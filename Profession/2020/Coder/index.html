<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/img/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/img/favicon.ico">
  <link rel="mask-icon" href="/img/apple-touch-icon.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hazyman.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":true},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="编码解码，回路习惯。">
<meta name="keywords" content="Life,Journey,Profession,Art,Coder,Design">
<meta property="og:type" content="article">
<meta property="og:title" content="Coder">
<meta property="og:url" content="https://hazyman.com/Profession/2020/Coder/index.html">
<meta property="og:site_name" content="生命之旅">
<meta property="og:description" content="编码解码，回路习惯。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-05-10T05:34:23.847Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Coder">
<meta name="twitter:description" content="编码解码，回路习惯。">

<link rel="canonical" href="https://hazyman.com/Profession/2020/Coder/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Coder | 生命之旅</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="生命之旅" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">生命之旅</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">常识、专业和价值。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/IPCreator1833" class="github-corner" title="IPCreator" aria-label="IPCreator" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://hazyman.com/Profession/2020/Coder/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/img/content/Kick-Off.jpg">
      <meta itemprop="name" content="IPCreator">
      <meta itemprop="description" content="Life is a journey.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="生命之旅">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Coder
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Profession/" itemprop="url" rel="index"><span itemprop="name">Profession</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/Profession/2020/Coder/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/Profession/2020/Coder/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><img data-src="/img/content/coder-cover.jpg" alt></p>
<blockquote>
<p>编码解码，<a href="https://hazyman.com/Profession/Brain/">回路</a><a href="https://hazyman.com/Profession/Habit/">习惯</a>。</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>保持节奏感、创造成就感</p>
</blockquote>
<p>世界正变得越来越自动化。因此我认为，并非每个人都需要学习编程，而是每个人都需要学习和理解如何实现自动化。<br>– <a href="https://daedtech.com/dont-learn-to-code-learn-to-automate/" target="_blank" rel="noopener">《不学习编码，学习自动化》</a></p>
<p><a href="https://github.com/DoctorWkt/acwj" target="_blank" rel="noopener">A Compiler Writing Journey</a><br>一个英文介绍，一步步讲解如何写一个最小的 C 语言编译器。</p>
<p><a href="https://www.coursera.org/professional-certificates/google-it-automation" target="_blank" rel="noopener">谷歌的 Python 课程</a><br>谷歌公司开发的免费 Python 课程，内容包含 Python 语言知识、Git 和计算机自动化。</p>
<p>Git 从2005年4月3日开始开发，4月6日完成开发，对外宣布，4月7日上线使用。<br>– <a href="https://en.wikipedia.org/wiki/Git#History" target="_blank" rel="noopener">维基百科</a></p>
<p>High一下!<br><a href="https://coolshell.cn" target="_blank" rel="noopener">酷 壳 – CoolShell</a><br>享受编程和技术所带来的快乐 – Coding Your Ambition</p>
<p><a href="http://evanw.github.io/float-toy/" target="_blank" rel="noopener">可视化浮点数</a></p>
<p>该网页提供32位浮点数和64位浮点数的二进制结构图，可以方便地设置每一个二进制位，显示对应的数字。</p>
<p><a href="https://socode.pro/" target="_blank" rel="noopener">socode.pd</a></p>
<p><img data-src="https://www.wangbase.com/blogimg/asset/202003/bg2020031601.jpg" alt></p>
<p>程序员的搜索工具，将各种网络资源汇总在一个搜索框里面。</p>
<p>我原本没想发明 Node.js，而是想用 Haskell 语言完成我的项目，但是失败了。我又不够聪明，没有能力改进 GHC（Haskell 语言的运行时），只好发明新的工具。<br>– <a href="http://www.stephendiehl.com/posts/decade.html" target="_blank" rel="noopener">Ryan Dahl，Node.js 的发明者</a></p>
<p>影响编程效率最大的因素，不是使用何种编程语言，而是昨晚你的睡眠是否充足。<br>– <a href="https://blog.wesleyac.com/posts/engineering-beliefs" target="_blank" rel="noopener">《我的软件工程信念》</a></p>
<p><img data-src="https://www.wangbase.com/blogimg/asset/202004/bg2020040114.jpg" alt><br><a href="https://www.florio.dev/20200328-letter-to-myself/" target="_blank" rel="noopener">写给新软件工程师的一封信（英文）</a></p>
<p>作者给进入这个行业的新人，提供了几点建议（上图），我觉得说得相当好。新人对这些建议肯定没有很深的体会，但是工作几年以后，再回头看，你会觉得这才是正确的路。</p>
<p>对我来说，英语是比 C 或 Java 更难写的语言。<br>– <a href="http://journal.stuffwithstuff.com/2020/04/05/crafting-crafting-interpreters/" target="_blank" rel="noopener">《解释器开发》的写作感受</a></p>
<p><a href="https://www.theverge.com/2020/4/22/21230816/microsoft-developers-bugs-machine-learning-numbers-statistics" target="_blank" rel="noopener">微软公司</a>透露，该公司 47,000名程序员每月产生近30,000个 bug。</p>
<p>我原想为自己的著作起名为《算法分析》，出版商说：”那将永远卖不出去”。<br>– <a href="https://www.quantamagazine.org/computer-scientist-donald-knuth-cant-stop-telling-stories-20200416/" target="_blank" rel="noopener">高德纳，《计算机编程艺术》的作者</a></p>
<h1 id="自学是门手艺"><a href="#自学是门手艺" class="headerlink" title="自学是门手艺"></a>自学是门手艺</h1><blockquote>
<p>One has no future if one couldn’t teach themself.</p>
</blockquote>
<p><strong>作者：李笑来</strong></p>
<p>特别感谢<strong>霍炬</strong>（<a href="https://github.com/virushuo" target="_blank" rel="noopener">@virushuo</a>）、<strong>洪强宁</strong>（<a href="https://github.com/hongqn" target="_blank" rel="noopener">@hongqn</a>) 两位良师诤友在此书写作过程中给予我的巨大帮助！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pseudo-code of selfteaching in Python</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">teach_yourself</span><span class="params">(anything)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> create():</span><br><span class="line">        learn()</span><br><span class="line">        practice()</span><br><span class="line">    <span class="keyword">return</span> teach_yourself(another)</span><br><span class="line"></span><br><span class="line">teach_yourself(coding</span><br></pre></td></tr></table></figure>
<hr>
<p>本书的版权协议为 <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">CC-BY-NC-ND license</a>。</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master/images/CC-BY-NC-ND.png?raw=true" alt="CC-BY-NC-ND"></p>
<hr>
<h2 id="01-前言"><a href="#01-前言" class="headerlink" title="01. 前言"></a>01. 前言</h2><p>想写一本关于自学能力的书，还真的不是一天两天的事，所以肯定不是心血来潮。</p>
<p>等我快把初稿框架搭完，跟霍炬说起我正在写的内容时，霍炬说：</p>
<blockquote>
<p>你还记得吗，你第一次背个包来我家的时候，咱们聊的就是咋写本有意思的编程书……</p>
</blockquote>
<p>我说：</p>
<blockquote>
<p>真是呢！十三年就这么过去了……</p>
</blockquote>
<p>不过，这次真的写了。写出来的其实并不是，或者说，并不仅仅是 “一本编程书”。</p>
<p>这本 “书” 是近些年我一直在做却没做完整的事情，讲清楚 “学习学习再学习”：</p>
<blockquote>
<p>学会学习之后再去学习……</p>
</blockquote>
<p>只不过，这一次我阐述地更具体 —— 不是 “学会学习”，而是 “学会自学” —— 这一点点的变化，让十多年前没写顺的东西，终于在这一次迎刃而解，自成体系。</p>
<blockquote>
<p>以前，我在写作课里讲，写好的前提就是 “Narrow down your topic” —— 把话题范围缩小缩小再缩小…… 这次算是给读者一个活生生的实例了罢。</p>
</blockquote>
<p>自学能力，对每个个体来说，是这个变化频率和变化幅度都在不断加大的时代里最具价值的能力。具备这个能力，不一定能直接增加一个人的幸福感（虽然实际上常常确实能），但它一定会缓解甚至消除一个人的焦虑 —— 若是在一个以肉眼可见的方式变化着的环境里生存，却心知肚明自己已然原地踏步许久，自己正在被这个时代甩在身后，谁能不焦虑呢？</p>
<p>实际上，这些年来我写的书，都是关于学习的，无论是《<a href="https://github.com/xiaolai/time-as-a-friend" target="_blank" rel="noopener">把时间当作朋友</a>》，还是《通往财富自由之路》，甚至《韭菜的自我修养》，你去看就知道，背后都是同样的目标：学习、进步 —— 甚至<strong>进化</strong>。</p>
<p>这一次的《自学是门手艺》，首先，可以看作是之前内容的 “实践版”：</p>
<blockquote>
<p>完成这本书的内容，起码会习得一个新技能：编程。</p>
</blockquote>
<p>更为重要的是，可以把《自学是门手艺》当作之前内容的 “升级版”：</p>
<blockquote>
<p>自学能力，是持续学习持续成长的发动机……</p>
</blockquote>
<p>仔细观察整个人群，你就会发现一个惊人且惊悚的事实：</p>
<blockquote>
<p><strong>至少有 99% 的人终生都没有掌握自学能力！</strong></p>
</blockquote>
<p>其实这个数字根本不夸张。根据 2017 年的统计数据，从 1977 年到 2017 年，40 年间全国大学录取人数总计为 1.15 亿左右（11518.2 万），占全国人口数量的 10% 不到，另外，这其中一半以上是专科生…… 你觉得那些 4% 左右的本科毕业生中，带着自学能力走入社会的比例是多少？不夸张地讲，我觉得 1% 都是很高的比例了 —— 所以，前面提到的 99% 都是很客气的说法。</p>
<p>绝大多数人，终其一生都没有自学过什么。他们也不是没学过，也不是没辛苦过，但事实却是：他们在有人教、有人带、有人逼的情况下都没真学明白那些基础知识…… 更可怕的是，他们学的那些东西中，绝大多数终其一生只有一个用处：考试。于是，考试过后，那些东西就 “考过即弃” 了…… 不得不承认，应试教育的确是磨灭自学能力的最有效方法。</p>
<p>在随后的生活里，尽管能意识到自己应该学点什么，常有 “要是我也会这个东西就好了” 的想法，但基本上百分之百以无奈结束 —— 再也没有人教、再也没有人带、再也没有人逼…… 于是，每次 “决心重新做人” 都默默地改成 “继续做人” 而后逢年过节再次许愿 “重新做人”……</p>
<p>这是有趣而又尴尬的真相：</p>
<blockquote>
<p>没有不学习的人。</p>
</blockquote>
<p>你仔细观察就知道了，就算被你认为不学无术的人，其实也在学习，只不过，他们的选择不同，他们想学的是投机取巧，并天天琢磨怎样才能更好地投机取巧……</p>
<p>但他们不是最倒霉的人。最倒霉的人是那种人，也 “认真学了”，可总是最终落得个越来越焦虑的下场……<br>经常有一些人指责另外一些人 “贩卖焦虑” —— 根据我的观察，这种指责的肤浅在于，焦虑不是被卖方贩卖的产品，焦虑其实是买方长期自行积累的结果。</p>
<p><strong>别人无法贩卖给你焦虑，是你自己焦虑</strong> —— 是你自己在为自己不断积累越来越多的焦虑……</p>
<p>然而，又有谁不想解决掉焦虑呢？又有谁不想马上解决掉焦虑呢？</p>
<p>于是，你焦虑，你就要找解决方案。而焦虑的你找到的解决方案，就是花个钱买本书，报个班，找个老师，上个课…… 这能说是别人贩卖焦虑给你吗？</p>
<p>自学能力强的人，并非不花钱，甚至他们花的钱可能更多。他们也花钱买书，而且买更多的书；他们也可能花钱上课，而且要上就上最好的课、最好的班；他们更经常费尽周折找到恰当的人咨询、求教、探讨 —— 所以，事实上，他们更可能花了更多的钱……</p>
<p>但自学能力强的人不焦虑，起码他们不会因为学习以及学习过程而焦虑 —— 这是重大差别。</p>
<p>而焦虑的大多数，并不是因为别人贩卖焦虑给他们，他们才 “拥有” 那些焦虑 —— 他们一直在焦虑，并且越来越焦虑……</p>
<p>为什么呢？总也学不会、学不好，换做是你，你不焦虑吗？！</p>
<p>生活质量就是这样一点一点被消磨掉的 —— 最消耗生活质量的东西，就是焦虑。</p>
<p>我相信，若是《自学是门手艺》这本书真的有用，它的重要用处之一就是能够缓解你的焦虑，让你明白，首先焦虑没用，其次，有办法也有途径让你摆脱过往一事无成的状况，逐步产生积累，并且逐步体会到那积累的作用，甚至最后还能感觉到更多积累带来的加速度…… 到那时候，焦虑就是 “别人的事情” 了。</p>
<p>自学没有什么 “秘诀”。<strong>它是一门手艺</strong>，并且，严格意义上来讲，它<strong>只是</strong>一门手艺。</p>
<p>手艺的特点就是<strong>无需天分</strong>。手艺的特点就是<strong>熟练程度决定一切</strong>。从这一点上来看，自学这门手艺和擀饺子皮没什么区别 —— 就那点事，刚开始谁都笨手笨脚，但熟练了之后，就那么回事…… 而已。</p>
<p>做什么事都有技巧，这不可否认。</p>
<p>自学当然也有技巧…… 不过，请做好思想准备：</p>
<blockquote>
<p>这儿的空间，<strong>没什么新鲜</strong>……</p>
</blockquote>
<p>—— 这是崔健一首歌里的歌词片段，但放在这里竟然非常恰当到位。</p>
<p><strong>一切与自学相关的技巧都是老生常谈</strong>。</p>
<p>中国人说，熟能生巧；老外说，Practice makes perfect —— 你看，与自学相关的技巧，干脆不分国界……</p>
<p>—— 因为这事人类从起点开始就没变过 —— 每代人都有足够多的人在自学这件事上挣扎…… 有成的有不成的；成的之中有大成有小成…… 可有一件事同样不变：留下的文字、留下的信息，都是大成或者小成之人留下的，不成的人不声不响就销声匿迹。</p>
<p>并且，从各国历史上来看，自学技巧这个话题从未涉及到政治，无论是在东方还是西方都是如此。结果就是，在自学能力这个小领域中，留下并流传下来的信息，几乎从未被审查，从未被摧毁，从未被侵犯，从未被扭曲 —— 真的是个特别罕见的 “纯净的领域” —— 这真的是整个人类不可想像之意外好运。</p>
<p>这就是为什么一切的自学技巧到最后肯定是老生常谈的原因。</p>
<p>大部分年轻人讨厌老生常谈。</p>
<p>但这还真的是被误导的结果。年轻人被什么误导了呢？</p>
<p>每一代人都是新鲜出生，每一代人出生时都在同一水准…… 随着时间的推移，总是庸者占绝大多数，这个 “绝大多数” 不是 51%，不是 70%，而是 99%！—— 年轻人吃亏就吃在没把这个现象考虑进来。</p>
<p>也就是说，虽然有用的道理在不断地传播，可终究还是 99% 的人做不到做不好，于是：</p>
<blockquote>
<p>讲大道理的更可能是庸者、失败者，而不是成功者。</p>
</blockquote>
<p>人类有很多天赋。就好像我反复提到的那样，“就算不懂也会用” 是人类的特长。同样的道理，人类在这方面同样擅长：</p>
<blockquote>
<p>无论自己什么样，在 “判断别人到底是不是真的很成功” 上，基本上有 99% 的把握……</p>
</blockquote>
<p>所以，十岁不到的时候，绝大多数小朋友就 “看穿” 了父母，后来再 “看穿” 了老师…… 发现他们整天说的都是他们自己做不到的事情…… 于是误以为自己 “看穿” 了整个世界。</p>
<p>那时候小朋友们还没学、或者没学好概率这个重要知识，于是，他们并不知道那只不过是 99% 的情况，而且更不知道 “<strong>因素的重要性与它所占的比例常常全无正相关</strong>”，所以当然不知道那自己尚未见到的 <code>1%</code> 才可能是最重要的……</p>
<p>于是，99% 的小朋友们一不小心就把自己 “搭了进去”：</p>
<blockquote>
<p>不仅讨厌老生常谈，而且偏要对着干，干着干着就把自己变成了另外一个属于那 99% 的另外一个老生……</p>
</blockquote>
<p>这是 99% 的人终其一生的生动写照。</p>
<p>做 <code>1%</code> 很难吗？真的很简单，有时仅仅一条就可能奏效：</p>
<blockquote>
<p><strong>在自学这件事上，重视一切老生常谈……</strong></p>
</blockquote>
<p>很难吗？不难，只不过是一个 “开关” 而已。</p>
<p>当我动手写这本 “书” 的时候，是 47 岁那年（2019）的春节前 —— 显然，这个时候我也早就是一位 “老生” 了…… 并且，这些道理我已经前后讲了二十年！算是 “常谈” 甚至 “长谈” 了罢……</p>
<p>开始在新东方教书那年，我 28 岁；用之前那一点三脚猫的编程能力辅助着去写《TOEFL 核心词汇 21 天突破》是 2003 年；后来写《<a href="https://github.com/xiaolai/time-as-a-friend" target="_blank" rel="noopener">把时间当作朋友</a>》是 2007 年，这本书的印刷版出版发行是在 2009 年；再后来陆续写了很多内容，包括没有纸质版发行只有在线版的《人人都能用英语》（2013）；以及因为在罗振宇的得到 App 上开专栏，把之前写过的《学习学习再学习》重构且扩充而出版的《通往财富自由之路》（2017）；甚至连《韭菜的自我修养》（2018）都是讲思考、学习、和认知升级的……</p>
<p>说来说去，就那些事 —— <strong>没什么新鲜</strong>。</p>
<p>这中间也有很多写了却没写完，或者因为写得自己不满意扔在柜子里的东西，比如《人人都是工程师》（2016）—— 哈！我就是这么坚韧，有了目标就会死不放弃…… 3 年后的今天，我终于用那个时候完全想不到的方式完成了当时的目标，并且，做到了很多 3 年前自己都完全想象不到的事情。</p>
<p>在写当前这本《自学是门手艺》的过程中，我从一开始就干脆没想给读者带来什么 “新鲜” 的或者 “前所未见” 的自学技巧 —— 因为真的就没有，根本就没有什么新鲜的自学技巧…… 没有，真的没有 —— 至少，我自己这么久了还是真的没见识过。</p>
<p>然而，我算是最终能做到的人。知道、得到、做到之间，均各不相同。</p>
<p>二十年前，在拥挤的课堂里坐在台下听我讲课的小朋友们，绝大多数在当时应该没有想到他们遇到了这样一个人 —— 二十年后，刚认识我的人也不会自动知道我是这样的人。</p>
<p>但是，这些年里，看到我在一点一点进步、从未原地踏步的人很多很多…… 我猜，所谓的 “榜样”，也不过如此了罢。</p>
<p>不夸张地讲，这可能是当前世界上<strong>最硬核的鸡汤书</strong>了 —— 因为，虽然它就是鸡汤（李笑来自认就是个鸡汤作者），但它不是 “只是拿话糊弄你” 那种，也不是 “只不过是善意的鼓励” 那种，它是那种 “教会你人生最重要的技能” 的鸡汤，并且还不仅仅只有一种技能，起码两个：“自学能力” 和 “编程能力”…… 而这两个能力中的无论哪一种，都是能确定地提高读者未来收入的技能，对，就是 <code>100%</code> 地确定 —— 有个会计专业的人求职的时候说 “我还会编程” 且还能拿出作品，你看看他可不可能找不到工作？你看看他是不是能薪水更高？</p>
<p><code>#!</code> —— 这是个程序员能看懂的梗。</p>
<p>关键在于，这个老生不是说说而已的老生，他是能够<strong>做到</strong>的人：</p>
<blockquote>
<ul>
<li>一个末流大学的会计专业毕业的人不得已去做了销售；</li>
<li>这个销售后来去国内最大的课外辅导机构当了 7 年 TOEFL/GRE/GMAT 老师；</li>
<li>这个英语老师后来同时成了很多畅销书、长销书的作者；</li>
<li>这个作者后来居然成了著名天使投资人；</li>
<li>这个投资人后来竟然写了本关于编程入门的书籍；</li>
<li>这本 “书” 最终竟然还是一个完整的产品，不仅仅是 “一本书”……</li>
</ul>
</blockquote>
<p>然而呢？</p>
<p>—— 然而，即便是这样的老生，也讲不出什么新鲜道理。</p>
<p>因为啊，历史上留下来的所有关于自学的技巧，都是人类史上最聪明的人留下来的 —— 你我这样的人，照做就可以了…… 现在你明白怎么回事了吧？</p>
<p><strong>记住罢</strong> ——</p>
<blockquote>
<p><strong>千万不要一不小心就把自己搭进去……</strong></p>
</blockquote>
<p style="text-align: right"><strong>李笑来</strong></p><br><p style="text-align: right">初稿完成于 <em>2019</em> 年 <em>2</em> 月 <em>27</em> 日</p>

<h2 id="02-如何证明你真的读过这本书？"><a href="#02-如何证明你真的读过这本书？" class="headerlink" title="02. 如何证明你真的读过这本书？"></a>02. 如何证明你真的读过这本书？</h2><h3 id="積ん読"><a href="#積ん読" class="headerlink" title="積ん読"></a>積ん読</h3><p>日语里有个很好玩的词，“<strong>積ん読</strong>”（<a href="https://en.wikipedia.org/wiki/Tsundoku" target="_blank" rel="noopener">tsundoku</a>）：</p>
<blockquote>
<p>指那些买回来堆在那里还没读过的（甚至后来干脆不看了的）书……</p>
</blockquote>
<p>细想想，每个人都有很多很多 “積ん読”。小时候我们拿回家的教科书中就有相当一部分，其实就是 “積ん読”，虽然那时候掏钱买书的是父母，不仔细看、或者干脆不看的时候，也知道自己在偷懒…… 再后来就是 “主动犯罪” 了 —— 比如，很多人买到手里的英语词汇书是根本就没有翻到过第二个列表的，乃至于过去我常常开玩笑说，中国学生都认识一个单词，<em>abandon</em>，不是吗？这个单词是很多很多人 “决心重新做人” 而后 “就这样罢” 的铁板钉钉的见证者。</p>
<p>在没有电子书的时代，印刷版书籍多少还有一点 “装饰品” 功用，可是到了电子书时代，谁知道你的设备里有多少付费书籍呢？攒下那么多，其实并没有炫耀的地方，给谁看呢？据说，Kindle 的后台数据里可以看到清楚的 “打开率”，大抵上也是在 &frac14; ~ &frac13; 之间，也就是说，差不多有 &frac23; ~ &frac34; 的电子书籍被购买下载之后，从来就没有被打开过。</p>
<p>如此看来，付费之后并不阅读，只能欺骗一个对象了：自己。跟心理学家们之前想象的不同，我认为人们通常是不会欺骗自己的，至少很难 “故意欺骗自己”。所以，对于 “买了之后坚决不读” 这个现象，我不认为 “给自己虚妄的满足感” 是最好的解释。</p>
<p>更朴素一点，更接近真相的解释是：</p>
<blockquote>
<p>那百分之七八十的人，其实是想着给自己一个希望……</p>
</blockquote>
<p>—— 等我有空了一定看。嗯。</p>
<p>说来好笑，其实每个人共同拥有的目标之一是这样的：</p>
<blockquote>
<p>成为前百分之二十的少数人……</p>
</blockquote>
<p>然而，PK 掉百分之七八十的人的方法真的很简单很简单啊：</p>
<blockquote>
<p>把买来的书都真真切切地认真读过就可以了。</p>
</blockquote>
<p>这实在是太简单了罢？！可是…… 我知道你刚刚那个没出息的闪念：</p>
<blockquote>
<p>那我少买书甚至不买书不就可以了吗？</p>
</blockquote>
<p>你自己都知道这是荒谬的，却忍不住为你的小聪明得意 —— 其实吧，幸亏有你们在，否则我们怎么混进前百分之二十呢？</p>
<h3 id="PoW"><a href="#PoW" class="headerlink" title="PoW"></a>PoW</h3><p>比特币这个地球上第一个真正被证明为可行的区块链应用中有一个特别重要的概念，叫做 “<strong>工作证明</strong>”（Proof of Work）—— 你干活了就是干活了，你没干活就是没干活，你的工作是可被证明的……</p>
<p>借用这个思路，我设计了个方法，让你有办法证明自己就是看过这本书，就是读完了这本书 —— 你能向自己也向别人证明自己曾经的工作…… 是不是挺好？</p>
<p>证明的方法是使用 <a href="https://github.com" target="_blank" rel="noopener">github.com</a> 这个网站以及版本控制工具 <strong>git</strong>。</p>
<h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><p>请按照以下步骤操作：</p>
<blockquote>
<ol>
<li>注册 <a href="https://github.com" target="_blank" rel="noopener">github.com</a> 帐号 —— 无论如何你都必须有 github 账户；</li>
<li>使用浏览器访问 <a href="https://github.com/selfteaching/the-craft-of-selfteaching" target="_blank" rel="noopener">https://github.com/selfteaching/the-craft-of-selfteaching</a>；</li>
<li>在页面右上部找到 “Fork” 按钮，将该仓库 Fork 到你自己的账户中；</li>
<li>使用 <code>git clone</code> 命令或者使用 <a href="https://desktop.github.com/" target="_blank" rel="noopener">Desktop for Github</a> 将 <a href="https://github.com/selfteaching/the-craft-of-selfteaching" target="_blank" rel="noopener">the craft of selfteaching</a> 这个你 Fork 过来的仓库克隆到本地；</li>
<li>按照 <a href="T-appendix.jupyter-installation-and-setup.md">Jupyterlab 的安装与配置</a> 的说明在本地搭建好 Jupyterlab —— 如果在 Jupyterlab 中浏览本书的话，其中的所有代码都是可以 “当场执行” 的，并且，你还可以直接改着玩……</li>
<li>在阅读过程中，可以不断通过修改文章中的代码作为练习 —— 这样做的结果就是已阅读过的文件会发生变化…… 每读完一章，甚至时时刻刻，你都可以通过 <code>git commit</code> 命令向你自己 Fork 过来的仓库提交变化 —— 这就是你的阅读工作证明；</li>
<li>仓库里有一个目录，<code>my-notes</code>，你可以把你在学习过程中写的笔记放在那里；</li>
<li>仓库里还有另外一个目录，<code>from-readers</code>；那是用来收集读者反馈的 —— 将来你可以写一篇《我的自学之路》，放在这个目录里，单独创建一个分支，而后提交 <code>pull request</code>，接受其他读者投票，若是达到一定的赞同率，那么你的文章就会被收录到主仓库中被更多人看到，激励更多的人像你一样走上自学之路……</li>
</ol>
</blockquote>
<p>当然，为了这么做，你还要多学一样反正你早晚都必须学会的东西，Git —— 请参阅附录《<a href="T-appendix.git-introduction.md">Git 入门</a>》。</p>
<p>时间就是这样，我们没办法糊弄它。而有了 git 这样的工具之后，我们在什么时候做了什么样的工作，是很容易证明的 —— 这对我们来说真是天大的好事。</p>
<h3 id="如何使用-Pull-Request-为这本书校对"><a href="#如何使用-Pull-Request-为这本书校对" class="headerlink" title="如何使用 Pull Request 为这本书校对"></a>如何使用 Pull Request 为这本书校对</h3><p>另外，在你阅读的过程中，发现有错别字啊、代码错误啊，甚至有 “更好的表述” 等等，都可以通过 <code>pull request</code> 来帮我改进 —— 这也是一种 “工作证明”。</p>
<p>(1) 使用浏览器访问 <a href="https://github.com/selfteaching/the-craft-of-selfteaching" target="_blank" rel="noopener">https://github.com/selfteaching/the-craft-of-selfteaching</a></p>
<p>(2) 点击右上角的 “Fork 按钮”，将该仓库 Fork 到你的 Github 账户中</p>
<p><img data-src="/images/github-fork.png?raw=true" alt></p>
<p>(3) 创建一个新分支，可以取名为 <code>from-&lt;your_username&gt;</code>，比如，<code>by git.basic.tutorial</code>；之后点击 Create Branch 建立新分支。</p>
<p><img data-src="/images/github-new-branch.png?raw=true" alt></p>
<p>(4) 在新分支下进行修改某个文件，而后提交 —— 提交前不要嫌麻烦，一定要在 Comment 中写清楚修改说明：</p>
<p><img data-src="/images/github-commit.png?raw=true" alt></p>
<p>以上示例图片中是修改了 README.md 文件 —— 事实上，你应该提交的是的确有必要的校对。</p>
<p>另外，<strong>请注意</strong>：在创建分支之前，要将你的 Fork 更新到最新版。具体操作方法见下一节《如何在 Github 网站上将自己的 Fork 与原仓库同步》。</p>
<p>(5) 在页面顶部选择 Pull request 标签：</p>
<p><img data-src="/images/github-pull-request.png?raw=true" alt></p>
<p>而后点击 <code>Compare &amp; pull request</code> 按钮 —— 如果看不到这个按钮，那就点击下面刚刚修改文件的链接，如上图中的 “Update README.md”（这是你刚刚提交修改时所填写的标题）。</p>
<p><img data-src="/images/github-open-pull-request.png?raw=true" alt></p>
<p>确认无误之后，点击 <code>Create pull request</code> 按钮。</p>
<p><img data-src="/images/github-create-pull-request.png?raw=true" alt></p>
<p>(6) 随后，Github 用户 <a href="https://github.com/xiaolai" target="_blank" rel="noopener">@xiaolai</a> —— 就是我，即，the-craft-of-selfteaching 这个仓库的所有者，会被通知有人提交了 Pull request，我会看到：</p>
<p><img data-src="/images/github-confirm-merge.png?raw=true" alt></p>
<p>在我确认这个 Pull request 修改是正确的、可接受的之后，我就会按 <code>Merge pull request</code> 按钮 —— 如此这般，一个修正就由你我共同完成了。</p>
<p><img data-src="/images/github-merged-pull-request.png?raw=true" alt></p>
<p><strong>注意</strong></p>
<p>提交 Pull request 的时候，最佳策略如下：</p>
<blockquote>
<ul>
<li>提交 Pull request 之前，必须先将你的 Fork 的 master 与原仓库同步到最新；</li>
<li>从 master 创建 <strong>新的 branch</strong> 进行增补、修改等操作；</li>
<li>尽量每次只提交一个小修改；</li>
<li>提交时尽量简短且清楚地说明修改原因；</li>
<li>耐心等待回复。</li>
</ul>
</blockquote>
<p>当自己的 Fork 过来的仓库已经被你在本地 “玩残” 了的时候，它千万不能被当作用来提交 Pull request 的版本。自己本地怎么玩都无所谓，但需要向别人提交 Pull request 的时候，必须重新弄一个当前最新版本到本地，而后再在其基础上修改。</p>
<h3 id="如何在-Github-网站上将自己的-Fork-与原仓库同步"><a href="#如何在-Github-网站上将自己的-Fork-与原仓库同步" class="headerlink" title="如何在 Github 网站上将自己的 Fork 与原仓库同步"></a>如何在 Github 网站上将自己的 Fork 与原仓库同步</h3><p>(1) 在你的 Fork 页面中如下图所示，点击 <code>Compare</code> 链接：</p>
<p><img data-src="/images/sync-fork-1.png?raw=true" alt></p>
<p>(2) 将 <code>base repository</code> 更改成当前自己的 Fork，在图示中即为 <code>gitbasictutorial/the-craft-of-selfteaching</code>：</p>
<p><img data-src="/images/sync-fork-2.png?raw=true" alt></p>
<p>(3) 这时候，页面会显示 <code>There isn&#39;t anything to compare.</code>，因为你在比较 “自己” 和 “自己”。点击 <code>compare across forks</code> 链接：</p>
<p><img data-src="/images/sync-fork-3.png?raw=true" alt></p>
<p>(4) 将 <code>head repository</code> 更改成 Upstream Repository（即，上游仓库），在图示中即为 <code>selfteaching/the-craft-of-selfteaching</code>：</p>
<p><img data-src="/images/sync-fork-4.png?raw=true" alt></p>
<p>(5) 稍等片刻，你会看到比较结果；而后你可以创建一个 Pull request —— 这是一个由你自己向你自己的 Fork 仓库提交的 Pull request：</p>
<p><img data-src="/images/sync-fork-5.png?raw=true" alt></p>
<p>(6) 而后你在 <code>Pull requests</code> 标签页里会看到你刚刚提交的 Pull request：</p>
<p><img data-src="/images/sync-fork-6.png?raw=true" alt></p>
<p>(7) 同意并合并之后的结果是，你的 Fork 与上游仓库同步完成了：</p>
<p><img data-src="/images/sync-fork-7.png?raw=true" alt></p>
<p>当然，有时会出现一些你无法解决的问题，那么，还有一个最后的方法：</p>
<blockquote>
<p>将你的 Fork 删除，而后重新到 <a href="https://github.com/selfteaching/the-craft-of-selfteaching" target="_blank" rel="noopener">https://github.com/selfteaching/the-craft-of-selfteaching</a> 页面按一次 <code>Fork</code> 按钮……</p>
</blockquote>
<h3 id="如何使用-github-记录自己的学习过程"><a href="#如何使用-github-记录自己的学习过程" class="headerlink" title="如何使用 github 记录自己的学习过程"></a>如何使用 github 记录自己的学习过程</h3><p>你可以在本地建立一个分支（branch），例如，取名为 <code>study</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git branch study</span><br><span class="line">git checkout study</span><br></pre></td></tr></table></figure>
<p>如此这般之后，你在本地工作目录中所做的任何修改，都可以提交到 <code>study</code> 这个分支之中。</p>
<p>你每次在 Jupyterlab 中浏览 <code>ipynb</code> 文件，按 <code>^ + Enter</code> 执行 code cell 中的代码的时候，该文件都会发生一些变化；你也可以随意修改文件中的任何地方，比如，添加一个 code cell，将某段代码从头至尾 “敲” 一遍；也可以修改某个 code cell 中的代码看看执行结果有什么不同；还可以添加或者修改任何 markdown cell —— 就当自己做笔记了……</p>
<p>总而言之，当你阅读完某一章节并如上所说那样做了一些改动之后，那个 <code>ipynb</code> 文件就发生了一些变化。于是，你就可以执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -am <span class="string">'my study result'</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
<p>如此这般，在 <code>study</code> 这个分支中就记录着你的学习轨迹。</p>
<p>当然，如果在这过程中，你发现本书自身有需要校对的地方，那么，你需要切换到 <code>master</code> 分支，执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>
<p>而后再修改，进而按照上一节的方法提交 Pull request。</p>
<p>未来，在 <a href="https://github.com/selfteaching" target="_blank" rel="noopener">https://github.com/selfteaching</a> 下我会专门设置一个 repo，用来自动扫描 github 上本书的学习记录 —— 这种记录在过往的书籍当中是不可能存在的，然而，现在却可以了。在我看来，将来这种记录的作用甚至有可能比 “学历” 还要重要。</p>
<h1 id="为什么一定要掌握自学能力？"><a href="#为什么一定要掌握自学能力？" class="headerlink" title="为什么一定要掌握自学能力？"></a>为什么一定要掌握自学能力？</h1><p>一句话解释清楚：</p>
<blockquote>
<p>没有自学能力的人没有<strong>未来</strong>。</p>
</blockquote>
<p>有两个因素需要深入考虑：</p>
<blockquote>
<ul>
<li>未来的日子还很长</li>
<li>这世界进步得太快</li>
</ul>
</blockquote>
<p>我有个观察：</p>
<blockquote>
<p>很多人都会不由自主地去复刻父母的人生时刻表。</p>
</blockquote>
<p>比如，你也可能观察到了，父母晚婚的人自己晚婚的概率更高，父母晚育的人自己晚育的概率也更高……</p>
<p>再比如，绝大多数人的内心深处，会不由自主地因为自己的父母在五十五岁的时候退休了，所以就默认自己也会在五十五岁前后退休…… 于是，到了四十岁前后的时候就开始认真考虑退休，在不知不觉中就彻底丧失了斗志，早早就活得跟已经老了很多岁似的。</p>
<p>但是，这很危险，因为很多人完全没有意识到自己所面临的人生，与父母所面临的人生可能完全不一样 —— 各个方面都不一样。单举一个方面的例子，也是比较容易令人震惊的方面：</p>
<blockquote>
<p>全球范围内都一样，在过去的五十年里，人们的平均寿命预期增长得非常惊人……</p>
</blockquote>
<p>拿中国地区做例子，根据世界银行的数据统计，中国人在出生时的寿命预期，从 1960 年的 <em>43.73</em> 岁，增长到了 2016 年的 <em>76.25</em> 岁，56 年间的增幅竟然有 <strong>74.39%</strong> 之多！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">data = np.genfromtxt(<span class="string">'life-expectancy-china-1960-2016.txt'</span>,</span><br><span class="line">                     delimiter=<span class="string">','</span>,</span><br><span class="line">                     names=[<span class="string">'x'</span>, <span class="string">'y'</span>])</span><br><span class="line">da1960  = data[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">da2016  = data[<span class="number">-1</span>][<span class="number">1</span>]</span><br><span class="line">increase = (da2016 - da1960) / da1960</span><br><span class="line">note = <span class="string">'from &#123;:.2f&#125; in 1960 to &#123;:.2f&#125; in 2016, increased  &#123;:.2%&#125;'</span>\</span><br><span class="line">    .format(da1960, da2016, increase)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">plt.plot(data[<span class="string">'x'</span>], data[<span class="string">'y'</span>])</span><br><span class="line">plt.ylabel(<span class="string">'Life Expectancy from Birth'</span>)</span><br><span class="line">plt.tick_params(axis=<span class="string">'x'</span>, rotation=<span class="number">70</span>)</span><br><span class="line">plt.title(<span class="string">'CHINA\n'</span> + note)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plt.savefig('life-expectancy-china-1960-2016.png', transparent=True)</span></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># data from:</span></span><br><span class="line"><span class="comment"># https://databank.worldbank.org/data/reports.aspx?source=2&amp;series=SP.DYN.LE00.IN</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/Part.1.A.better.teachyourself_2_0.png?raw=true" alt="png"></p>
<p>如此发展下去，虽然人类不大可能永生不死，但平均寿命依然在持续延长是个不争的事实。与上一代不同，现在的千禧一代，需要面对的是百岁人生 —— 毫无疑问，不容置疑。</p>
<p>这么长的人生，比默认的想象中可能要多出近一倍的人生，再叠加上另外一个因素 —— 这是个变化越来越快的世界 —— 会是什么样子？</p>
<p>我是 1972 年出生的。从交通工具来看，我经历过出门只能靠步行，大街上都是牛车马车，机动车顶多见过拖拉机，到有自行车，到见过摩托车，到坐小汽车，到自己开车，到开有自动辅助驾驶功能的电动车…… 从阅读来看，我经历过只有新华书店，到有网络上的文字，到可以在当当上在线买到纸质书，到有了国际信用卡后可以在 Amazon 上第一时间阅读新书的电子版、听它的有声版，到现在可以很方便地获取最新知识的互动版，并直接参与讨论…… 从技能上来看，我经历过认为不识字是文盲，到不懂英语是文盲，到不懂计算机是文盲，到现在，不懂数据分析的基本与文盲无异……</p>
<p>我也见识过很多当年很有用很赚钱很令人羡慕的技能 “突然” 变成几乎毫无价值的东西，最明显的例子是驾驶。也就是二十多年前，的哥还是很多人羡慕的职业呢！我本科的时候学的是会计专业，那时候我们还要专门练习打算盘呢！三十年之后的今天，就算有人打算盘打得再快，有什么具体用处嘛？我上中学的时候，有个人靠出版字帖赚了大钱 —— 那时候据说只要写字漂亮就能找到好工作；可今天，写字漂亮与否还是决定工作好坏的决定性因素吗？打印机很便宜啊！</p>
<p>这两个因素叠加在一起的结果就是，这世界对很多人来说，其实是越来越残忍的。</p>
<p>我见过太多的同龄人，早早就停止了进步，早早就被时代甩在身后，早早就因此茫然不知所措 —— 早早晚晚，你也会遇到越来越多这样的人。他们的共同特征只有一个：</p>
<blockquote>
<p>没有自学能力</p>
</blockquote>
<p>有一个统计指数，叫做人类发展指数（Human Development Index），它的曲线画出来，怎么看都有即将成为指数级上升的趋势。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">lebdata = np.genfromtxt(<span class="string">'life-expectancy-china-1960-2016.txt'</span>,</span><br><span class="line">                        delimiter=<span class="string">','</span>,</span><br><span class="line">                        names=[<span class="string">'x'</span>, <span class="string">'y'</span>])</span><br><span class="line"></span><br><span class="line">hdidata = np.genfromtxt(<span class="string">'hdi-china-1870-2015.txt'</span>,</span><br><span class="line">                        delimiter=<span class="string">','</span>,</span><br><span class="line">                        names=[<span class="string">'x'</span>, <span class="string">'y'</span>])</span><br><span class="line"></span><br><span class="line">plt.plot(hdidata[<span class="string">'x'</span>], hdidata[<span class="string">'y'</span>], label=<span class="string">'Human Development Index'</span>)</span><br><span class="line">plt.tick_params(axis=<span class="string">'x'</span>, rotation=<span class="number">70</span>)</span><br><span class="line">plt.title(<span class="string">'China: 1870 - 2015'</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(lebdata[<span class="string">'x'</span>], lebdata[<span class="string">'y'</span>] * <span class="number">0.005</span>, label=<span class="string">'Life Expectancy from Birth'</span>)</span><br><span class="line">plt.plot(secondary_y=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line"><span class="comment"># plt.savefig('human-development-index-china-1870-2015.png', transparent=True)</span></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># link:</span></span><br><span class="line"><span class="comment"># https://ourworldindata.org/human-development-index</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># data from:</span></span><br><span class="line"><span class="comment"># blob:https://ourworldindata.org/44b6da71-f79e-42ab-ab37-871e4bd256e9</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/Part.1.A.better.teachyourself_4_0.png?raw=true" alt="png"></p>
<p>社会发展越来越快，你要面对的人生越来越长，在那一段与你的直觉猜想并不相同的漫漫人生路上，你居然没有磨练过自学能力，竟然只能眼睁睁地看着自己被甩下且无能为力，难道接下来要在那么长的时间里 “苦中作乐” 吗？</p>
<p>没有未来的日子，怎么过呢？</p>
<p>我本科学的是会计，研究生跑到国外读宏观经济学没读完，跑回国内做计算机硬件批发，再后来去新东方应聘讲授托福课程，离开新东方之后创业，再后来做投资，这期间不断地写书…… 可事实上，我的经历在这个时代并不特殊。有多少人在后来的职业生涯中所做的事情与当年大学里所学的专业相符呢？</p>
<p>纽约联邦储蓄银行在 2012 年做过一个调查，发现人们的职业与自己大学所学专业相符的比例连 <em>30%</em> 都不到。而且，我猜，这个比例会持续下降的 —— 因为这世界变化快，因为大多数教育机构与世界发展脱钩的程度只能越来越严重……</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">labels = [<span class="string">'Major Match'</span>, <span class="string">''</span>]</span><br><span class="line">sizes = [<span class="number">273</span>, <span class="number">727</span>]</span><br><span class="line">colors = [<span class="string">'#E2E2E2'</span>, <span class="string">'#6392BF'</span>]</span><br><span class="line">explode = (<span class="number">0</span>, <span class="number">0.08</span>)</span><br><span class="line">plt.figure(figsize=(<span class="number">7</span>, <span class="number">7</span>))</span><br><span class="line">plt.pie(sizes,</span><br><span class="line">        labels=labels,</span><br><span class="line">        explode=explode,</span><br><span class="line">        autopct=<span class="string">'%1.1f%%'</span>,</span><br><span class="line">        colors=colors,</span><br><span class="line">        startangle=<span class="number">270</span>,</span><br><span class="line">        shadow=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># plt.savefig('major-match-job.png', transparent=True)</span></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># data from:</span></span><br><span class="line"><span class="comment"># https://libertystreeteconomics.newyorkfed.org/2013/05/do-big-cities-help-college-graduates-find-better-jobs.html</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/Part.1.A.better.teachyourself_6_0.png?raw=true" alt="png"></p>
<p>绝大多数人终生都饱受<strong>时间幻觉</strong>的拖累。</p>
<p>小时候觉得时间太长，那是幻觉；长大了觉得时间越来越快，那还是幻觉 —— 时间从来都是匀速的。最大的幻觉在于，总是以为 “时间不够了” —— 这个幻觉最坑人。许多年前，有一次我开导我老婆。她说，“啊？得学五年才行啊？！太长了！” 我说，</p>
<blockquote>
<p>“你回头看看呗，想想呗，五年前你在做什么？是不是回头一看的时候，五年前就好像是昨天？道理是一样的，五年之后的某一天你回头想今天，也是 ‘一转眼五年就过去’ 了…… 只不过，你今天觉得需要时间太多，所以不肯学 —— 但是，不管你学还是不学，五年还是会 ‘一转眼就过去’ 的…… 到时候再回头，想起这事的时候，没学的你，一定会后悔 —— 事实上，你已经有很多次后悔过 ‘之前要是学了就好了’，不是吗？”</p>
</blockquote>
<p>现在回头看，开导是非常成功的。十多年后的今天，她已经真的可以被称为 “自学专家” —— 各种运动在她那儿都不是事。健身，可以拿个北京市亚军登上健与美杂志封面；羽毛球，可以参加专业比赛；潜水，潜遍全球所有潜水胜地，到最后拿到的各种教练证比她遇到的各地教练的都多、更高级；帆船，可以组队横跨大西洋；爬山，登上喜马拉雅……</p>
<p>都说，人要有一技之长。那这一技究竟应该是什么呢？</p>
<blockquote>
<p>自学能力是唯一值得被不断磨练的长技。</p>
</blockquote>
<p>磨练出自学能力的好处在于，无论这世界需要我们学什么的时候，我们都可以主动去学，并且还是马上开始 —— 不需要等别人教、等别人带。</p>
<p>哪怕有很强的自学能力的意思也并不是说，什么都能马上学会、什么都能马上学好，到最后无所不精无所不通…… 因为这里有个时间问题。无论学什么，都需要耗费时间和精力，与此同时更难的事情在于不断填补耐心以防它过早耗尽。另外，在极端的情况下，多少也面临天分问题。比如身高可能影响打篮球的表现，比如长相可能影响表演的效果，比如唱歌跑调貌似是很难修复的，比如有些人的粗心大意其实是基因决定的，等等。不过，以我的观察，无论是什么，哪怕只是学会一点点，都比不会强。哪怕只是中等水平，就足够应付生活、工作、养家糊口的需求。</p>
<p>我在大学里学的是会计专业，毕业后找不到对口工作，只好去做销售 —— 没人教啊！怎么办？自学。也有自学不怎么样的时候，比如当年研究生课程我就读不完。后来想去新东方教书 —— 因为听说那里赚钱多 —— 可英语不怎么样啊！怎么办？自学。离开新东方去创业，时代早就变了，怎么办？自学，学的不怎么样，怎么办？硬挺。虽然创业这事后来也没怎么大成，但竟然在投资领域开花结果 —— 可赚了钱就一切平安如意了吗？并不是，要面对之前从来没可能遇到的一些险恶与困境，怎么办？自学。除了困境之外，更痛苦的发现在于对投资这件事来说，并没有受过任何有意义的训练，怎么办？自学。觉得自己理解的差不多了，一出手就失败，怎么办？接着学。</p>
<p>我出身一般，父母是穷教师。出生在边疆小镇，儿时受到的教育也一般，也是太淘气 —— 后来也没考上什么好大学。说实话，我自认天资也一般，我就是那种被基因决定了经常马虎大意的人。岁数都这么大了，情商也都不是一般的差 —— 还是跟年轻的时候一样，经常莫名其妙就把什么人给得罪透了……</p>
<p>但我过得一直不算差。</p>
<p>靠什么呢？人么，一个都靠不上。到最后，我觉得只有一样东西真正可靠 —— <strong>自学能力</strong>。于是，经年累月，我磨练出了一套属于我自己的本领：只要我觉得有必要，我什么都肯学，学什么都能学会到够用的程度…… 编程，我不是靠上课学会的；英语，不是哪个老师教我的；写作，也不是谁能教会我的；教书，没有上过师范课程；投资，更没人能教我 —— 我猜，也没人愿意教我…… 自己用的东西自己琢磨，挺好。</p>
<p>关键在于，自学这事并不难，也不复杂，挺简单的，因为它所需要的一切都很朴素。</p>
<p>于是，从某个层面上来看，我每天都过的很开心。为什么？因为我有未来。凭什么那么确信？因为我知道我自己有自学能力。</p>
<p><strong>—— 我希望你也有。</strong></p>
<p>准确地讲，希望你有个更好的未来。</p>
<p>而现在我猜，此刻，你心中也是默默如此作想的罢。</p>
<h1 id="为什么把编程当作自学的入口？"><a href="#为什么把编程当作自学的入口？" class="headerlink" title="为什么把编程当作自学的入口？"></a>为什么把编程当作自学的入口？</h1><p>很多人误以为 “编程” 是很难的事情。</p>
<p>…… 实则不然 —— 这恰恰是我们选择 “编程” 作为自学的第一个 “执行项目” 的原因。</p>
<p>一本关于自学能力的书，若是真的能够起到作用，那么它就必须让读者在读之前和读之后不一样 —— 比如，之前可能没有自学能力，或者自学能力很差，之后就有了一定的自学能力……</p>
<p>然而，这很难。不但对读者来说很难，对作者来说更难 —— 我当过那么多年被学生高度评价的老师，出版过若干本畅销且长销的书籍，所以更是清楚地知道例子的重要性。</p>
<p>道理当然很重要；可是，在传递道理的时候，例子相对来看好像更重要。</p>
<p>同样的道理，例子不准，人就可能会理解错；例子不精彩，人就可能听不进去；例子居然可以令人震惊，那就可以做到让听众、让读者 “永生不忘”。</p>
<p>许多年前，有位后来在美国读书已经博士毕业了的学生来信，大意是说：</p>
<blockquote>
<p>好多年前，我在新东方上课，听您讲，人学习就好像是动物进化一样…… 很多人很早就开始停止了进化，本质上跟猴子没啥区别。</p>
<p>那段类比好长，我记不太清楚细节了…… 可是，当时我是出了一身汗的，因为我忽然觉得自己是一只猴子。可是，突然之间，我不想继续做猴子，更不想一直做猴子！</p>
<p>从那之后，我好像变了一个人似的…… 现在我已经博士毕业了，觉得应该写封信告诉您，我不再是猴子了，最起码是大猩猩，而且我保证，我会一直进化。</p>
<p>……</p>
</blockquote>
<p>所以啊，在我看来，写书讲课之前，最重要的工作，也是做得最多的事情，其实就是 “找到好例子” —— 那即意味着说，先要找到很多很多恰当合适的例子，而后再通过反复比较试验，挑出那个效果最好的例子。了解了这一点，将来你准备任何演讲，都会不由自主地多花一点时间在这方面，效果肯定比 “把幻灯片做得更花哨一些” 要好太多了罢？</p>
<p>后来，我选中了一个例子：“<strong>自学编程</strong>” —— “<em>尽量只通过阅读学会编程</em>”。</p>
<h2 id="（一）"><a href="#（一）" class="headerlink" title="（一）"></a>（一）</h2><p>选择它的理由，首先就在于：</p>
<blockquote>
<p>事实证明，<strong>它就是无论是谁都能学会的</strong> —— 千万别不信。</p>
</blockquote>
<p>它老少皆宜 —— 也就是说，“只要你愿意”，根本没有年龄差异。十二岁的孩子可以学；十八岁的大学生可以学；在职工作人员可以学…… 就算你已经退休了，想学就能学，谁也拦不住你。</p>
<p>它也不分性别，男性可以学，女性同样可以学，性别差异在这里完全不存在。</p>
<p>它也不分国界，更没有区域差异 —— 互联网的恩惠在于，你在北京、纽约也好，老头沟、门头沟也罢，在这个领域里同样完全没有任何具体差异。</p>
<p>尤其是在中国。现状是，中国的人口密度极高，优质教育资源的确就是稀缺…… 但在计算机科学领域，所有的所谓 “优质教育资源” 事实上完全没有任何独特的竞争力 —— 编程领域，实际上是当今世上极为罕见的 “<strong>教育机会公平之地</strong>”。又不仅在中国如此，事实上，在全球范围内也都是如此。</p>
<h2 id="（二）"><a href="#（二）" class="headerlink" title="（二）"></a>（二）</h2><p>编程作为 “讲解如何习得自学能力的例子”，实在是太好了。</p>
<p>首先，编程这个东西反正要自学 —— 不信你问问计算机专业的人，他们会如实告诉你的，学校里确实也教，但说实话都教得不太好……</p>
<p>其次，编程这个东西最适合 “仅靠阅读自学” —— 这个领域发展很快，到最后，新东西出来的时候，没有老师存在，任由你是谁，都只能去阅读 “官方文档”，只此一条路。</p>
<p>然后，也是最重要的一条，别管是不是很多人觉得编程是很难的东西，事实上它就是每个人都应该具备的技能。</p>
<p>许多年前，不识字，被称为文盲……</p>
<p>后来，人们反应过来了，不识英文，也是文盲，因为科学文献的主导语言是英文，读不懂英文，什么都吃不上热乎的；等菜好不容易端上来了吧，早就凉了不说，味道都常常会变……</p>
<p>再后来，不懂基本计算机操作技能的，也算是文盲，因为他们无论做什么事情，效率都太低下了，明明可以用快捷键一下子完成的事情，却非要手动大量重复……</p>
<p>到了最近，不懂数据分析的，也开始算作文盲了。许多年前人们惊呼信息时代来了的时候，其实暂时体会不到什么太多的不同。然而，许多年过去，互联网上的格式化数据越来越多，不仅如此，实时产出的格式化数据也越来越多，于是，数据分析不仅成了必备的能力，而且早就开始直接影响一个人的薪资水平。</p>
<p>你作为一个个体，每天都在产生各种各样的数据，然后时时刻刻都在被别人使用着、分析着…… 然而你自己却全然没有数据分析能力，甚至不知道这事很重要，是不是感觉很可怕？你看看周边那么多人，有多大的比例想过这事？反正那些天天看机器算法生成的信息流的人好像就是全然不在意自己正在被支配……</p>
<p>怎么办？学呗，学点编程罢 —— 巧了，<em>这还真是个正常人都能学会的技能</em>。</p>
<h2 id="（三）"><a href="#（三）" class="headerlink" title="（三）"></a>（三）</h2><p>编程作为 “讲解如何习得自学能力的例子” 最好的地方在于，这个领域的知识结构，最接近每个人所面对的人生中的知识结构。</p>
<p>这是什么意思呢？</p>
<p>编程入门的门槛之所以高，有个比较特殊的原因：</p>
<blockquote>
<p><strong>它的知识点结构不是线性的</strong>。</p>
</blockquote>
<p>我们在中小学里所遇到的教科书，其中每个章节所涉及到的知识点之间，全都是线性关联。第一章学好了，就有基础学第二章；在第二章的概念不会出现在第一章之中……</p>
<p>很遗憾，编程所涉及到的知识点没办法这样组织 —— 就是不行。编程教材之所以难以读懂，就是因为它的各章中的知识点结构不是线性排列的。你经常在某一章读到不知道后面第几章才可能讲解清楚的概念。</p>
<p>比如，几乎所有的 Python 编程书籍上来就举个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'Hello, world!'</span>)</span><br></pre></td></tr></table></figure>
<p>姑且不管这个例子是否意义非凡或者意义莫名，关键在于，<code>print()</code> 是个函数，而函数这个概念，不可能一上来就讲清楚，只能在后面若干章之后才开始讲解……</p>
<blockquote>
<p>想要理解当前的知识点，需要依赖对以后才能开始学习的某个甚至多个知识点的深入了解……</p>
</blockquote>
<p>这种现象，可以借用一个专门的英文概念，叫做 “<strong>Forward References</strong>” —— 原本是计算机领域里的一个<a href="https://en.wikipedia.org/wiki/Forward_declaration" target="_blank" rel="noopener">术语</a>。为了配合当前的语境，姑且把它翻译为 “<strong>过早引用</strong>” 罢，或者 “<strong>前置引用</strong>” 也行。</p>
<p>学校里的课本，都很严谨 —— 任何概念，未经声明就禁止使用。所以，学完一章，就能学下一章；跳到某一章遇到不熟悉的概念，往前翻肯定能找到……</p>
<p>在学校里习惯了这种知识体系的人，离开学校之后马上抓瞎 —— <strong>社会的知识结构不仅不是这样的，而且<em>几乎全都不是</em>这样的</strong>。工作中、生活里，充满了各式各样的 “<em>过早引用</em>”。为什么总是要到多年以后你才明白父母曾经说过的话那么有道理？为什么总要到孩子已经长大之后才反应过来当初自己对孩子做错过很多事情？为什么在自己成为领导之前总是以为他们只不过是在忽悠你？为什么那么多人创业失败了之后才反应过来当初投资人提醒的一些观念其实是千真万确的？—— 因为很多概念很多观念是 “过早引用”，在当时就是非常难以理解……</p>
<p>自学编程在这方面的好处在于，在自学的过程中，其实你相当于过了一遍 “模拟人生” —— 于是，面对同样的 “<em>过早引用</em>”，你不会觉得那么莫名其妙，你有一套你早已在 “模拟人生” 中练就的方法论去应对。</p>
<h2 id="（四）"><a href="#（四）" class="headerlink" title="（四）"></a>（四）</h2><p>另外一个把编程作为 “讲解如何习得自学能力的例子” 最好的地方在于，你在这个过程中将不得不习得英语 —— 起码是英文阅读能力，它能让你在不知不觉中 “脱盲”。</p>
<p>学编程中最重要的活动就是 “阅读官方文档”。学 Python 更是如此。Python 有很多非常优秀的地方，其中一个令人无法忽视的优点就是它的文档完善程度极好。它甚至有专门的文档生成工具，<a href="http://www.sphinx-doc.org/en/master/" target="_blank" rel="noopener">Sphinx</a>：</p>
<blockquote>
<p>Sphinx is a tool that makes it easy to create intelligent and beautiful documentation, written by Georg Brandl and licensed under the BSD license.</p>
<p>It was originally created for <a href="https://docs.python.org/" target="_blank" rel="noopener">the Python documentation</a>, and it has excellent facilities for the documentation of software projects in a range of languages. Of course, this site is also created from reStructuredText sources using Sphinx!</p>
</blockquote>
<p>最好的 Python 教程，是官方网站上的 <a href="https://docs.python.org/3/tutorial/index.html" target="_blank" rel="noopener">The Python Tutorial</a>，读它就够了。我个人完全没兴趣从头到尾写一本 Python 编程教材，不仅因为人家写得真好，而且它就放在那里。</p>
<p>虽然你在官方网站上就是很难找到它的中文版，虽然就不告诉你到底在哪里也显得很不厚道，但是，我建议你就只看英文版 —— 因为离开了这个教程之后，还是要面对绝大多数都是英文的现实。</p>
<p>为了照顾那些也想读完本书，但因为种种原因想着读中文可以快一些的人，链接还是放在这里：</p>
<blockquote>
<ul>
<li><a href="https://docs.python.org/zh-cn/3/tutorial/index.html" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/tutorial/index.html</a> (for v.3.7.2）</li>
<li><a href="http://www.pythondoc.com/pythontutorial3/" target="_blank" rel="noopener">http://www.pythondoc.com/pythontutorial3/</a> (for v.3.6.3)</li>
</ul>
</blockquote>
<p>我曾经专门写过一本书发布在网上，叫《<a href="https://github.com/xiaolai/everyone-can-use-english" target="_blank" rel="noopener">人人都能用英语</a>》。其中的观点就是，大多数人之所以在英语这事上很矬，是因为他们花无数的时间去 <em>“学”</em>，但就是 <em>“不用”</em>。学以致用，用以促学。可就是不用，无论如何就是不用，那英语学了那么多年能学好吗？</p>
<p>自学编程的一个 “副作用” 就是，<strong>你不得不用英语</strong>。而且还是天天用，不停地用。</p>
<p>当年我上大学的时候，最初英语当然也不好。不过，因为想读当时还是禁书的《动物庄园》（<a href="https://www.marxists.org/subject/art/literature/children/texts/orwell/animal-farm/index.htm" target="_blank" rel="noopener">Animal Farm</a>），就只好看原版（当时好不容易搞到的是本英法对照版）…… 然后英语阅读就基本过关了。</p>
<p>这原理大抵上是这样，刚开始，英语就好像一层毛玻璃，隔在你和你很想要了解的内容之间。然而，由于你对那内容的兴趣和需求是如此强烈，乃至于即便隔着毛玻璃你也会挣扎着去看清楚…… 挣扎久了（其实没两天就不一样），你的 “视力” 就进化了，毛玻璃还在那里，但你好像可以穿透它看清一切……</p>
<p>自学编程，也算是一举两得了！</p>
<h2 id="（五）"><a href="#（五）" class="headerlink" title="（五）"></a>（五）</h2><p>当然，把编程作为 “讲解如何习得自学能力的例子”，实在是太好了的最重要原因在于，自学编程对任何人来说都绝对是：</p>
<blockquote>
<ul>
<li>现实的（Practical）</li>
<li>可行动的（Actionable）</li>
<li>并且还是真正是可达成的（Achievable）</li>
</ul>
</blockquote>
<p>最重要的就是最后这个 “可达成的”。虽然对读者和作者来说，一个做到没那么容易，另一个讲清楚也非常难，但是，既然是所有人都 “可达成的”，总得试试吧？但是，请相信我，这事比减肥容易多了 —— 毕竟，你不是在跟基因作斗争。</p>
<p>这只是个起点。</p>
<p>尽量只靠阅读学会编程，哪怕仅仅是入门，这个经历和经验都是极为宝贵的。</p>
<p>自学是门手艺。只不过它并不像卖油翁的手艺那样很容易被别人看到，也不是很容易拿它出来炫耀 —— 因为别人看不到么！然而，经年累月，就不一样了，那好处管他别人知不知道，自己却清楚得很！</p>
<p>你身边总有些人能把别人做不好的事做得极好，你一定很羡慕。可他们为什么能做到那样呢？很简单啊，他们的自学能力强，所以他们能学会大多数自学能力差的人终生学不到的东西。而且他们的自学能力会越来越强，每学会一样新东西，他们就积累了更多自学经验，难以对外言表的经验，再遇到什么新东西，相对没那么吃力。</p>
<p>另外，自学者最大的感受就是万物相通。他们经常说的话有这么一句：“…… <strong>到最后，都是一样的呢</strong>。”</p>
<h2 id="（六）"><a href="#（六）" class="headerlink" title="（六）"></a>（六）</h2><p>最后一个好处，一句话就能说清楚，并且，随着时间的推移，你对此的感触会越来越深：</p>
<blockquote>
<p>在这个领域里，自学的人最多……</p>
</blockquote>
<p>没有什么比这句话更令人舒心的了：<strong>相信我，你并不孤独</strong>。</p>
<h1 id="只靠阅读习得新技能"><a href="#只靠阅读习得新技能" class="headerlink" title="只靠阅读习得新技能"></a>只靠阅读习得新技能</h1><p>习得自学能力的终极目标就是：</p>
<blockquote>
<p>有能力<strong>只靠阅读</strong>就能习得新技能。</p>
</blockquote>
<p>退而求其次，是 “尽量只靠阅读就习得新技能” —— 当然，刚开始的时候可能需要有人陪伴，一起学，一起讨论，一起克服困难…… 但就是要摆脱 “没人教，没人带，没人逼，就彻底没戏” 的状态。</p>
<p>小时候总是听大人说：</p>
<blockquote>
<p>不是什么东西都可以从书本里学到的……</p>
</blockquote>
<p>一度，我觉得他们说的有道理。再后来，隐约感觉这话哪儿有毛病，但竟然又感觉无力反驳……</p>
<p>那时，真被他们忽悠到了；后来，也差点被他们彻底忽悠到！</p>
<p>幸亏后来我渐渐明白，且越来越相信：</p>
<blockquote>
<p>自己生活工作学习上遇到的所有疑问，书本里应该都有答案 —— 起码有所参考。</p>
</blockquote>
<p>“不是什么东西都可以从书本里学到的……” 这话听起来那么有道理，只不过是因为自己读书<strong>不够多</strong>、<strong>不够对</strong>而已。</p>
<p>过了 25 岁，我放弃了读小说，虚构类作品，我只选择看电影；而非虚构类作品，我选择尽量只读英文书，虽然那时候买起来很贵也很费劲，但我觉得值 —— 英文世界和中文世界的文化风格略有不同。在英文世界里，你看到的正常作者好像更多地把 “通俗易懂”、“逻辑严谨” 当作最基本的素养；而在中文世界里，好像 “故弄玄虚”、“偷梁换柱” 更常见一些；在英文世界里，遇到读不懂的东西可以很平静地接受自己暂时的愚笨，心平气和地继续努力就好；在中文世界里，遇到装神弄鬼欺世盗名的，弄不好最初根本没认出来，到最后跟 “认贼作父” 一样令人羞辱难当不堪回首。</p>
<p>说实话，我真觉得这事跟崇洋媚外没什么关系。我是朝鲜族，去过韩国，真觉得韩国的书更没法看（虽然明显是个人看法）…… 2015 年年底，我的律师告诉我，美国移民就快帮我办下来了，可那时候我开始觉得美国政府也各种乱七八糟，于是决定停止办理。我是个很宅的人，除了餐馆基本上哪儿都不去，陪家人朋友出去所谓旅游的时候，我只不过是换个房间继续宅着…… 可这些都不是重点，重点在于：</p>
<blockquote>
<p><strong>知识原本就应该无国界</strong>…… 不是吗？不是吗！</p>
</blockquote>
<p>再说，这些年我其实还读了不少中国人写的英文书呢，比如，张纯如的书很值得一看；郑念的 Life and Death in Shanghai，真的很好很好。我也读了不少老外写的关于中国的书 —— 这些年我一直推荐费正清的剑桥中国史（The Cambridge History of China），当然有中文版的，不过，能读英文版的话感受很不一样。</p>
<p>当然，英文书里同样烂书也很多，烂作者也同样一大堆，胡说八道欺世盗名的一大串…… 但总体上来看，非小说类著作质量的确更高一点。</p>
<p>还有，英语在科学研究领域早已成为 “主导语言”（Dominant Language）也是不争的事实。不过，英语成为主导语言的结果，就是英语本身被不断 “强奸”，外来语越来越多，“Long time no see” 被辞典收录就是很好的例子。事实上，英语本身就是个大杂烩……</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/Joseph-M-Williams-research-visualized.png?raw=true" alt="Joseph M. Williams’ research visualized (top 10,000 words)."><a href="https://medium.com/@andreas_simons/the-english-language-is-a-lot-more-french-than-we-thought-heres-why-4db2db3542b3" target="_blank" rel="noopener"></a></p>
<p>读书越多越明白读书少会被忽悠…… 很多人真的会大头捣蒜一般地认同 “不是什么东西都可以从书本里学到的……”</p>
<p>另外，很多人在如此教导小朋友的时候，往往是因为 “人心叵测” 啊，“江湖险恶” 啊，所以害怕小朋友吃亏。可事实上，如若说，人间那些勾心斗角的事貌似从书本里学不来的话，其实也不过还是历史书看少了 —— 勾心斗角的套路历史上全都被反复用过了。倒是有本中文书值得吐血推荐，民国时代的作者连阔如先生写的《江湖丛谈》，粗略扫过你就知道了，江湖那点事，也早就有人给你里里外外翻了个遍…… 只不过这书不太容易买到就是了。</p>
<p>我也遇到过这样的反驳：</p>
<blockquote>
<p>书本能教会你做生意吗？！</p>
</blockquote>
<p>说实话，去回驳这个反驳还真挺难，因为反驳者是脑容量特别有限才能说出这种话 —— 世界上有那么多商学院都是干嘛的？搞得它们好像不存在一样。首先，它们的存在说明，商业这事是有迹可循的，是可学习的；其次，商业类书籍非常多，是非虚构类书籍中的一大品类；更为重要的是，做生意这事，看谁做 —— 有本事（即，比别人拥有更多技能）的人做生意和没本事的人做生意，用同样的商业技巧，能有一样的效果吗？最后啊，这世界在这方面从来没有变过：一技傍身的人，总是不愁生活……</p>
<p>更为重要的是，这才几年啊，互联网本身已经成了一本大书 —— 关于全世界的一整本大书。仅仅是 10 多年前，大约在 2008 年前后，经过几年发展的 Wikipedia 被众多西方大学教授们群起而攻，指责它错误百出…… 可现在呢？Wikipedia 好像有天生的自我修复基因，它变得越来越值得信赖，越来越好用。</p>
<p>七零后八零后长大的过程中，还经常被父母无故呵斥：“怎么就你事这么多！” 或者无奈敷衍：“等你长大了就明白了……” 九零后、零零后呢？他们很少有什么疑问需要向父母提问，直接问搜索引擎，效果就是父母们天天被惊到甚至吓到。最近两年更不一样了，我有朋友在旧金山生活，他的孩子整天跟 Google 说话，有点什么问题，就直接 “Hey Google…”</p>
<p>我长大的那个年代，一句 “通过阅读了解世界” 好像还是很抽象甚至很不现实的话，现在呢？现在，除了阅读之外，你还能想出什么更有效的方法吗？反正我想不出。</p>
<p>有个很有趣的现象：</p>
<blockquote>
<p>人么，只要识字，就忍不住阅读……</p>
</blockquote>
<p>只不过，人们阅读的选择很不同而已。有自学能力的人和没有自学能力的人，在这一点上很容易分辨：</p>
<blockquote>
<ul>
<li>有自学能力的人，选择阅读 “有繁殖能力” 的内容；</li>
<li>没有自学能力的人，阅读只是为了消磨时光……</li>
</ul>
</blockquote>
<p>我把那些能给你带来新视野，能让你改变思考模式，甚至能让你拥有一项新技能的内容称之为 “有繁殖能力的内容”。</p>
<p>人都一样，拥有什么样的能力之后，就会忍不住去用，甚至总是连下意识中也要用。</p>
<p>那些靠阅读机器算法推送的内容而杀时间的人，恰恰就是因为他们有阅读能力才去不断地读，读啊读，像是那只被打了兴奋剂后来死在滚轮上的小白鼠。如果这些人哪怕有一点点自学能力，那么他们很快就会分辨出自己正在阅读的东西不会刺激自己的产出，只会消磨自己的时间；那么，他们就会主动放弃阅读那些杀时间的内容，把那时间和精力自然而然地用在筛选有繁殖能力的内容，让自己进步，让自己习得更多技能上去了。</p>
<p>所以，只要你有一次 “<strong>只靠阅读习得一项新技能</strong>” 的经验，你就变成另外一个人了。你会不由自主、哪怕下意识里都会去运用你新习得的能力…… 从这个角度看，自学很上瘾！能上瘾，却不仅无害，还好处无穷，这样的好事，恐怕也就这一个了罢。</p>
<p>我有过只靠阅读学会游泳的经历…… 听起来不像真的吧？更邪门的是，罗永浩同学的蛙泳，是我站在游泳池边，仅靠言语讲解，就让他从入水就扑腾开始三十分钟之内可以开始蛙泳的 —— 虽然当天他第一次蛙泳，一个来回五十米都坚持不下来。</p>
<p>仅靠阅读学会新技能不仅是可能的，并且，你随后会发现的真相是：</p>
<blockquote>
<p>绝大多数情况下，没人能教你，也不一定有人愿意教你…… 到最后，你想学会或你必须学会什么东西的时候，<strong>你只能靠阅读！</strong> —— 因为其实你谁都靠不上……</p>
</blockquote>
<p>我有很多偶像，英国数学家乔治・布尔就是其中一个 —— 因为他就是个基本上只靠阅读自学成才的人。十八、九岁，就自学了微积分 —— 那是将近两百年前，没有 Google，没有 Wikipedia…… 然后他还自己创办了学校，给自己打工…… 从来没有上过大学，后来却被皇家学院聘请为该学院第一个数学教授。然后，人家发明的布尔代数，在百年之后引发了信息革命…… 达芬奇也是这样的人 —— 要说惨，他比所有人都惨…… 因为几乎从一开始就貌似没有谁有资格有能力教他。</p>
<p>这些例子都太遥远了。给你讲个我身边的人，我亲自打过很长时间交道的人 —— 此人姓邱，人称邱老板。</p>
<p>邱老板所写的区块链交易所引擎，在 Github 上用的是个很霸气的名字，“<a href="https://github.com/peatio/peatio" target="_blank" rel="noopener">貔貅</a>”（英文用了一个生造的词，Peatio）—— 这个 Repo 至 2019 年春节的时候，总计有 2,913 个 Star，有 2,150 个 Fork…… 绝对是全球这个领域中最受关注的开源项目。2017 年 9 月，云币应有关部门要求关闭之前，是全球排名前三的区块链交易所。</p>
<p>邱老板当年上学上到几年级呢？初中未读完，所以，跟他聊天随口说成语是很有负担的，因为他真的可能听不懂…… 然而，他的编程、他的英语，全是自学的…… 学到什么地步呢？学到可以创造极有价值的商业项目的地步。他什么学习班都没上过，全靠阅读 —— 基本上只读互联网这本大书。</p>
<p>讲真，你没有选择，只靠阅读习得新技能，这是你唯一的出路。</p>
<h1 id="开始阅读前的一些准备"><a href="#开始阅读前的一些准备" class="headerlink" title="开始阅读前的一些准备"></a>开始阅读前的一些准备</h1><h2 id="内容概要"><a href="#内容概要" class="headerlink" title="内容概要"></a>内容概要</h2><p>关于 Python 编程的第一部分总计 7 章，主要内容概括为：</p>
<blockquote>
<ol>
<li>以布尔值为入口开始理解程序本质</li>
<li>了解值的分类和运算方法</li>
<li>简要了解流程控制的原理</li>
<li>简要了解函数的基本构成</li>
<li>相对完整地了解字符串的操作</li>
<li>了解各种容器的基础操作</li>
<li>简要了解文件的读写操作</li>
</ol>
</blockquote>
<h2 id="阅读策略"><a href="#阅读策略" class="headerlink" title="阅读策略"></a>阅读策略</h2><p>首先，不要试图一下子就全部搞懂。这不仅很难，<strong>在最初的时候也完全没必要</strong>。</p>
<p>因为这部分的知识结构中，充满了 “过早引用”。请在第一遍粗略完成第 1 部分中的 E1 ~ E7 之后，再去阅读《<a href="Part.1.F.deal-with-forward-references.md">如何从容应对 “过早引用”？</a>》。</p>
<p>其次，这一部分，注定要<strong>反复阅读若干遍</strong>。</p>
<p>在开始之前，要明确这一部分的阅读目标。</p>
<p>这一部分的目标，不是让你读完之后就可以开始写程序；也不是让你读完之后就对编程或者 Python 编程有了完整的了解，甚至不是让你真的学会什么…… 这一部分的目标，只是让你 “<strong>脱盲</strong>”。</p>
<p>不要以为脱盲是很容易的事情。你看，所有人出生的时候，都天然是 “文盲”；人们要上好多年的学，才能够真正 “脱盲” —— 仔细想想吧，小学毕业的时候，所有人就真的彻底脱盲了吗？</p>
<p>以中文脱盲为例，学字的同时，还要学习笔划；为了学更多的字，要学拼音，要学如何使用《新华字典》……</p>
<p>学会了一些基础字之后，要学更多的词，而后在练习了那么多造词造句之后，依然会经常用错…… 你看，脱盲，和阅读能力强之间距离很长呢；不仅如此，阅读能力强和写作能力强之间的距离更长……</p>
<p>反复阅读这一部分的结果是：</p>
<blockquote>
<ul>
<li>你对基本概念有了一定的了解</li>
<li>你开始有能力相对轻松地阅读部分官方文档</li>
<li>你可以读懂一些简单的代码</li>
</ul>
</blockquote>
<p>仅此而已。</p>
<h2 id="心理建设"><a href="#心理建设" class="headerlink" title="心理建设"></a>心理建设</h2><p>当我们开始学习一项新技能的时候，我们的大脑会不由自主地紧张。可这只不过是多年之间在学校里不断受挫的积累效应 —— 学校里别的地方不一定行，可有个地方特别行：给学生制造全方位、无死角、层层递进的挫败感。</p>
<p>可是，你要永远记住两个字：</p>
<blockquote>
<p>别怕！</p>
</blockquote>
<p>用四个字也行：</p>
<blockquote>
<p>啥也别怕！</p>
</blockquote>
<p>六个字也可以：</p>
<blockquote>
<p>没什么可怕的！</p>
</blockquote>
<p>我遇到最多的孱弱之语大抵是这样的：</p>
<blockquote>
<p>我一个文科生……</p>
</blockquote>
<p>哈哈，从某个层面望过去，其实吧，编程既不是文科也不是理科…… 它更像是 “手工课”。你越学就越清楚这个事实，它就好像是你做木工一样，学会使用一个工具，再学会使用另外一个工具，其实总共就没多少工具。然后，你更多做的是各种拼接的工作，至于能做出什么东西，最后完全靠你的想象力……</p>
<p>十来岁的孩子都可以学会的东西，你怕什么？</p>
<p><strong>别怕</strong>，无论说给自己，还是讲给别人，都是一样的，它可能是人生中最重要的鼓励词。</p>
<h2 id="关于这一部分内容中的代码"><a href="#关于这一部分内容中的代码" class="headerlink" title="关于这一部分内容中的代码"></a>关于这一部分内容中的代码</h2><p>所有的代码，都可以在选中代码单元格（Code Cell）之后，按快捷键 <code>⇧ ⏎</code> 或 <code>^ ⏎</code> 执行，查看结果。</p>
<p>少量执行结果太长的代码，其输出被设置成了 “Scrolled”，是可以通过触摸板或鼠标滑轮上下滑动的。</p>
<p>为了避免大量使用 <code>print()</code> 才能看到输出结果，在很多的代码单元格中，开头插入了以下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br></pre></td></tr></table></figure>
<p>你可以暂时忽略它们的意义和工作原理。注意：有时，你需要在执行第二次的时候，才能看到全部输出结果。</p>
<p>另外，有少量代码示例，为了让读者每次执行的时候看到不同的结果，使用了随机函数，为其中的变量赋值，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">r = random.randrange(<span class="number">1</span>, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<p>同样，你可以暂时忽略它们的意义和工作原理；只需要知道因为有它们在，所以每次执行那个单元格中的代码会有不同的结果就可以了。</p>
<p>如果你不是直接在网站上浏览这本 “书”、或者不是在阅读印刷版，而是在本地自己搭建 Jupyterlab 环境使用，那么请参阅附录《<a href="T-appendix.jupyter-installation-and-setup.md">Jupyterlab 的安装与配置</a>》。</p>
<blockquote>
<p><strong>注意</strong>：尤其需要仔细看看《<a href="T-appendix.jupyter-installation-and-setup.md">Jupyterlab 的安装与配置</a>》的《关于 Jupyter lab themes》这一小节 —— 否则，阅读体验会有很大差别。</p>
</blockquote>
<p>另外，如果你使用的是 <a href="https://nteract.io" target="_blank" rel="noopener">nteract</a> 桌面版 App 浏览 <code>.ipynb</code> 文件，那么有些使用了 <code>input()</code> 函数的代码是无法在 nteract 中执行的。</p>
<h1 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h1><p>“速成”，对绝大多数人<a href="#fn1" name="fn1b"><sup>[1]</sup></a>来说，在绝大多数情况下，是不大可能的。</p>
<p>编程如此，自学编程更是如此。有时，遇到复杂度高一点的知识，连快速入门都不一定是很容易的事情。</p>
<p>所以，这一章的名称，特意从 “<em>入门</em>” 改成了 “<strong>入口</strong>” —— 它的作用是给你 “指一个入口”，至于你能否从那个入口进去，是你自己的事了……</p>
<p>不过，有一点不一样的地方，我给你指出的入口，跟别的编程入门书籍不一样 —— 它们几乎无一例外都是从一个 “Hello World!” 程序开始的…… 而我们呢？</p>
<p>让我们从认识一个人开始罢……</p>
<h2 id="乔治・布尔"><a href="#乔治・布尔" class="headerlink" title="乔治・布尔"></a>乔治・布尔</h2><p>1833 年，一个 18 岁的英国小伙脑子里闪过一个念头：</p>
<blockquote>
<p><strong>逻辑关系</strong>应该能用<strong>符号</strong>表示。</p>
</blockquote>
<p>这个小伙子叫乔治・布尔（<a href="https://en.wikipedia.org/wiki/George_Boole" target="_blank" rel="noopener">George Boole</a>，其实之前就提到过我的这位偶像），于 1815 年出生于距离伦敦北部 120 英里之外的一个小镇，林肯。父亲是位对科学和数学有着浓厚兴趣的鞋匠。乔治・布尔在父亲的影响下，靠阅读自学成才。14 岁的时候就在林肯小镇名声大噪，因为他翻译了一首希腊语的诗歌并发表在本地的报纸上。</p>
<p>到了 16 岁的时候，他被本地一所学校聘为教师，那时候他已经在阅读微积分书籍。19 岁的时候布尔创业了 —— 他办了一所小学，自任校长兼教师。23 岁，他开始发表数学方面的论文。他发明了 “操作演算”，即，通过操作符号来研究微积分。他曾经考虑过去剑桥读大学，但后来放弃了，因为为了入学他必须放下自己的研究，还得去参加标准本科生课程。这对一个长期只靠自学成长的人来说，实在是太无法忍受了。</p>
<p>1847 年，乔治 32 岁，出版了他人生的第一本书籍，<a href="http://www.gutenberg.org/ebooks/36884" target="_blank" rel="noopener">THE MATHEMATICAL ANALYSIS OF LOGIC</a> —— 18 岁那年的闪念终于成型。这本书很短，只有 86 页，但最终它竟然成了人类的瑰宝。在书里，乔治・布尔很好地解释了如何使用代数形式表达逻辑思想。</p>
<p>1849 年，乔治・布尔 34 岁，被当年刚刚成立的女皇学院（Queen’s College）聘请为第一位数学教授。随后他开始写那本最著名的书，<a href="http://www.gutenberg.org/ebooks/15114" target="_blank" rel="noopener">AN INVESTIGATION OF THE LAWS OF THOUGHT</a>。他在前言里写到：</p>
<blockquote>
<p>“The design of the following treatise is to investigate the fundamental laws of those operations of the mind by which reasoning is performed; to give expression to them in the symbolical language of a Calculus, and upon this foundation to establish the science of Logic and construct its method; …”</p>
<p>“本书论述的是，探索心智推理的基本规律；用微积分的符号语言进行表达，并在此基础上建立逻辑和构建方法的科学……”</p>
</blockquote>
<p>在大学任职期间，乔治・布尔写了两本教科书，一本讲微分方程，另外一本讲差分方程，而前者，<a href="https://archive.org/details/atreatiseondiff06boolgoog/page/n7" target="_blank" rel="noopener">A TREATISE ON DIFFERENTIAL EQUATIONS</a>，直到今天，依然难以超越。</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/george-boole-in-1864.png?raw=true" alt="george-boole-1864"></p>
<p>乔治・布尔于 1864 年因肺炎去世。</p>
<p>乔治・布尔在世的时候，人们并未对他的布尔代数产生什么兴趣。直到 70 年后，克劳德・香农（<a href="https://en.wikipedia.org/wiki/Claude_Shannon" target="_blank" rel="noopener">Claude Elwood Shannon</a>）发表那篇著名论文，<a href="https://www.cs.virginia.edu/~evans/greatworks/shannon38.pdf" target="_blank" rel="noopener">A SYMBOLIC ANALYSIS OF RELAY AND SWITCHING CIRCUITS</a> 之后，布尔代数才算是开始被大规模应用到实处。</p>
<p>有本书可以闲暇时间翻翻，<a href="https://www.amazon.com/gp/product/B0091XBUTM/ref=dbs_a_def_rwt_hsch_vapi_tkin_p1_i4" target="_blank" rel="noopener">The Logician and the Engineer: How George Boole and Claude Shannon Created the Information Age</a>。可以说，没有乔治・布尔的<strong>布尔代数</strong>，没有克劳德・香农的<strong>逻辑电路</strong>，就没有后来的计算机，就没有后来的互联网，就没有今天的信息时代 —— 世界将会怎样？</p>
<p>2015 年，乔治・布尔诞辰 200 周年，Google 设计了<a href="https://www.google.com/doodles/george-booles-200th-birthday" target="_blank" rel="noopener">专门的 Logo</a> 纪念这位为人类作出巨大贡献的自学奇才。</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/george-boole-google-doodle-2015.gif?raw=true" alt="george-boole-google-doodle-2015"></p>
<p>Google Doodle 的寄语是这样的：</p>
<blockquote>
<p>A very happy <strong>11001000</strong>_th_ birthday to genius George Boole!</p>
</blockquote>
<h2 id="布尔运算"><a href="#布尔运算" class="headerlink" title="布尔运算"></a>布尔运算</h2><p>从定义上来看，所谓<strong>程序</strong>（Programs）其实一点都不神秘。</p>
<p>因为程序这个东西，不过是按照一定<em>顺序</em>完成任务的<strong>流程</strong>（Procedures）。根据定义，日常生活中你做盘蛋炒饭给自己吃，也是完成了一个 “做蛋炒饭” 的程序 —— 你按部就班完成了一系列的步骤，最终做好了一碗蛋炒饭给自己吃 —— 从这个角度望过去，所有的菜谱都是程序……</p>
<p>只不过，菜谱这种程序，编写者是人，执行者还是人；而我们即将要学会写的程序，编写者是人，执行者是计算机 —— 当然，菜谱用自然语言编写，计算机程序由程序员用编程语言编写。</p>
<p>然而，这些都不是最重要的差异 —— 最重要的差异在于计算机能做<strong>布尔运算</strong>（Boolean Operations）。</p>
<p>于是，一旦代码编写好之后，计算机在执行的过程中，除了可以 “<em>按照顺序执行任务</em>” 之外，还可以 “<em>根据不同情况执行不同的任务</em>”，比如，“<em>如果条件尚未满足则重复执行某一任务</em>”。</p>
<p>计算器和计算机都是电子设备，但计算机更为强大的原因，用通俗的说法就是它 “<strong>可编程</strong>”（Programable）—— 而所谓可编程的核心就是<em>布尔运算</em>及其相应的<strong>流程控制</strong>（Control Flow）；没有布尔运算能力就没有办法做<em>流程控制</em>；没有流程控制就只能 “按顺序执行”，那就显得 “很不智能”……</p>
<h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p>在 Python 语言中，<strong>布尔值</strong>（Boolean Value）用 <code>True</code> 和 <code>False</code> 来表示。</p>
<p><strong>注意</strong>：请小心区分大小写 —— 因为 Python 解释器是对大小写敏感的，对它来说，<code>True</code> 和 <code>true</code> 不是一回事。</p>
<p>任何一个<strong>逻辑表达式</strong>都会返回一个<em>布尔值</em>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"><span class="comment"># 请暂时忽略以上两行……</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> == <span class="number">2</span></span><br><span class="line"><span class="number">1</span> != <span class="number">2</span></span><br></pre></td></tr></table></figure>
<pre><code>False
True
</code></pre><p><code>1 == 2</code>，用自然语言描述就是 “<em>1 等于 2 吗？</em>” —— 它的布尔值当然是 <code>False</code>。</p>
<p><code>1 != 2</code>，用自然语言描述就是 “<em>1 不等于 2 吗？</em>” —— 它的布尔值当然是 <code>True</code>。</p>
<p><strong>注意</strong>：自然语言中的 “<em>等于</em>”，在 Python 编程语言中，使用的符号是 <code>==</code>，<strong>不是一个等号！</strong></p>
<p><strong>请再次注意</strong>：单个等号 <code>=</code>，有其他的用处。初学者最不适应的就是，在编程语言里所使用的操作符，与他们之前在其他地方已经习惯了的使用方法并不相同 —— 不过，适应一段时间就好了。</p>
<h3 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h3><p>Python 语言中的<strong>逻辑操作符</strong>（Logical Operators）如下表所示 —— 为了理解方便，也可以将其称为 “<em>比较操作符</em>”。</p>
<table>
<thead>
<tr>
<th>比较操作符</th>
<th>意义</th>
<th>示例</th>
<th>布尔值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>==</code></td>
<td>等于</td>
<td><code>1 == 2</code></td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>!=</code></td>
<td>不等于</td>
<td><code>1 != 2</code></td>
<td><code>True</code></td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>大于</td>
<td><code>1 &gt; 2</code></td>
<td><code>False</code></td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于等于</td>
<td><code>1 &gt;= 1</code></td>
<td><code>True</code></td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于</td>
<td><code>1 &lt; 2</code></td>
<td><code>True</code></td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于等于</td>
<td><code>1 &lt;= 2</code></td>
<td><code>True</code></td>
</tr>
<tr>
<td><code>in</code></td>
<td>属于</td>
<td><code>&#39;a&#39; in &#39;basic&#39;</code></td>
<td><code>True</code></td>
</tr>
</tbody>
</table>
<p>除了等于、大于、小于之外，Python 还有一个逻辑操作符，<code>in</code>：</p>
<p>这个表达式 <code>&#39;a&#39; in &#39;basic&#39;</code> 用自然语言描述就是：</p>
<blockquote>
<p>“<code>&#39;a&#39;</code> 存在于 <code>&#39;basic&#39;</code> 这个字符串之中吗？”（属于关系）</p>
</blockquote>
<h3 id="布尔运算操作符"><a href="#布尔运算操作符" class="headerlink" title="布尔运算操作符"></a>布尔运算操作符</h3><p>以上的例子中，逻辑操作符的<strong>运算对象</strong>（Operands）是数字值和字符串值。</p>
<p>而针对布尔值进行运算的操作符很简单，只有三种：与、或、非：</p>
<blockquote>
<p>分别用 <code>and</code>、<code>or</code>、<code>not</code> 表示</p>
</blockquote>
<p><strong>注意</strong>：它们全部是小写。因为布尔值只有两个，所以布尔运算结果只有几种而已，如下图所示：</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/boolean-operators.png?raw=true" alt></p>
<p>先别管以下代码中 <code>print()</code> 这个函数的工作原理，现在只需要关注其中布尔运算的结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'(True and False) yields:'</span>,  <span class="literal">True</span> <span class="keyword">and</span> <span class="literal">False</span>)</span><br><span class="line">print(<span class="string">'(True and True) yields:'</span>,  <span class="literal">True</span> <span class="keyword">and</span> <span class="literal">True</span>)</span><br><span class="line">print(<span class="string">'(False and True) yields:'</span>,  <span class="literal">False</span> <span class="keyword">and</span> <span class="literal">True</span>)</span><br><span class="line">print(<span class="string">'(True or False) yields:'</span>,  <span class="literal">True</span> <span class="keyword">or</span> <span class="literal">False</span>)</span><br><span class="line">print(<span class="string">'(False or True) yields:'</span>,  <span class="literal">False</span> <span class="keyword">or</span> <span class="literal">True</span>)</span><br><span class="line">print(<span class="string">'(False or False) yields:'</span>,  <span class="literal">False</span> <span class="keyword">or</span> <span class="literal">False</span>)</span><br><span class="line">print(<span class="string">'(not True) yields:'</span>,  <span class="keyword">not</span> <span class="literal">True</span>)</span><br><span class="line">print(<span class="string">'(not False) yields:'</span>,  <span class="keyword">not</span> <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<pre><code>(True and False) yields: False
(True and True) yields: True
(False and True) yields: False
(True or False) yields: True
(False or True) yields: True
(False or False) yields: False
(not True) yields: False
(not False) yields: True
</code></pre><p>千万不要误以为布尔运算是<em>理科生</em>才必须会、才能用得上的东西…… 文理艺分科是中国的特殊分类方式，真挺害人的。比如，设计师们在计算机上创作图像的时候，也要频繁使用<em>或与非</em>的布尔运算操作才能完成各种图案的拼接…… 抽空看看这个网页：<a href="https://sketchapp.com/docs/shapes/boolean-operations/" target="_blank" rel="noopener">Boolean Operations used by Sketch App</a> —— 这类设计软件，到最后是每个人都用得上的东西呢。另，难道艺术生不需要学习文科或者理科？—— 事实上，他们也有文化课……</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/operations@2x.png?raw=true" alt></p>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>有了布尔运算能力之后，才有<em>根据情况决定流程</em>的所谓<strong>流程控制</strong>（Control Flow）的能力。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">r = random.randrange(<span class="number">1</span>, <span class="number">1000</span>)</span><br><span class="line"><span class="comment"># 请暂时忽略以上两句的原理，只需要了解其结果：</span></span><br><span class="line"><span class="comment"># 引入随机数，而后，每次执行的时候，r 的值不同</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> r % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">    print(r, <span class="string">'is even.'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(r, <span class="string">'is odd.'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>693 is odd.
</code></pre><p>你可以多执行几次以上程序，看看每次不同的执行结果。执行方法是，选中上面的 Cell 之后按快捷键 <code>shift + enter</code>。</p>
<p>现在看代码，先忽略其它的部分，只看关键部分：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> r % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>这个 <code>if/else</code> 语句，完成了流程的<strong>分支</strong>功能。<code>%</code> 是计算余数的符号，如果 <code>r</code> 除以 <code>2</code> 的余数等于 <code>0</code>，那么它就是偶数，否则，它就是奇数 —— 写成布尔表达式，就是 <code>r % 2 == 0</code>。</p>
<p>这一次，你看到了单个等号 <code>=</code>：<code>r = random.randrange(1, 1000)</code>。</p>
<p>这个符号在绝大多数编程语言中都是 “<strong>赋值</strong>”（Assignment）的含义。</p>
<p>在 <code>r = 2</code> 之中，<code>r</code> 是一个名称为 <code>r</code> 的<strong>变量</strong>（Variable）—— 现在只需要将变量理解为程序<em>保存数值的地方</em>；而 <code>=</code> 是赋值符号，<code>2</code> 是一个整数<strong>常量</strong>（Literal）。</p>
<p>语句 <code>r = 2</code> 用自然语言描述就是：</p>
<blockquote>
<p>“把 <code>2</code> 这个值保存到名称为 <code>r</code> 的变量之中”。</p>
</blockquote>
<p>现在先别在意头两行代码的工作原理，只关注它的工作结果：<code>random.randrange(1, 1000)</code> 这部分代码的作用是返回一个 <em>1 到 1000 之间</em>（含左侧 <code>1</code> 但不含右侧 <code>1000</code>）的随机整数。每次执行以上的程序，它就生成一个新的随机整数，然后因为 <code>=</code> 的存在，这个数就被保存到 <code>r</code> 这个变量之中。</p>
<p>计算机程序的所谓 “智能”（起码相对于计算器），首先是因为它能做<em>布尔运算</em>。计算机的另外一个好处是 “不知疲倦”（反正它也不用自己交电费），所以，它最擅长处理的就是 “重复”，这个词在程序语言中，术语是<strong>循环</strong>（Loop）。以下程序会打印出 <code>10</code> 以内的所有奇数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">        print(i)</span><br></pre></td></tr></table></figure>
<pre><code>1
3
5
7
9
</code></pre><p>其中 <code>range(10)</code> 的返回值，是 <code>0～9</code> 的整数序列（默认起始值是 <code>0</code>；含左侧 <code>0</code>，不含右侧 <code>10</code>）。</p>
<p>用自然语言描述以上的程序，大概是这样的 —— 自然语言写在 <code>#</code> 之后：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>): <span class="comment"># 对于 0～9 中的所有数字都带入 i 这个变量，执行一遍以下任务：</span></span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> != <span class="number">0</span>:  <span class="comment">#     如果 i 除以 2 的余数不等于零的话，执行下面的语句：</span></span><br><span class="line">        print(i)    <span class="comment">#         向屏幕输出 i 这个变量中所保存的值</span></span><br></pre></td></tr></table></figure>
<p>就算你让它打印出一百亿以内的奇数，它也毫不含糊 —— 你只需要在 <code>range()</code> 这个函数的括号里写上一个那么大的整数就行……</p>
<p>让它干一点稍微复杂的事吧，比如，我们想要打印出 <code>100</code> 以内所有的<em>质数</em>（Primes）。</p>
<p>根据质数的定义，它大于等于 <code>2</code>，且只有在被它自身或者 <code>1</code> 做为除数时余数为 <code>0</code>。判断一个数字是否是质数的<strong>算法</strong>是这样的：</p>
<blockquote>
<ul>
<li>设 <code>n</code> 为整数，<code>n &gt;= 2</code>；</li>
<li>若 <code>n == 2</code>，<code>n</code> 是质数；</li>
<li>若 <code>n &gt; 2</code>，就把 <code>n</code> 作为被除数，从 <code>2</code> 开始一直到 <code>n - 1</code> 都作为除数，<em>逐一</em>计算看看余数是否等于 <code>0</code>？<blockquote>
<ul>
<li>如果是，那就不用接着算了，它不是质数；</li>
<li>如果全部都试过了，余数都不是 <code>0</code>，那么它是质数。</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<p>于是，你需要两个<strong>嵌套</strong>的循环，第一个是负责让被除数 <code>n</code> 从 <code>2</code> <strong>遍历</strong>（就是依次经历一次）到 <code>99</code>（题目是 <code>100</code> 以内，所以不包含 <code>100</code>）的循环，第二个是在前者内部负责让除数 <code>i</code> 从 <code>2</code> 遍历到 <code>n - 1</code> 的循环：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">100</span>): <span class="comment">#range(2,100)表示含左侧 2，不含右侧 100，是不是第三次看到这个说法了？</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        print(n)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">        <span class="keyword">if</span> (n % i) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:                  <span class="comment"># 这里目前你可能看不懂…… 但先关注结果吧。</span></span><br><span class="line">        print(n)</span><br></pre></td></tr></table></figure>
<pre><code>2
3
5
7
11
13
17
19
23
29
31
37
41
43
47
53
59
61
67
71
73
79
83
89
97
</code></pre><h2 id="所谓算法"><a href="#所谓算法" class="headerlink" title="所谓算法"></a>所谓算法</h2><p>以上的<strong>算法</strong>可以改进（程序员们经常用的词汇是 “<em>优化</em>”）<a id="plusone"></a>：</p>
<blockquote>
<p>从 <code>2</code> 作为除数开始试，试到 <sup>2</sup>&radic;<span style="text-decoration: overline">n</span> 之后的一个整数就可以了……</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">100</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        print(n)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, int(n ** <span class="number">0.5</span>)+<span class="number">1</span>): <span class="comment">#为什么要 +1 以后再说…… n 的 1/2 次方，相当于根号 n。</span></span><br><span class="line">        <span class="keyword">if</span> (n % i) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(n)</span><br></pre></td></tr></table></figure>
<pre><code>2
3
5
7
11
13
17
19
23
29
31
37
41
43
47
53
59
61
67
71
73
79
83
89
97
</code></pre><p>你看，寻找更有效的算法，或者说，不断优化程序，提高效率，最终是程序员的工作，不是编程语言本身的工作。关于判断质数最快的算法，<a href="https://stackoverflow.com/questions/1801391/what-is-the-best-algorithm-for-checking-if-a-number-is-prime" target="_blank" rel="noopener">可以看 Stackoverflow 上的讨论</a>，有更多时间也可以翻翻 <a href="https://en.wikipedia.org/wiki/Generating_primes" target="_blank" rel="noopener">Wikipedia</a>。</p>
<p>到最后，<strong>所有的工具都一样，效用取决于使用它的人</strong>。所以，学会使用工具固然重要，更为重要的是与此同时自己的能力必须不断提高。</p>
<p>虽然写代码这事刚开始学起来好像门槛很高，那只不过是幻觉，其实门槛比它更高的多的去了。到最后，它就是个最基础的工具，还是得靠思考能力 —— 这就好像识字其实挺难的 —— 小学初中高中加起来十来年，我们才掌握了基本的阅读能力；可最终，即便是本科毕业、研究生毕业，真的能写出一手好文章的人还是少之又少一样 —— 因为用文字值得写出来的是思想，用代码值得写出来的是创造，或者起码是有意义的问题的有效解决方案。有思想，能解决问题，是另外一门手艺 —— 需要终生精进的手艺。</p>
<h2 id="所谓函数"><a href="#所谓函数" class="headerlink" title="所谓函数"></a>所谓函数</h2><p>我们已经反复见过 <code>print()</code> 这个<strong>函数</strong>（Functions）了。它的作用很简单，就是把传递给它的值输出到屏幕上 —— 当然，事实上它的使用细节也很多，以后慢慢讲。</p>
<p>现在，最重要的是初步理解一个函数的基本构成。关于<strong>函数</strong>，相关的概念有：<em>函数名</em>（Function Name）、<em>参数</em>（Parameters）、<em>返回值</em>（Return Value）、<em>调用</em>（Call）。</p>
<p>拿一个更为简单的函数作为例子，<code>abs()</code>。它的作用很简单：接收一个数字作为参数，经过运算，返回该数字的绝对值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = abs(<span class="number">-3.1415926</span>)</span><br><span class="line">a</span><br></pre></td></tr></table></figure>
<pre><code>3.1415926
</code></pre><p>在以上的代码的第 1 行中，</p>
<blockquote>
<ul>
<li>我们<em>调用</em>了一个<em>函数名</em>为 <code>abs</code> 的函数；写法是 <code>abs(-3.1415926)</code>；</li>
<li>这么写，就相当于向它<em>传递</em>了一个<em>参数</em>，其值为：<code>-3.1415926</code>；</li>
<li>该函数接收到这个参数之后，根据这个参数的<em>值</em>在函数内部进行了<em>运算</em>；</li>
<li>而后该函数返回了一个值，<em>返回值</em>为之前接收到的参数的值的绝对值 <code>3.1415926</code>；</li>
<li>而后这个<em>值</em>被保存到<em>变量</em> <code>a</code> 之中。</li>
</ul>
</blockquote>
<p>从结构上来看，每个函数都是一个完整的程序，因为一个程序，核心构成部分就是<em>输入</em>、<em>处理</em>、<em>输出</em>：</p>
<blockquote>
<ul>
<li>它有输入 —— 即，它能接收外部通过参数传递的值；</li>
<li>它有处理 —— 即，内部有能够完成某一特定任务的代码；尤其是，它可以根据 “输入” 得到 “输出”；</li>
<li>它有输出 —— 即，它能向外部输送返回值……</li>
</ul>
</blockquote>
<p>被调用的函数，也可以被理解为<strong>子程序</strong>（Sub-Program）—— 主程序执行到函数调用时，就开始执行实现函数的那些代码，而后再返回主程序……</p>
<p>我们可以把判断一个数字是否是质数的过程，写成函数，以便将来在多处用得着的时候，随时可以调用它：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_prime</span><span class="params">(n)</span>:</span>            <span class="comment"># 定义 is_prime()，接收一个参数</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:              <span class="comment"># 开始使用接收到的那个参数（值）开始计算……</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>       <span class="comment"># 不再是返回给人，而是返回给调用它的代码……</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">2</span>, int(n**<span class="number">0.5</span>)+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> (n % m) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">80</span>, <span class="number">110</span>):</span><br><span class="line">    <span class="keyword">if</span> is_prime(i):          <span class="comment"># 调用 is_prime() 函数，</span></span><br><span class="line">        print(i)            <span class="comment"># 如果返回值为 True，则向屏幕输出 i</span></span><br></pre></td></tr></table></figure>
<pre><code>83
89
97
101
103
107
109
</code></pre><h2 id="细节补充"><a href="#细节补充" class="headerlink" title="细节补充"></a>细节补充</h2><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>一个完整的程序，由一个或者多个<strong>语句</strong>（Statements）构成。通常情况下，建议每一行只写一条语句。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">        print(i)</span><br></pre></td></tr></table></figure>
<pre><code>1
3
5
7
9
</code></pre><h3 id="语句块"><a href="#语句块" class="headerlink" title="语句块"></a>语句块</h3><p>在 Python 语言中，<strong>行首空白</strong>（Leading whitespace，由空格 <code>&#39; &#39;</code> 或者 Tab <code>⇥</code> 构成）有着特殊的含义。</p>
<p>如果有行首空白存在，那么，Python 将认为这一行与其他邻近有着相同行首空白的语句同属于一个<strong>语句块</strong> —— 而一个语句块必然由一个行末带有冒号 <code>:</code> 的语句起始。同属于一个语句块中的语句，行首空白数量应该相等。这看起来很麻烦，可实际上，程序员一般都使用专门的文本编辑器，比如 <a href="https://code.visualstudio.com" target="_blank" rel="noopener">Visual Studio Code</a>，其中有很多的辅助工具，可以让你很方便地输入具备一致性的行首空白。</p>
<p>以上程序，一共三个语句，两个语句块，一个 <code>for</code> 循环<em>语句块</em>中包含着一个 <code>if</code> 条件<em>语句块</em>。注意第一行和第二行末尾的冒号 <code>:</code>。</p>
<p>在很多其他的语言中，比如，JavaScript，用大括号 <code>{}</code> 作为语句块标示 —— 这是 Python 比较特殊的地方，它组织语句块的方式如下图所示：</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/python-leading-space.png?raw=true" alt></p>
<blockquote>
<p><strong>注意</strong>：在同一个文件里，不建议混合使用 Tab 和 Space；要么全用空格，要么全用制表符。</p>
</blockquote>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>在 Python 程序中可以用 <code>#</code> 符号标示<strong>注释</strong>语句。</p>
<p>所谓的注释语句，就是程序文件里写给人看而不是写给计算机看的部分。本节中的代码里就带着很多的注释。</p>
<p>人写的 Python 语言代码，要被 Python <strong>解释器</strong>翻译成机器语言，而后才能让计算机 “读懂”，随后计算机才可以按照指令执行。解释器在编译程序的过程中，遇到 <code>#</code> 符号，就会忽略其后的部分（包括这个注释符号）。</p>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p>在本节，我们见到的比较操作符可以比较它左右的值，而后返回一个布尔值。</p>
<p>我们也见过两个整数被<strong>操作符</strong> <code>%</code> 连接，左侧作为被除数，右侧作为除数，<code>11 % 3</code> 这个表达式的值是 <code>2</code>。对于数字，我们可用的操作符有 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>//</code>、<code>%</code>、<code>**</code> —— 它们分别代表加、减、乘、除、商、余、幂。</p>
<h3 id="赋值符号与操作符的连用"><a href="#赋值符号与操作符的连用" class="headerlink" title="赋值符号与操作符的连用"></a>赋值符号与操作符的连用</h3><p>你已经知道变量是什么了，也已经知道赋值是什么了。于是，你看到 <code>x = 1</code> 就明白了，这是为 <code>x</code> 赋值，把 <code>1</code> 这个值保存到变量 <code>x</code> 之中去。</p>
<p>但是，若是你看到 <code>x += 1</code>，就迷惑了，这是什么意思呢？</p>
<p>这只是编程语言中的一种惯用法。它相当于 <code>x = x + 1</code>。</p>
<p>看到 <code>x = x + 1</code> 依然会困惑…… 之所以困惑，是因为你还没有习惯把单等号 <code>=</code> 当作赋值符号，把双等号 <code>==</code> 当作逻辑判断的 “等于”。</p>
<p><code>x = x + 1</code> 的意思是说，把表达式 <code>x + 1</code> 的值保存到变量 <code>x</code> 中去 —— 如此这般之后，<code>x</code> 这个变量中所保存的就不再是原来的值了……</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">0</span></span><br><span class="line">x += <span class="number">1</span></span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>
<pre><code>1
</code></pre><p>其实不难理解，只要习惯了就好。理论上，加减乘除商余幂这些操作符，都可以与赋值符号并用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">11</span></span><br><span class="line">x %= <span class="number">3</span>   <span class="comment"># x = x % 3</span></span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>
<pre><code>2
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以下是这一章中所提到的重要概念。了解它们以及它们之间的关系，是进行下一步的基础。</p>
<blockquote>
<ul>
<li>数据：整数、布尔值；操作符；变量、赋值；表达式</li>
<li>函数、子程序、参数、返回值、调用</li>
<li>流程控制、分支、循环</li>
<li>算法、优化</li>
<li>程序：语句、注释、语句块</li>
<li>输入、处理、输出</li>
<li>解释器</li>
</ul>
</blockquote>
<p>你可能已经注意到了，这一章的小节名称罗列出来的话，看起来像是一本编程书籍的目录 —— 只不过是概念讲解顺序不同而已。事实上还真的就是那么回事。</p>
<p>这些概念，基本上都是<strong>独立于</strong>某一种编程语言的（Language Independent），无论将来你学习哪一种编程语言，不管是 C++，还是 JavaScript，抑或是 Golang，这些概念都在那里。</p>
<p>学会一门编程语言之后，再学其它的就会容易很多 —— 而且，当你学会了其中一个之后，早晚你会顺手学其它的，为了更高效使用微软办公套件，你可能会花上一两天时间研究一下 VBA；为了给自己做个网页什么的，你会顺手学会 JavaScript；为了修改某个编辑器插件，你发现人家是用 Ruby 写的，大致读读官方文档，你就可以下手用 Ruby 语言了；为了搞搞数据可视化，你会发现不学会 R 语言有点不方便……</p>
<p>你把这些概念装在脑子里，而后就会发现几乎所有的编程入门教学书籍结构都差不多是由这些概念构成的。因为，所有的编程语言基础都一样，所有的编程语言都是我们指挥计算机的工具。无论怎样，反正都需要输入输出，无论什么语言，不可能没有布尔运算，不可能没有流程控制，不可能没有函数，只要是高级语言，就都需要编译器…… 所以，掌握这些基本概念，是将来持续学习的基础。</p>
<hr>
<p><strong>脚注</strong></p>
<p><a name="fn1">[1]</a>：对于自学能力强、有很多自学经验的人来说，速成往往真的是可能、可行的。因为他们已经积累的知识与经验会在习得新技能时发挥巨大的作用，乃至于他们看起来相对别人花极少的时间就能完成整个自学任务。也就是说，将来的那个已经习得自学能力、且自学能力已经磨练得很强的你，常常真的可以做到在别人眼里 “速成”。</p>
<p><a href="#fn1b"><small>↑Back to Content↑</small></a></p>
<h1 id="值及其相应的运算"><a href="#值及其相应的运算" class="headerlink" title="值及其相应的运算"></a>值及其相应的运算</h1><p>从结构上来看，一切的计算机程序，都由且只由两个最基本的成分构成：</p>
<blockquote>
<ul>
<li><strong>运算</strong>（Evaluation）</li>
<li><strong>流程控制</strong>（Control Flow）</li>
</ul>
</blockquote>
<p>没有流程控制的是计算器而已；有流程控制的才是可编程设备。</p>
<p>看看之前我们见过的计算质数的程序：（按一下 <code>⎋</code>，即 <code>ESC</code>，确保已经进入命令模式，<code>⇧ L</code> 可以切换是否显示代码行号）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_prime</span><span class="params">(n)</span>:</span>            <span class="comment"># 定义 is_prime()，接收一个参数</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:              <span class="comment"># 开始使用接收到的那个参数（值）开始计算……</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>       <span class="comment"># 不再是返回给人，而是返回给调用它的代码……</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">2</span>, int(n**<span class="number">0.5</span>)+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> (n % m) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">80</span>, <span class="number">110</span>):</span><br><span class="line">    <span class="keyword">if</span> is_prime(i):          <span class="comment"># 调用 is_prime() 函数，</span></span><br><span class="line">        print(i)            <span class="comment"># 如果返回值为 True，则向屏幕输出 i</span></span><br></pre></td></tr></table></figure>
<pre><code>83
89
97
101
103
107
109
</code></pre><p><code>if...</code>，<code>for...</code> 在控制流程：在什么情况下运算什么，在什么情况下重复运算什么；</p>
<p>第 13 行 <code>is_prime()</code> 这个函数的调用，也是在控制流程 —— 所以我们可以<strong>把函数看作是 “子程序” </strong>；</p>
<p>一旦这个函数被调用，流程就转向开始执行在第 1 行中定义的 <code>is_prime()</code> 函数内部的代码，而这段代码内部还是<em>计算</em>和<em>流程控制</em>，决定一个返回值 —— 返回值是布尔值；再回到第 13 行，将返回值交给 <code>if</code> 判断，决定是否执行第 14 行……</p>
<p>而计算机这种可编程设备之所以可以做流程控制，是因为它可以做<strong>布尔运算</strong>，即，它可以<em>对布尔值</em>进行<em>操作</em>，而后将布尔值交给<em>分支</em>和<em>循环</em>语句，构成了程序中的流程控制。</p>
<h2 id="值"><a href="#值" class="headerlink" title="值"></a>值</h2><p>从本质上看，程序里的绝大多数语句包含着<strong>运算</strong>（Evaluation），即，在对某个值进行<strong>评价</strong>。这里的 “评价”，不是 “判断某人某事的好坏”，而是 “<em>计算出某个值究竟是什么</em>” —— 所以，我们用中文的 “<strong>运算</strong>” 翻译这个 “<em>Evaluation</em>” 可能表达得更准确一些。</p>
<p>在程序中，被运算的可分为<strong>常量</strong>（Literals）和<strong>变量</strong>（Variables）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span> + <span class="number">2</span> * <span class="number">3</span></span><br><span class="line">a += <span class="number">1</span></span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<p>在以上代码中，</p>
<p><code>1</code>、<code>2</code>、<code>3</code>，都是<strong>常量</strong>。<em>Literal</em> 的意思是 “字面的”，顾名思义，常量的<em>值</em>就是它字面上的值。<code>1</code> 的值，就是 <code>1</code>。</p>
<p><code>a</code> 是<strong>变量</strong>。顾名思义，它的值将来是可变的。比如，在第 2 句中，这个变量的<em>值</em>发生了改变，之前是 <code>7</code>，之后变成了 <code>8</code>。</p>
<p>第 1 句中的 <code>+</code>、<code>*</code>，是<strong>操作符</strong>（Operators），它用来对其左右的值进行相应的<em>运算</em>而后得到一个值。先是由操作符 <code>*</code> 对 <code>2</code> 和 <code>3</code> 进行运算，<br>生成一个值，<code>6</code>；然后再由操作符 <code>+</code> 对 <code>1</code> 和 <code>6</code> 进行运算，生成一个值 <code>7</code>。先算乘除后算加减，这是操作符的<strong>优先级</strong>决定的。</p>
<p><code>=</code> 是赋值符号，它的作用是将它右边的值保存到左边的变量中。</p>
<p><em>值</em>是程序的基础成分（Building blocks），它就好像盖房子用的砖块一样，无论什么样的房子，到最后都主要是由砖块构成。</p>
<p><em>常量</em>，当然有个<em>值</em> —— 就是它们字面所表达的值。</p>
<p><em>变量</em>必须先<em>赋值</em>才能使用，也就是说，要先把一个<em>值</em>保存到变量中，它才能在其后被运算。</p>
<p>在 Python 中每个函数都有<em>返回值</em>，即便你在定义一个函数的时候没有设定返回值，它也会加上默认的返回值 <code>None</code>……（请注意 <code>None</code> 的大小写！）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">print(f())        <span class="comment"># 输出 f() 这个函数被调用后的返回值，None</span></span><br><span class="line">print(print(f())) <span class="comment"># 这一行最外围的 print() 调用了一次 print(f())，所以输出一个 None，</span></span><br><span class="line">                  <span class="comment"># 而后再输出这次调用的返回值，所以又输出一次 None</span></span><br></pre></td></tr></table></figure>
<pre><code>None
None
None
</code></pre><p>当我们调用一个函数的时候，本质上来看，就相当于：</p>
<blockquote>
<p>我们把一个值交给某个函数，请函数根据它内部的运算和流程控制对其进行操作而后返回另外一个值。</p>
</blockquote>
<p>比如，<code>abs()</code> 函数，就会返回传递给它的<em>值</em>的<em>绝对值</em>；<code>int()</code> 函数，会将传递给它的值的小数部分砍掉；<code>float()</code> 接到整数参数之后，会返回这个整数的浮点数形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line">abs(<span class="number">-3.14159</span>)</span><br><span class="line">int(abs(<span class="number">-3.14159</span>))</span><br><span class="line">float(int(abs(<span class="number">-3.14159</span>)))</span><br></pre></td></tr></table></figure>
<pre><code>3.14159
3
3.0
</code></pre><h2 id="值的类型"><a href="#值的类型" class="headerlink" title="值的类型"></a>值的类型</h2><p>在编程语言中，总是包含最基本的三种数据类型：</p>
<blockquote>
<ul>
<li>布尔值（Boolean Value)</li>
<li>数字（Numbers）：整数（Int）、浮点数（Float）、复数（Complex Numbers）</li>
<li>字符串（Strings）</li>
</ul>
</blockquote>
<p>既然有不同类型的数据，它们就分别对应着不同类型的值。</p>
<p>运算的一个默认法则就是，通常情况下应该是<em>相同类型的值才能相互运算</em>。</p>
<p>显然，数字与数字之间的运算是合理的，但你让 <code>+</code> 这个操作符对一个字符串和一个数字进行运算就不行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line"><span class="number">11</span> + <span class="number">10</span> - <span class="number">9</span> * <span class="number">8</span> / <span class="number">7</span> // <span class="number">6</span> % <span class="number">5</span></span><br><span class="line"><span class="string">'3.14'</span> + <span class="number">3</span>                  <span class="comment"># 这一句会报错</span></span><br></pre></td></tr></table></figure>
<pre><code>20.0

---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

&lt;ipython-input-18-e922b7565e53&gt; in &lt;module&gt;
      3
      4 11 + 10 - 9 * 8 / 7 // 6 % 5
----&gt; 5 &apos;3.14&apos; + 3                  # 这一句会报错

TypeError: can only concatenate str (not &quot;int&quot;) to str
</code></pre><p>所以，在不得不对不同类型的值进行运算之前，总是要事先做 <strong>Type Casting</strong>（类型转换）。比如，</p>
<blockquote>
<ul>
<li>将字符串转换为数字用 <code>int()</code>、<code>float()</code>；</li>
<li>将数字转换成字符串用 <code>str()</code>；</li>
</ul>
</blockquote>
<p>另外，即便是在数字之间进行计算的时候，有时也需要将整数转换成浮点数字，或者反之：</p>
<blockquote>
<ul>
<li>将整数转换成浮点数字用 <code>float()</code>；</li>
<li>将浮点数字转换成整数用 <code>int()</code>；</li>
</ul>
</blockquote>
<p>有个函数，<code>type()</code>，可以用来查看某个值属于什么类型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line">type(<span class="number">3</span>)</span><br><span class="line">type(<span class="number">3.0</span>)</span><br><span class="line">type(<span class="string">'3.14'</span>)</span><br><span class="line">type(<span class="literal">True</span>)</span><br><span class="line">type(range(<span class="number">10</span>))</span><br><span class="line">type([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">type((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">type(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</span><br><span class="line">type(&#123;<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>, <span class="string">'c'</span>:<span class="number">3</span>&#125;)</span><br></pre></td></tr></table></figure>
<pre><code>int
float
str
bool
range
list
tuple
set
dict
</code></pre><h2 id="操作符-1"><a href="#操作符-1" class="headerlink" title="操作符"></a>操作符</h2><p>针对不同类型的数据，有各自专用的<strong>操作符</strong>。</p>
<h3 id="数值操作符"><a href="#数值操作符" class="headerlink" title="数值操作符"></a>数值操作符</h3><p>针对数字进行计算的操作符有加减乘除商余幂：<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>//</code>、<code>%</code>、<code>**</code>。</p>
<p>其中 <code>+</code> 和 <code>-</code> 可以对单个值进行操作，<code>-3</code>；其它的操作符需要有两个值才能操作。</p>
<p>从优先级来看，这些操作符中：</p>
<blockquote>
<ul>
<li>对两个值进行操作的 <code>+</code>、<code>-</code> 的优先级最低；</li>
<li>稍高的是 <code>*</code>、<code>/</code>、<code>//</code>、<code>%</code>；</li>
<li>更高的是对单个值进行操作的 <code>+</code>、<code>-</code>；</li>
<li>优先级最高的是 <code>**</code>。</li>
</ul>
</blockquote>
<p>完整的操作符优先级列表，参见官方文档：</p>
<blockquote>
<p><a href="https://docs.python.org/3/reference/expressions.html#operator-precedence" target="_blank" rel="noopener">https://docs.python.org/3/reference/expressions.html#operator-precedence</a></p>
</blockquote>
<h3 id="布尔值操作符"><a href="#布尔值操作符" class="headerlink" title="布尔值操作符"></a>布尔值操作符</h3><p>针对布尔值，操作符有<code>与</code>、<code>或</code>、<code>非</code>：<code>and</code>、<code>or</code>、<code>not</code>。</p>
<p>它们之中，优先级最低的是或 <code>or</code>，然后是与 <code>and</code>, 优先级最高的是非 <code>not</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">True</span> <span class="keyword">and</span> <span class="literal">False</span> <span class="keyword">or</span> <span class="keyword">not</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<pre><code>False
</code></pre><p>最先操作的是 <code>not</code>，因为它优先级最高。所以，上面的表达式相当于 <code>True and False or (not True)</code>，即相当于 <code>True and False or False</code>；</p>
<p>然后是 <code>and</code>，所以，<code>True and False or False</code> 相当于是 <code>(True and False) or False</code>，即相当于 <code>False or False</code>；</p>
<p>于是，最终的值是 <code>False</code>。</p>
<h3 id="逻辑操作符-1"><a href="#逻辑操作符-1" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h3><p>数值之间还可以使用逻辑操作符，<code>1 &gt; 2</code> 返回布尔值 <code>False</code>。逻辑操作符有：<code>&lt;</code>（小于）、<code>&lt;=</code>（小于等于）、<code>&gt;</code>（大于）、<code>&gt;=</code>（大于等于）、<code>!=</code>（不等于）、<code>==</code>（等于）。</p>
<p>逻辑操作符的优先级，高于布尔值的操作符，低于数值计算的操作符。<br>即：数值计算的操作符优先级最高，其次是逻辑操作符，布尔值的操作符优先级最低。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">-95</span></span><br><span class="line">n &lt; <span class="number">0</span> <span class="keyword">and</span> (n + <span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<pre><code>True
</code></pre><h3 id="字符串操作符"><a href="#字符串操作符" class="headerlink" title="字符串操作符"></a>字符串操作符</h3><p>针对字符串，有三种操作：</p>
<blockquote>
<ul>
<li>拼接：<code>+</code> 和 <code>&#39; &#39;</code>（后者是空格）</li>
<li>拷贝：<code>*</code></li>
<li>逻辑运算：<code>in</code>、<code>not in</code>；以及，<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code>、<code>!=</code>、<code>==</code></li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line"><span class="string">'Awesome'</span> + <span class="string">'Python'</span></span><br><span class="line"><span class="string">'Awesome'</span> <span class="string">'Python'</span></span><br><span class="line"><span class="string">'Python, '</span> + <span class="string">'Awesome! '</span> * <span class="number">3</span></span><br><span class="line"><span class="string">'o'</span> <span class="keyword">in</span> <span class="string">'Awesome'</span> <span class="keyword">and</span> <span class="string">'o'</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">'Python'</span></span><br></pre></td></tr></table></figure>
<pre><code>&apos;AwesomePython&apos;
&apos;AwesomePython&apos;
&apos;Python, Awesome! Awesome! Awesome! &apos;
False
</code></pre><p>字符之间，字符串之间，除了 <code>==</code> 和 <code>!=</code> 之外，也都可以被逻辑操作符 <code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code> 运算：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'a'</span> &lt; <span class="string">'b'</span></span><br></pre></td></tr></table></figure>
<pre><code>True
</code></pre><p>这是因为字符对应着 Unicode 码，字符在被比较的时候，被比较的是对应的 Unicode 码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line"><span class="string">'A'</span> &gt; <span class="string">'a'</span></span><br><span class="line">ord(<span class="string">'A'</span>)</span><br><span class="line">ord(<span class="string">'a'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>False
65
97
</code></pre><p>当字符串被比较的时候，将从两个字符串各自的第一个字符开始逐个比较，“一旦决出胜负马上停止”：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'PYTHON'</span> &gt; <span class="string">'Python 3'</span></span><br></pre></td></tr></table></figure>
<pre><code>False
</code></pre><h3 id="列表的操作符"><a href="#列表的操作符" class="headerlink" title="列表的操作符"></a>列表的操作符</h3><p>数字和字符串（由字符构成的序列）是最基本的数据类型，而我们往往需要批量处理数字和字符串，这样的时候，我们需要<strong>数组</strong>（Array）。不过，在 Python 语言中，它提供了一个<strong>容器</strong>（Container）的概念，用来容纳批量的数据。</p>
<p>Python 的容器有很多种 —— 字符串，其实也是容器的一种，它的里面容纳着批量的字符。</p>
<p>我们先简单接触一下另外一种容器：<strong>列表</strong>（List）。</p>
<p>列表的标示，用方括号 <code>[]</code>；举例来说，<code>[1, 2, 3, 4, 5]</code> 和 <code>[&#39;ann&#39;, &#39;bob&#39;, &#39;cindy&#39;, &#39;dude&#39;, &#39;eric&#39;]</code>，或者 <code>[&#39;a&#39;, 2, &#39;b&#39;, 32, 22, 12]</code> 都是一个列表。</p>
<p>因为列表和字符串一样，都是<em>有序容器</em>（容器还有另外一种是无序容器），所以，它们可用的操作符其实相同：</p>
<blockquote>
<ul>
<li>拼接：<code>+</code> 和 <code>&#39; &#39;</code>（后者是空格）</li>
<li>拷贝：<code>*</code></li>
<li>逻辑运算：<code>in</code>、<code>not in</code>；以及，<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code>、<code>!=</code>、<code>==</code></li>
</ul>
</blockquote>
<p>两个列表在比较时（前提是两个列表中的数据元素类型相同），遵循的还是跟字符串比较相同的规则：“一旦决出胜负马上停止”。但实际上，由于列表中可以包含不同类型的元素，所以，通常情况下没有实际需求对他们进行 “大于、小于” 的比较。（比较时，类型不同会引发 <code>TypeError</code>……）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line">a_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">b_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">c_list = [<span class="string">'ann'</span>, <span class="string">'bob'</span>, <span class="string">'cindy'</span>, <span class="string">'dude'</span>, <span class="string">'eric'</span>]</span><br><span class="line">a_list &gt; b_list</span><br><span class="line"><span class="number">10</span> <span class="keyword">not</span> <span class="keyword">in</span> a_list</span><br><span class="line"><span class="string">'ann'</span> <span class="keyword">in</span> c_list</span><br></pre></td></tr></table></figure>
<pre><code>False
True
True
</code></pre><h2 id="更复杂的运算"><a href="#更复杂的运算" class="headerlink" title="更复杂的运算"></a>更复杂的运算</h2><p>对于数字进行加、减、乘、除、商、余、幂的操作，对于字符串进行拼接、拷贝、属于的操作，对布尔值进行或、与、非的操作，这些都是相对简单的运算。</p>
<p>更为复杂一点的，我们要通过调用函数来完成 —— 因为在函数内部，我们可以用比 “单个表达式” 更为复杂的程序针对传递进来的参数进行运算。换言之，函数就相当于各种事先写好的子程序，给它传递一个值，它会对其进行运算，而后返回一个值（最起码返回一个 <code>None</code>）。</p>
<p>以下是 Python 语言所有的内建函数（<a href="https://docs.python.org/3/library/functions.html" target="_blank" rel="noopener">Built-in Functions</a>）：</p>
<table>
<thead>
<tr>
<th>(</th>
<th>Python</th>
<th>Built-in</th>
<th>Functions</th>
<th>)</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://docs.python.org/3/library/functions.html#abs" target="_blank" rel="noopener">abs()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#delattr" target="_blank" rel="noopener">delattr()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#hash" target="_blank" rel="noopener">hash()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#func-memoryview" target="_blank" rel="noopener">memoryview()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#func-set" target="_blank" rel="noopener">set()</a></td>
</tr>
<tr>
<td><a href="https://docs.python.org/3/library/functions.html#all" target="_blank" rel="noopener">all()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#func-dict" target="_blank" rel="noopener">dict()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#help" target="_blank" rel="noopener">help()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#min" target="_blank" rel="noopener">min()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#setattr" target="_blank" rel="noopener">setattr()</a></td>
</tr>
<tr>
<td><a href="https://docs.python.org/3/library/functions.html#any" target="_blank" rel="noopener">any()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#dir" target="_blank" rel="noopener">dir()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#hex" target="_blank" rel="noopener">hex()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#next" target="_blank" rel="noopener">next()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#slice" target="_blank" rel="noopener">slice()</a></td>
</tr>
<tr>
<td><a href="https://docs.python.org/3/library/functions.html#ascii" target="_blank" rel="noopener">ascii()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#divmod" target="_blank" rel="noopener">divmod()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#id" target="_blank" rel="noopener">id()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#object" target="_blank" rel="noopener">object()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#sorted" target="_blank" rel="noopener">sorted()</a></td>
</tr>
<tr>
<td><a href="https://docs.python.org/3/library/functions.html#bin" target="_blank" rel="noopener">bin()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#enumerate" target="_blank" rel="noopener">enumerate()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#input" target="_blank" rel="noopener">input()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#oct" target="_blank" rel="noopener">oct()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#staticmethod" target="_blank" rel="noopener">staticmethod()</a></td>
</tr>
<tr>
<td><a href="https://docs.python.org/3/library/functions.html#bool" target="_blank" rel="noopener">bool()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#eval" target="_blank" rel="noopener">eval()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#int" target="_blank" rel="noopener">int()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#open" target="_blank" rel="noopener">open()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#func-str" target="_blank" rel="noopener">str()</a></td>
</tr>
<tr>
<td><a href="https://docs.python.org/3/library/functions.html#breakpoint" target="_blank" rel="noopener">breakpoint()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#exec" target="_blank" rel="noopener">exec()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#isinstance" target="_blank" rel="noopener">isinstance()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#ord" target="_blank" rel="noopener">ord()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#sum" target="_blank" rel="noopener">sum()</a></td>
</tr>
<tr>
<td><a href="https://docs.python.org/3/library/functions.html#func-bytearray" target="_blank" rel="noopener">bytearray()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#filter" target="_blank" rel="noopener">filter()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#issubclass" target="_blank" rel="noopener">issubclass()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#pow" target="_blank" rel="noopener">pow()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#super" target="_blank" rel="noopener">super()</a></td>
</tr>
<tr>
<td><a href="https://docs.python.org/3/library/functions.html#func-bytes" target="_blank" rel="noopener">bytes()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#float" target="_blank" rel="noopener">float()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#iter" target="_blank" rel="noopener">iter()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#print" target="_blank" rel="noopener">print()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#func-tuple" target="_blank" rel="noopener">tuple()</a></td>
</tr>
<tr>
<td><a href="https://docs.python.org/3/library/functions.html#callable" target="_blank" rel="noopener">callable()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#format" target="_blank" rel="noopener">format()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#len" target="_blank" rel="noopener">len()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#property" target="_blank" rel="noopener">property()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#type" target="_blank" rel="noopener">type()</a></td>
</tr>
<tr>
<td><a href="https://docs.python.org/3/library/functions.html#chr" target="_blank" rel="noopener">chr()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#func-frozenset" target="_blank" rel="noopener">frozenset()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#func-list" target="_blank" rel="noopener">list()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#func-range" target="_blank" rel="noopener">range()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#vars" target="_blank" rel="noopener">vars()</a></td>
</tr>
<tr>
<td><a href="https://docs.python.org/3/library/functions.html#classmethod" target="_blank" rel="noopener">classmethod()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#getattr" target="_blank" rel="noopener">getattr()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#locals" target="_blank" rel="noopener">locals()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#repr" target="_blank" rel="noopener">repr()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#zip" target="_blank" rel="noopener">zip()</a></td>
</tr>
<tr>
<td><a href="https://docs.python.org/3/library/functions.html#compile" target="_blank" rel="noopener">compile()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#globals" target="_blank" rel="noopener">globals()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#map" target="_blank" rel="noopener">map()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#reversed" target="_blank" rel="noopener">reversed()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#__import__" target="_blank" rel="noopener"><strong>import</strong>()</a></td>
</tr>
<tr>
<td><a href="https://docs.python.org/3/library/functions.html#complex" target="_blank" rel="noopener">complex()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#hasattr" target="_blank" rel="noopener">hasattr()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#max" target="_blank" rel="noopener">max()</a></td>
<td><a href="https://docs.python.org/3/library/functions.html#round" target="_blank" rel="noopener">round()</a></td>
</tr>
</tbody>
</table>
<p>现在倒不用着急一下子全部了解它们 —— 反正早晚都会的。</p>
<p>这其中，针对数字，有计算绝对值的函数 <code>abs()</code>，有计算商余的函数 <code>divmod()</code> 等等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line">abs(<span class="number">-3.1415926</span>)</span><br><span class="line">divmod(<span class="number">11</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<pre><code>3.1415926
(3, 2)
</code></pre><p>这些内建函数也依然只能完成 “基本操作”，比如，对于数字，我们想计算三角函数的话，内建函数就帮不上忙了，于是，我们需要调用标准库（Standard Library）中的 math 模块（Module）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line">math.sin(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<pre><code>-0.9589242746631385
</code></pre><p>代码 <code>math.sin(5)</code> 这里的 <code>.</code>，也可以被理解为 “操作符”，它的作用是：</p>
<blockquote>
<p>从其它模块中调用函数。</p>
</blockquote>
<p>代码 <code>math.sin(5)</code> 的作用是：</p>
<blockquote>
<p>把 <code>5</code> 这个值，传递给 <code>math</code> 这个模块里的 <code>sin()</code> 函数，让 <code>sin()</code> 根据它内部的代码对这个值进行运算，而后返回一个值（即，计算结果）。</p>
</blockquote>
<p>类（Class）中定义的函数，也可以这样被调用 —— 虽然你还不明白类（Class）究竟是什么，但从结构上很容易理解，它实际上也是保存在其他文件中的一段代码，于是，那段代码内部定义的函数，也可以这样调用。</p>
<p>比如，数字，其实属于一个类，所以，我们可以调用那个类里所定义的函数，比如，<code>float.as_integer_ratio()</code>，它将返回两个值，第一个值除以第二个值，恰好等于传递给它的那个浮点数字参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.1415926</span>.as_integer_ratio()</span><br></pre></td></tr></table></figure>
<pre><code>(3537118815677477, 1125899906842624)
</code></pre><h2 id="关于布尔值的补充"><a href="#关于布尔值的补充" class="headerlink" title="关于布尔值的补充"></a>关于布尔值的补充</h2><p>当你看到以下这样的表达式，而后再看看它的结果，你可能会多少有点迷惑：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">True</span> <span class="keyword">or</span> <span class="string">'Python'</span></span><br></pre></td></tr></table></figure>
<pre><code>True
</code></pre><p>这是因为 Python 将 <code>True</code> 定义为：</p>
<blockquote>
<p>By default, an object is considered true unless its class defines either a __bool__() method that returns <code>False</code> or a __len__() method that returns zero, when called with the object.</p>
<p><a href="https://docs.python.org/3/library/stdtypes.html#truth-value-testing" target="_blank" rel="noopener">https://docs.python.org/3/library/stdtypes.html#truth-value-testing</a></p>
</blockquote>
<p>这一段文字，初学者是看不懂的。但下一段就好理解了：</p>
<blockquote>
<p>Here are most of the built-in objects considered <code>False</code>:</p>
<blockquote>
<ul>
<li>constants defined to be false: <code>None</code> and <code>False</code>.</li>
<li>zero of any numeric type: <code>0</code>, <code>0.0</code>, <code>0j</code>, <code>Decimal(0)</code>, <code>Fraction(0, 1)</code></li>
<li>empty sequences and collections: <code>&#39;&#39;</code>, <code>()</code>, <code>[]</code>, <code>{}</code>, <code>set()</code>, <code>range(0)</code></li>
</ul>
</blockquote>
</blockquote>
<p>所以，<code>&#39;Python&#39;</code> 是个非空的字符串，即，不属于是 <code>empty sequences</code>，所以它不被认为是 <code>False</code>，即，它的布尔值是 <code>True</code></p>
<p>于是，这么理解就轻松了：</p>
<blockquote>
<p>每个变量或者常量，除了它们的值之外，同时还相当于有一个对应的布尔值。</p>
</blockquote>
<h2 id="关于值的类型的补充"><a href="#关于值的类型的补充" class="headerlink" title="关于值的类型的补充"></a>关于值的类型的补充</h2><p>除了数字、布尔值、字符串，以及上一小节介绍的列表之外，还有若干数据类型，比如 <code>range()</code>（等差数列）、<code>tuple</code>（元组）、<code>set</code>（集合）、<code>dictionary</code>（字典），再比如 <code>Date Type</code>（日期）等等。</p>
<p>它们都是基础数据类型的各种组合 —— 现实生活中，更多需要的是把基础类型组合起来构成的数据。比如，一个通讯簿，里面是一系列字符串分别对应着若干字符串和数字。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">entry[<span class="number">3662</span>] = &#123;</span><br><span class="line">    <span class="string">'first_name'</span>: <span class="string">'Michael'</span>,</span><br><span class="line">    <span class="string">'last_name'</span>: <span class="string">'Willington'</span>,</span><br><span class="line">    <span class="string">'birth_day'</span>: <span class="string">'12/07/1992'</span>,</span><br><span class="line">    <span class="string">'mobile'</span>: &#123;</span><br><span class="line">        <span class="string">'+714612234'</span>,</span><br><span class="line">        <span class="string">'+716253923'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="string">'id'</span>: <span class="number">3662</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>针对不同的类型，都有相对应的操作符，可以对其进行运算。</p>
<p>这些类型之间有时也有不得不相互运算的需求，于是，在相互运算之前同样要 <em>Type Casting</em>，比如将 List 转换为 Set，或者反之：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">b = set(a)</span><br><span class="line">c = list(b)</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<pre><code>[1, 2, 3, 4, 5, 6, 7]
{1, 2, 3, 4, 5, 6, 7}
[1, 2, 3, 4, 5, 6, 7]
</code></pre><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>回到最开始：从结构上来看，一切的计算机程序，都由且只由两个最基本的成分构成：</p>
<blockquote>
<ul>
<li><strong>运算</strong>（Evaluation）</li>
<li><strong>流程控制</strong>（Control Flow）</li>
</ul>
</blockquote>
<p>这一章主要介绍了基础数据类型的运算细节。而除了基础数据类型，我们需要由它们组合起来的更多复杂数据类型。但无论数据的类型是什么，被操作符操作的总是该数据的<strong>值</strong>。所以，虽然绝大多数编程书籍按照惯例会讲解 “数据类型”，但为了究其本质，我们在这里关注的是 “值的类型”。虽然只是关注焦点上的一点点转换，但实践证明，这一点点的不同，对初学者更清楚地把握知识点有巨大的帮助。</p>
<p>针对每一种<em>值</em>的类型，无论简单复杂，都有相应的操作方式：</p>
<blockquote>
<ul>
<li><strong>操作符</strong><ul>
<li>值运算</li>
<li>逻辑运算</li>
</ul>
</li>
<li><strong>函数</strong><ul>
<li>内建函数</li>
<li>其他模块里的函数</li>
<li>其本身所属类之中所定义的函数</li>
</ul>
</li>
</ul>
</blockquote>
<p>所以，接下来要学习的，无非就是熟悉各种<em>数据类型</em>，及其相应的操作，包括能对它们的<em>值</em>进行操作的操作符和函数；无论是操作符还是函数，最终都会返回一个相应的<strong>值</strong>，及其相应的<em>布尔值</em> —— 这么看来，编程知识结构没多复杂。因为换句话讲，</p>
<blockquote>
<p>接下来你要学习的无非是各种<em>数据类型</em>的<em>运算</em>而已。</p>
</blockquote>
<p>另外，虽然现在尚未来得及对<strong>函数</strong>进行深入讲解，但最终你会发现它跟操作符一样，在程序里无所不在。</p>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p>另外，以下几个链接先放在这里，未来你会返回来参考它们，还是不断地参考它们：</p>
<blockquote>
<ul>
<li>关于表达式：<a href="https://docs.python.org/3/reference/expressions.html" target="_blank" rel="noopener">https://docs.python.org/3/reference/expressions.html</a></li>
<li>关于所有操作的优先级：<a href="https://docs.python.org/3/reference/expressions.html#operator-precedence" target="_blank" rel="noopener">https://docs.python.org/3/reference/expressions.html#operator-precedence</a></li>
<li>上一条链接不懂 BNF 的话根本读不懂：<a href="https://en.wikipedia.org/wiki/Backus-Naur_form" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Backus-Naur_form</a></li>
<li>Python 的内建函数：<a href="https://docs.python.org/3/library/functions.html" target="_blank" rel="noopener">https://docs.python.org/3/library/functions.html</a></li>
<li>Python 的标准数据类型：<a href="https://docs.python.org/3/library/stdtypes.html" target="_blank" rel="noopener">https://docs.python.org/3/library/stdtypes.html</a></li>
</ul>
</blockquote>
<p>另外，其实所有的操作符，在 Python 内部也是调用函数完成的……</p>
<blockquote>
<p><a href="https://docs.python.org/3.7/library/operator.html" target="_blank" rel="noopener">https://docs.python.org/3.7/library/operator.html</a></p>
</blockquote>
<h1 id="流程控制-1"><a href="#流程控制-1" class="headerlink" title="流程控制"></a>流程控制</h1><p>在相对深入了解了值的基本操作之后，我们需要再返回来对流程控制做更深入的了解。</p>
<p>之前我们看过这个寻找质数的程序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">100</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        print(n)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">        <span class="keyword">if</span> (n % i) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(n)</span><br></pre></td></tr></table></figure>
<p>这其中，包含了<em>分支</em>与<em>循环</em> —— 无论多复杂的流程控制用这两个东西就够了，就好像无论多复杂的电路最终都是由通路和开路仅仅两个状态构成的一样。</p>
<blockquote>
<p>今天的人们觉得这是 “天经地义” 的事情，可实际上并非如此。这是 1966 年的一篇论文所带来的巨大改变 —— <em>Flow diagrams, turing machines and languages with only two formation rules</em> by Böhm and Jacopini (1966)。实际上，直到上个世纪末，<code>GOTO</code> 语句才从各种语言里近乎 “灭绝”……</p>
<p>任何进步，无论大小，其实都相当不容易，都非常耗时费力 —— 在哪儿都一样。有兴趣、有时间，可以去浏览 Wikipedia 上的简要说明 —— <a href="https://en.wikipedia.org/wiki/Control_flow#Goto" target="_blank" rel="noopener">Wikipedia: Minimal structured control flow</a>。</p>
</blockquote>
<h2 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h2><p><code>if</code> 语句的最简单构成是这样 —— 注意第 1 行末尾的冒号 <code>:</code> 和第 2 行的缩进：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> expression:</span><br><span class="line">    statements</span><br></pre></td></tr></table></figure>
<p>如果表达式 <code>expression</code> 返回值为真，执行 <code>if</code> 语句块内部的 <code>statements</code>，否则，什么都不做，执行 <code>if</code> 之后的下一个语句。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">r = random.randrange(<span class="number">1</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> r % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">    print(<span class="string">f'<span class="subst">&#123;r&#125;</span> is even.'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>372 is even.
</code></pre><p>如果，表达式 <code>expression</code> 返回值无论真假，我们都需要做一点相应的事情，那么我们这么写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> expression:</span><br><span class="line">    statements_for_True</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    statements_for_False</span><br></pre></td></tr></table></figure>
<p>如果表达式 <code>expression</code> 返回值为真，执行 <code>if</code> 语句块内部的 <code>statements_for_True</code>，否则，就执行 <code>else</code> 语句块内部的 <code>statements_for_False</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">r = random.randrange(<span class="number">1</span>, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> r % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">    print(<span class="string">f'<span class="subst">&#123;r&#125;</span> is even.'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">f'<span class="subst">&#123;r&#125;</span> is odd.'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>945 is odd.
</code></pre><p>有时，表达式 <code>&lt;expression&gt;</code> 返回的值有多种情况，并且针对不同的情况我们都要做相应的事情，那么可以这么写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> expression_1:</span><br><span class="line">    statements_for_expression_1_True</span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> expression_2:</span><br><span class="line">    statements_for_expression_2_True</span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> expression_3:</span><br><span class="line">    statements_for_expression_3_True</span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> expression_...:</span><br><span class="line">    statements_for_expression_..._True</span><br></pre></td></tr></table></figure>
<p>Python 用 <code>elif</code> 处理这种多情况分支，相当于其它编程语言中使用 <code>switch</code> 或者 <code>case</code>……</p>
<p><code>elif</code> 是 <code>else if</code> 的缩写，作用相同。</p>
<p>以下程序模拟投两个骰子的结果 —— 两个骰子数字加起来，等于 <code>7</code> 算平，大于 <code>7</code> 算大，小于 <code>7</code> 算小：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">r = random.randrange(<span class="number">2</span>, <span class="number">13</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> r == <span class="number">7</span>:</span><br><span class="line">    print(<span class="string">'Draw!'</span>)</span><br><span class="line"><span class="keyword">elif</span> r &lt; <span class="number">7</span>:</span><br><span class="line">    print(<span class="string">'Small!'</span>)</span><br><span class="line"><span class="keyword">elif</span> r &gt; <span class="number">7</span>:</span><br><span class="line">    print(<span class="string">'Big!'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Big!
</code></pre><p>当然你还可以模拟投飞了的情况，即，最终的骰子数是 <code>0</code> 或者 <code>1</code>，即，<code>&lt; 2</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">r = random.randrange(<span class="number">0</span>, <span class="number">13</span>) <span class="comment"># 生成的随机数应该从 0 开始了；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> r == <span class="number">7</span>:</span><br><span class="line">    print(<span class="string">'Draw!'</span>)</span><br><span class="line"><span class="keyword">elif</span> r &gt;= <span class="number">2</span> <span class="keyword">and</span> r &lt; <span class="number">7</span>:      <span class="comment"># 如果这里直接写 elif r &lt; 7:，那么，else: 那一部分永远不会被执行……</span></span><br><span class="line">    print(<span class="string">'Small!'</span>)</span><br><span class="line"><span class="keyword">elif</span> r &gt; <span class="number">7</span>:</span><br><span class="line">    print(<span class="string">'Big!'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'Not valid!'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Small!
</code></pre><h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><p>Python 语言中，<code>for</code> 循环不使用其它语言中那样的计数器，取而代之的是 <code>range()</code> 这个我称其为 “整数等差数列生成器” 的函数。</p>
<p>用 C 语言写循环是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( a = <span class="number">0</span>; a &lt; <span class="number">10</span>; a = a + <span class="number">1</span> )&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"value of a: %d\n"</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用 Python 写同样的东西，是这样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    print(<span class="string">f'value of a: <span class="subst">&#123;a&#125;</span>'</span>) <span class="comment">#每次 a 的值都不同，从 0 递增至 9</span></span><br></pre></td></tr></table></figure>
<pre><code>value of a: 0
value of a: 1
value of a: 2
value of a: 3
value of a: 4
value of a: 5
value of a: 6
value of a: 7
value of a: 8
value of a: 9
</code></pre><h3 id="range-函数"><a href="#range-函数" class="headerlink" title="range() 函数"></a>range() 函数</h3><p><code>range()</code> 是个内建函数，<a href="https://docs.python.org/3/library/functions.html#func-range" target="_blank" rel="noopener">它的文档</a>是这样写的：</p>
<blockquote>
<p><strong>range</strong>(<em>stop</em>)</p>
<p><strong>range</strong>(<em>start, stop[, step]</em>)</p>
</blockquote>
<p>只有一个参数的时候，这个参数被理解为 <code>stop</code>，生成一个从 <code>0</code> 开始，到 <code>stop - 1</code> 的整数数列。</p>
<p>这就解释了为什么有的时候我们会在 <code>for ... in range(...):</code> 这种循环内的语句块里进行计算的时候，经常会在变量之后写上 <code>+ 1</code>，因为我们 range(n) 的返回数列中不包含 <code>n</code>，但我们有时候却需要 <code>n</code>。<a href="Part.1.E.1.entrance.ipynb#plusone">点击这里返回看看第一章里提到的例子：所谓算法那一小节</a>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line">range(<span class="number">10</span>)</span><br><span class="line">list(range(<span class="number">10</span>)) <span class="comment"># 将 range(10) 转换成 list，以便清楚看到其内容。</span></span><br></pre></td></tr></table></figure>
<pre><code>range(0, 10)

[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre><p><code>start</code> 参数的默认值是 <code>0</code>。如需指定起点，那么得给 <code>range()</code> 传递两个参数，比如，<code>range(2, 13)</code>……</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(range(<span class="number">2</span>, <span class="number">13</span>))</span><br></pre></td></tr></table></figure>
<pre><code>[2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
</code></pre><p>第三个参数可选；<code>step</code>，步长，就相当于是 “等差数列” 当中的 “差”，默认值是 <code>1</code>。例如，<code>range(1, 10, 2)</code> 生成的是这样一个数列 <code>[1, 3, 5, 7, 9]</code>。所以，打印 <code>0 ～ 10</code> 之间的所有奇数，可以这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<pre><code>1
3
5
7
9
</code></pre><p>我们也可以生成负数的数列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(range(<span class="number">0</span>, <span class="number">-10</span>, <span class="number">-1</span>))</span><br></pre></td></tr></table></figure>
<pre><code>[0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
</code></pre><h3 id="Continue、Break-和-Pass"><a href="#Continue、Break-和-Pass" class="headerlink" title="Continue、Break 和 Pass"></a>Continue、Break 和 Pass</h3><p>在循环的过程中，还可以用 <code>continue</code> 和 <code>break</code> 控制流程走向，通常是在某条件判断发生的情况下 —— 正如你早就见过的那样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">100</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        print(n)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">        <span class="keyword">if</span> (n % i) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(n)</span><br></pre></td></tr></table></figure>
<p><code>continue</code> 语句将忽略其后的语句开始下次循环，而 <code>break</code> 语句将从此结束当前循环，开始执行循环之后的语句：</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/continue-break.png?raw=true" alt></p>
<p><code>for</code> 语句块还可以附加一个 <code>else</code> —— 这是 Python 的一个比较有个性的地方。附加在 <code>for</code> 结尾的 <code>else</code> 语句块，<em>在没有 <code>break</code> 发生的情况下会运行</em>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">100</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        print(n)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">        <span class="keyword">if</span> (n % i) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:               <span class="comment"># 下一行的 print(n) 事实上属于语句块 for i in range(2, n):</span></span><br><span class="line">        print(n)        <span class="comment"># 整个循环结束，都没有发生 break 的情况下，才执行一次 print(n)</span></span><br></pre></td></tr></table></figure>
<pre><code>2
3
5
7
11
13
17
19
23
29
31
37
41
43
47
53
59
61
67
71
73
79
83
89
97
</code></pre><p>试比较以下两段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">100</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        print(n)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">        <span class="keyword">if</span> (n % i) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    print(n)            <span class="comment"># 事实上相当于针对 range(2, 100) 中每个 n 都执行了一次 print(n)</span></span><br><span class="line">                        <span class="comment"># 这个 print(n) 属于语句块 for n in range(2, 100):</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">100</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        print(n)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">        <span class="keyword">if</span> (n % i) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        print(n)            <span class="comment"># 事实上相当于针对 range(2, n) 中每个 i 都执行了一次 print(n)</span></span><br></pre></td></tr></table></figure>
<pre><code>2
3
5
5
5
7
7
7
7
7
9
11
11
11
...
97
97
97
97
99
</code></pre><p><code>pass</code> 语句什么都不干：</p>
<p>再比如，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">someFunction</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p>
<p>又或者：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>换个角度去理解的话可能更清楚：<code>pass</code> 这个语句更多是给写程序的人用的。当你写程序的时候，你可以用 <code>pass</code> 占位，而后先写别的部分，过后再回来补充本来应该写在 <code>pass</code> 所在位置的那一段代码。</p>
<p>写嵌套的判断语句或循环语句的时候，最常用 <code>pass</code>，因为写嵌套挺费脑子的，一不小心就弄乱了。所以，经常需要先用 <code>pass</code> 占位，而后逐一突破。</p>
<h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h2><p>今天，在绝大多数编程语言中，都提供两种循环结构：</p>
<blockquote>
<ul>
<li>Collection-controlled loops（以集合为基础的循环）</li>
<li>Condition-controlled loops（以条件为基础的循环）</li>
</ul>
</blockquote>
<p>之前的 <code>for ... in ...</code> 就是 Collection-controlled loops；而在 Python 中提供的 Condition-controlled loops 是 <code>while</code> 循环。</p>
<p><code>while</code> 循环的格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> expression:</span><br><span class="line">    statements</span><br></pre></td></tr></table></figure>
<p>输出 1000 以内的斐波那契数列的程序如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">1000</span></span><br><span class="line">a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> a &lt; n:</span><br><span class="line">    print(a, end=<span class="string">' '</span>)</span><br><span class="line">    a, b = b, a+b</span><br><span class="line">print()</span><br></pre></td></tr></table></figure>
<pre><code>0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
</code></pre><p><code>for</code> 和 <code>while</code> 的区别在哪里？什么时候应该用哪个？</p>
<p><code>for</code> 更适合处理序列类型的数据（Sequence Type）的迭代，比如处理字符串中的每一个字符，比如把 <code>range()</code> 返回的数列当作某种序列类型的索引。</p>
<p><code>while</code> 更为灵活，因为它后面只需要接上一个逻辑表达式即可。</p>
<h2 id="一个投骰子赌大小的游戏"><a href="#一个投骰子赌大小的游戏" class="headerlink" title="一个投骰子赌大小的游戏"></a>一个投骰子赌大小的游戏</h2><p>虽然还不可能随心所欲写程序，但是，你现在具备了起码的 “阅读能力”。有了以上大概的介绍，你也许可以读懂一些代码了 —— 它们在你眼里再也不是天书了……</p>
<p>以下是一个让用户和程序玩掷骰子赌大小的程序。规则如下：</p>
<blockquote>
<ul>
<li>每次计算机随机生成一个 <code>2... 12</code> 之间的整数，用来模拟机器人投两个骰子的情况；</li>
<li>机器人和用户的起始资金都是 10 个硬币</li>
<li>要求用户猜大小：<ul>
<li>用户输入 <code>b</code> 代表 “大”；</li>
<li>用户输入 <code>s</code> 代表 “小”；</li>
<li>用户输入 <code>q</code> 代表 “退出”；</li>
</ul>
</li>
<li>用户的输入和随机产生的数字比较有以下几种情况：<ul>
<li>随机数小于 <code>7</code>，用户猜小，用户赢；</li>
<li>随机数小于 <code>7</code>，用户猜大，用户输；</li>
<li>随机数等于 <code>7</code>，用户无论猜大还是猜小，结局平，不输不赢；</li>
<li>随机数大于 <code>7</code>，用户猜小，用户输；</li>
<li>随机数大于 <code>7</code>，用户猜大，用户赢；</li>
</ul>
</li>
<li>游戏结束条件：<ul>
<li>机器人和用户，若任意一方硬币数量为 <code>0</code>，则游戏结束；</li>
<li>用户输入了 <code>q</code> 主动终止游戏。</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randrange</span><br><span class="line"></span><br><span class="line">coin_user, coin_bot = <span class="number">10</span>, <span class="number">10</span> <span class="comment"># 可以用一个赋值符号分别为多个变量赋值</span></span><br><span class="line">rounds_of_game = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bet</span><span class="params">(dice, wager)</span>:</span>    <span class="comment"># 接收两个参数，一个是骰子点数，另一个用户的输入</span></span><br><span class="line">    <span class="keyword">if</span> dice == <span class="number">7</span>:</span><br><span class="line">        print(<span class="string">f'The dice is <span class="subst">&#123;dice&#125;</span>;\nDRAW!\n'</span>) <span class="comment"># \n 是换行符号</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> dice &lt; <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">if</span> wager == <span class="string">'s'</span>:</span><br><span class="line">            print(<span class="string">f'The dice is <span class="subst">&#123;dice&#125;</span>;\nYou WIN!\n'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">f'The dice is <span class="subst">&#123;dice&#125;</span>;\nYou LOST!\n'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">elif</span> dice &gt; <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">if</span> wager == <span class="string">'s'</span>:</span><br><span class="line">            print(<span class="string">f'The dice is <span class="subst">&#123;dice&#125;</span>;\nYou LOST!\n'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">f'The dice is <span class="subst">&#123;dice&#125;</span>;\nYou WIN!\n'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:         <span class="comment">#  除 for 之外的另外一个循环语句</span></span><br><span class="line">    print(<span class="string">f'You: <span class="subst">&#123;coin_user&#125;</span>\t Bot: <span class="subst">&#123;coin_bot&#125;</span>'</span>)</span><br><span class="line">    dice = randrange(<span class="number">2</span>, <span class="number">13</span>)   <span class="comment"># 生成一个 2 到 12 的随机数</span></span><br><span class="line">    wager = input(<span class="string">"What's your bet? "</span>)</span><br><span class="line">    <span class="keyword">if</span> wager == <span class="string">'q'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">elif</span> wager <span class="keyword">in</span> <span class="string">'bs'</span>:  <span class="comment"># 只有当用户输入的是 b 或者 s 得时候，才 “掷骰子”……</span></span><br><span class="line">        result = bet(dice, wager)</span><br><span class="line">        coin_user += result    <span class="comment"># coin_user += result 相当于 coin_user = coin_user + result</span></span><br><span class="line">        coin_bot -= result</span><br><span class="line">        rounds_of_game += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> coin_user == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"Woops, you've LOST ALL, and game over!"</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">elif</span> coin_bot == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"Woops, the robot's LOST ALL, and game over!"</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">f"You've played <span class="subst">&#123;rounds_of_game&#125;</span> rounds.\n"</span>)</span><br><span class="line">print(<span class="string">f"You have <span class="subst">&#123;coin_user&#125;</span> coins now.\nBye!"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>有控制流，才能算得上是程序。</p>
<blockquote>
<ul>
<li>只处理一种情况，用 <code>if ...</code></li>
<li>处理 <code>True</code>/<code>False</code> 两种情况，用 <code>if ... else ...</code></li>
<li>处理多种情况，用 <code>if ... elif ... elif ... else ...</code></li>
<li>迭代有序数据类型，用 <code>for ... in ...</code>，如果需要处理没有 <code>break</code> 发生的情况，用 <code>for ... else ...</code></li>
<li>其它循环，用 <code>while ...</code></li>
<li>与循环相关的语句还有 <code>continue</code>、<code>break</code>、<code>pass</code></li>
<li>函数从控制流角度去看其实就是子程序</li>
</ul>
</blockquote>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数，实际上是可被调用的完整的程序。它具备输入、处理、输出的功能。又因为它经常在主程序里被调用，所以它总是更像是个子程序。</p>
<p>了解一个函数，无非是要了解它的两个方面：</p>
<blockquote>
<ul>
<li>它的<strong>输入</strong>是怎么构成的（都有哪些参数？如何指定？）；</li>
<li>以及它的<strong>输出</strong>是什么（返回值究竟是什么？）……</li>
</ul>
</blockquote>
<p>从这个角度看，牛，对人类来说就是个函数，它吃的是<em>草</em>，挤出来的是<em>奶</em>…… 开玩笑了。</p>
<p>在我们使用函数的过程中，我们常常<em>有意忽略</em>它的内部如何完成从输入到输出之间的<em>处理过程</em> —— 这就好像我们平日里用灯泡一样，大多数情况下，我们只要知道开关的使用方法就够了 —— 至于为什么按到这个方向上灯会亮，为什么按到另外一个方向上灯会灭，并不是我们作为用户必须关心的事情……</p>
<p>当然，如果你是设计开关的人就不一样了，你必须知道其中的运作原理；但是，最终，你还是希望你的用户用最简单方便的操作界面，而不是必须搞懂所有原理才能够使用你所设计的产品……</p>
<p>当我们用 Python 编程的时候，更多的情况下，我们只不过是在使用别人已经写好的函数，或者用更专业一点的词藻，叫做 “已完好封装的函数”。而我们所需要做的事情（所谓的 “学习使用函数”），其实只不过是 “通过阅读产品说明书了解如何使用产品” 而已，真的没多神秘……</p>
<p><strong>注意</strong></p>
<blockquote>
<p>这一章的核心目的，不是让你学会如何写函数；而是通过一些例子，让你大抵上学会 “<em>如何阅读官方文档中关于函数的使用说明</em>”。也请注意之前的那个词：“<em>大抵上</em>”，所以<strong>千万别怕自己最初的时候理解不全面</strong>。</p>
</blockquote>
<p>另外，这一章中用来举例的函数，全部来自于同一个官方文档页面，<a href="https://docs.python.org/3/library/functions.html" target="_blank" rel="noopener">Built-in Functions</a>：</p>
<blockquote>
<p><a href="https://docs.python.org/3/library/functions.html" target="_blank" rel="noopener">https://docs.python.org/3/library/functions.html</a></p>
</blockquote>
<h2 id="示例-print"><a href="#示例-print" class="headerlink" title="示例 print()"></a>示例 print()</h2><h3 id="基本的使用方法"><a href="#基本的使用方法" class="headerlink" title="基本的使用方法"></a>基本的使用方法</h3><p><code>print()</code> 是初学者最常遇到的函数 —— 姑且不说是不是最常用到的。</p>
<p>它最基本的作用就是把传递给它的值输出到屏幕上，如果不给它任何参数，那么它就输出一个空行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'line 1st'</span>)</span><br><span class="line">print(<span class="string">'line 2nd'</span>)</span><br><span class="line">print()</span><br><span class="line">print(<span class="string">'line 4th'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>line 1st
line 2nd

line 4th
</code></pre><p>你也可以向它传递多个参数，参数之间用 <code>,</code> 分开，它就会把那些值逐个输出到屏幕，每个值之间默认用空格分开。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'Hello,'</span>, <span class="string">'jack'</span>, <span class="string">'mike'</span>, <span class="string">'...'</span>, <span class="string">'and all you guys!'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Hello, jack mike ... and all you guys!
</code></pre><p>当我们想把变量或者表达式的值插入字符串中的时候，可以用 f-string：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">'Ann'</span></span><br><span class="line">age = <span class="string">'22'</span></span><br><span class="line">print(<span class="string">f'<span class="subst">&#123;name&#125;</span> is <span class="subst">&#123;age&#125;</span> years old.'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Ann is 22 years old.
</code></pre><p>但这并不是 <code>print()</code> 这个函数的功能，这实际上是 <a href="https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting" target="_blank" rel="noopener"><code>f-string</code></a> 的功能，<code>f-string</code> 中用花括号 <code>{}</code> 括起来的部分是表达式，最终转换成字符串的时候，那些表达式的值（而不是变量或者表达式本身）会被插入相应的位置……</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">'Ann'</span></span><br><span class="line">age = <span class="string">'22'</span></span><br><span class="line"><span class="string">f'<span class="subst">&#123;name&#125;</span> is <span class="subst">&#123;age&#125;</span> years old.'</span></span><br></pre></td></tr></table></figure>
<pre><code>&apos;Ann is 22 years old.&apos;
</code></pre><p>所以，<code>print(f&#39;{name} is {age} years old.&#39;)</code> 这一句中，函数 <code>print()</code> 完成的还是它最基本的功能：给它什么，它就把什么输出到屏幕上。</p>
<h3 id="print-的官方文档说明"><a href="#print-的官方文档说明" class="headerlink" title="print() 的官方文档说明"></a>print() 的官方文档说明</h3><p>以下，是 print() 这个函数的<a href="https://docs.python.org/3/library/functions.html#print" target="_blank" rel="noopener">官方文档</a>：</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/doc-print.png?raw=true" alt></p>
<p>最必须读懂的部分，就是这一行：</p>
<blockquote>
<p><code>print(*object, sep=&#39; &#39;, end=&#39;\n&#39;, file=sys.stdout, flush=False)</code> <a href="#fn1" name="fn1b"><sup>[1]</sup></a></p>
</blockquote>
<p>先只注意那些有着 <code>=</code> 的参数，<code>sep=&#39; &#39;</code>、<code>end=&#39;\n&#39;</code>、<code>file=sys.stdout</code>，和 <code>flush=False</code>。</p>
<p>这其中，先关注这三个 <code>sep=&#39; &#39;</code>、<code>end=&#39;\n&#39;</code>、<code>file=sys.stdout</code>：</p>
<blockquote>
<ul>
<li><code>sep=&#39; &#39;</code>：接收多个参数之后，输出时，分隔符号默认为空格，<code>&#39; &#39;</code>；</li>
<li><code>end=&#39;\n&#39;</code>：输出行的末尾默认是换行符号 <code>&#39;\n&#39;</code>；</li>
<li><code>file=sys.stdout</code>：默认的输出对象是 <code>sys.stdout</code>（即，用户正在使用的屏幕）……</li>
</ul>
</blockquote>
<p>也就是说，这个函数中有若干个具有默认值的参数，即便我们在调用这个函数的时候，就算没有指定它们，它们也存在于此。</p>
<p>即，当我们调用 <code>print(&#39;Hello&#39;, &#39;world!&#39;)</code> 的时候，相当于我们调用的是 <code>print(&#39;Hello&#39;, &#39;world!&#39;, sep=&#39; &#39;, end=&#39;\n&#39;, file=sys.stdout, flush=False)</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys                                  <span class="comment"># 如果没有这一行，代码会报错</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'Hello'</span>, <span class="string">'world!'</span>)                    <span class="comment"># 下一行的输出和这一行相同</span></span><br><span class="line">print(<span class="string">'Hello'</span>, <span class="string">'world!'</span>, sep=<span class="string">' '</span>, end=<span class="string">'\n'</span>, file=sys.stdout, flush=<span class="literal">False</span>)</span><br><span class="line">print(<span class="string">'Hello'</span>, <span class="string">'world!'</span>, sep=<span class="string">'-'</span>, end=<span class="string">'\t'</span>)</span><br><span class="line">print(<span class="string">'Hello'</span>, <span class="string">'world!'</span>, sep=<span class="string">'~'</span>)           <span class="comment"># 上一行的末尾是 \t，所以，这一行并没有换行显示</span></span><br><span class="line">print(<span class="string">'Hello'</span>, <span class="string">'world!'</span>, sep=<span class="string">'\n'</span>)          <span class="comment"># 参数之间用换行 \n 分隔</span></span><br></pre></td></tr></table></figure>
<pre><code>Hello world!
Hello world!
Hello-world!    Hello~world!
Hello
world!
</code></pre><p>很多人只看各种教材、教程，却从来不去翻阅官方文档 —— 到最后非常吃亏。只不过是多花一点点的功夫而已，看过之后，就会知道：原来 <code>print()</code> 这个函数是可以往文件里写数据的，只要指定 <code>file</code> 这个参数为一个已经打开的文件对象就可以了（真的有很多人完全不知道）……</p>
<p>另外，现在可以说清楚了：</p>
<blockquote>
<p><code>print()</code> 这个函数的返回值是 <code>None</code> —— 注意，它向屏幕输出的内容，与 <code>print()</code> 这个函数的返回值不是一回事。</p>
</blockquote>
<p>做为例子，看看 <code>print(print(1))</code> 这个语句 —— <code>print()</code> 这个函数被调用了两次，第一次是 <code>print(1)</code>，它向屏幕输出了一次，完整的输出值实际上是 <code>str(1) + &#39;\n&#39;</code>，而后返回一个值，<code>None</code>；而第二次调用 print()，这相当于是向屏幕输出这个 <code>None</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(print(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<pre><code>1
None
</code></pre><p>“<strong>看说明书</strong>” 就是这样，全都看了，真不一定全部看懂，但看总是比不看强，因为总是有能看懂的部分……</p>
<h2 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h2><p>在 Python 中，函数的参数，有两种：</p>
<blockquote>
<ul>
<li><strong>位置参数</strong>（Positional Arguments，在官方文档里常被缩写为 <em>arg</em>）</li>
<li><strong>关键字参数</strong>（Keyword Arguments，在官方文档里常被缩写为 <em>kwarg</em>）</li>
</ul>
</blockquote>
<p>在函数定义中，带有 <code>=</code> 的，即，已为其设定了默认值的参数，叫做 Keyword Arguments，其它的是 Positional Arguments。</p>
<p>在调用有 Keyword Arguments 的函数之时，如若不提供这些参数，那么参数在执行时，启用的是它在定义的时候为那些 Keyword Arguments 所设定的默认值；如若提供了这些参数的值，那么参数在执行的时候，启用的是接收到的相应值。</p>
<p>比如，<code>sorted()</code> 函数，它的定义如下：</p>
<blockquote>
<p><code>sorted(iterable, *, key=None, reverse=False)</code></p>
</blockquote>
<p>现在先只关注它的 Keyword Arguments，<code>reverse</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line">sorted(<span class="string">'abdc'</span>)</span><br><span class="line">sorted(<span class="string">'abdc'</span>, reverse=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<pre><code>[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]
[&apos;d&apos;, &apos;c&apos;, &apos;b&apos;, &apos;a&apos;]
</code></pre><h2 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h2><p>位置参数，顾名思义，是 “由位置决定其值的参数”。拿 <code>divmod()</code> 为例，它的<a href="https://docs.python.org/3/library/functions.html#divmod" target="_blank" rel="noopener">官方文档</a>是这样写的：</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/doc-divmod.png?raw=true" alt></p>
<p>它接收且必须接收两个参数。</p>
<blockquote>
<ul>
<li>当你调用这个函数的时候，括号里写的第一个参数，是被除数，第二个参数是除数 —— 此为该函数的输入；</li>
<li>而它的返回值，是一个元组（Tuple，至于这是什么东西，后面讲清楚），其中包括两个值，第一个是商，第二个是余 —— 此为该函数的输出。</li>
</ul>
</blockquote>
<p>作为 “这个函数的用户”，你不能（事实上也没必要）调换这两个参数的意义。因为，根据定义，被传递的值的意义就是由参数的位置决定的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line">divmod(<span class="number">11</span>, <span class="number">3</span>)</span><br><span class="line">a, b = divmod(<span class="number">11</span>, <span class="number">3</span>)</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line"></span><br><span class="line">divmod(<span class="number">3</span>, <span class="number">11</span>)</span><br><span class="line">a, b = divmod(<span class="number">3</span>, <span class="number">11</span>)</span><br><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure>
<pre><code>(3, 2)
3
2
(0, 3)
0
3
</code></pre><h2 id="可选位置参数"><a href="#可选位置参数" class="headerlink" title="可选位置参数"></a>可选位置参数</h2><p>有些函数，如 <code>pow()</code>，有<strong>可选的位置参数</strong>（Optional Positional Arguments）。</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/doc-pow.png?raw=true" alt></p>
<p>于是，<code>pow()</code> 有两种用法，各有不同的结果：</p>
<blockquote>
<ul>
<li><code>pow(x, y)</code> —— 返回值是 <code>x ** y</code></li>
<li><code>pow(x, y, z)</code> —— 返回值是 <code>x ** y % z</code></li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line">pow(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">pow(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<pre><code>8
0
</code></pre><p>注意 <code>pow()</code> 函数定义部分中，圆括号内的方括号 <code>[, z]</code> —— 这是非常严谨的标注，如果没有 <code>z</code>，那么那个逗号 <code>,</code> 就是没必要的。</p>
<p>看看 <code>exec()</code> 的官方文档（先别管这个函数干嘛用的），注意函数定义中的两个嵌套的方括号：</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/doc-exec.png?raw=true" alt></p>
<p>这些方括号的意思是说：</p>
<blockquote>
<ul>
<li>没在方括号里的 <code>object</code> 是不可或缺的参数，调用时必须提供；</li>
<li>可以有第二个参数，第二个参数会被接收为 <code>globals</code>；</li>
<li>在有第二个参数的情况下，第三个参数会被接收为 <code>locals</code>；</li>
<li><em>但是，你没办法在不指定 <code>globals</code> 这个位置参数的情况下指定 <code>locals</code>……</em></li>
</ul>
</blockquote>
<h2 id="可接收很多值的位置参数"><a href="#可接收很多值的位置参数" class="headerlink" title="可接收很多值的位置参数"></a>可接收很多值的位置参数</h2><p>再回头看看 <code>print()</code>，它的第一个位置参数，<code>object</code> 前面是有个星号的：<code>*object, ...</code>。</p>
<p>对函数的用户来说，这说明，这个位置可以接收很多个参数（或者说，这个位置可以接收一个列表或者元组）。</p>
<p>再仔细看看 <code>print()</code>，它只有一个位置参数：</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/doc-print-def.png?raw=true" alt></p>
<p>因为位置决定了值的定义，一般来说，一个函数里最多只有一个这种可以接收很多值的位置参数 —— 否则如何获知谁是谁呢？</p>
<p>如果与此同时，还有若干个位置参数，那么，<em>能够接收很多值的位置参数</em>只能放置最后，就好像 <code>max()</code> 函数那样：</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/doc-max.png?raw=true" alt></p>
<h2 id="Class-也是函数"><a href="#Class-也是函数" class="headerlink" title="Class 也是函数"></a>Class 也是函数</h2><p>虽然你现在还不一定知道 Class 究竟是什么，但在阅读官方文档的时候，遇到一些内建函数前面写着 Class，比如 <code>Class bool([x])</code>，千万别奇怪，因为 Class 本质上来看就是一种特殊类型的函数，也就是说，它也是函数：</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/doc-class.png?raw=true" alt></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line">bool()</span><br><span class="line">bool(<span class="number">3.1415926</span>)</span><br><span class="line">bool(<span class="number">-3.1415926</span>)</span><br><span class="line">bool(<span class="number">1</span> == <span class="number">2</span>)</span><br><span class="line">bool(<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<pre><code>False
True
True
False
False
</code></pre><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>本章需要（大致）了解的重点如下，其实很简单：</p>
<blockquote>
<ul>
<li>你可以把函数当作一个产品，而你自己是这个产品的用户；</li>
<li>既然你是产品的用户，你要养成好习惯，一定要亲自阅读产品说明书；</li>
<li>调用函数的时候，注意<em>可选位置参数的使用方法</em>和<em>关键字参数的默认值</em>；</li>
<li>函数定义部分，注意两个符号就行了，<code>[]</code> 和 <code>=</code>；</li>
<li>所有的函数都有返回值，即便它内部不指定返回值，也有一个默认返回值：<code>None</code>；</li>
<li>另外，一定要耐心阅读该函数在使用的时候需要注意什么 —— 产品说明书的主要作用就在这里……</li>
</ul>
</blockquote>
<p>知道这些就很好了！</p>
<p>这就好像你拿着一张地图，不可能一下子掌握其中所有的细节，但花几分钟搞清楚 “图例”（Legend）部分总是可以的，知道什么样的线标示的是公交车，什么样的线标示的是地铁，什么样的线标示的是桥梁，然后知道上北下南左西右东 —— 这之后，就可以开始慢慢研究地图了……</p>
<p>为了学会使用 Python，你以后最常访问的页面一定是这个：</p>
<blockquote>
<ul>
<li><p><a href="https://docs.python.org/3/library/index.html" target="_blank" rel="noopener">https://docs.python.org/3/library/index.html</a></p>
<p>而最早反复阅读查询的页面肯定是其中的这两个：</p>
<ul>
<li><a href="https://docs.python.org/3/library/functions.html" target="_blank" rel="noopener">https://docs.python.org/3/library/functions.html</a></li>
<li><a href="https://docs.python.org/3/library/stdtypes.html" target="_blank" rel="noopener">https://docs.python.org/3/library/stdtypes.html</a></li>
</ul>
</li>
</ul>
</blockquote>
<p>对了，还有就是，在这一章之后，你已经基本上 “<strong>精通</strong>” 了 <code>print()</code> 这个函数的用法。</p>
<hr>
<p><strong>脚注</strong></p>
<p>（2019.02.14）<a name="fn1">[1]</a>：<code>print()</code> 函数的<a href="https://docs.python.org/3/library/functions.html#print" target="_blank" rel="noopener">官方文档</a>里，<code>sep=&#39;&#39;</code> 肯定是 <code>sep=&#39; &#39;</code> 的笔误 —— 可以用以下代码验证：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'a'</span>, <span class="string">'b'</span>, sep=<span class="string">''</span>)</span><br><span class="line">print(<span class="string">'a'</span>, <span class="string">'b'</span>)</span><br></pre></td></tr></table></figure>
<p>（2019.03.16）有读者提醒：<a href="https://github.com/selfteaching/the-craft-of-selfteaching/issues/111" target="_blank" rel="noopener">https://github.com/selfteaching/the-craft-of-selfteaching/issues/111</a></p>
<blockquote>
<p>而现在（2019.03.16）复制粘贴文档中的 <code>sep=&#39; &#39;</code>，会发现是有空格的。</p>
<p>这是改了么？</p>
</blockquote>
<p>我回去查看了一下 2019.02.13 我提交的 bug track：<a href="https://bugs.python.org/issue35986" target="_blank" rel="noopener">https://bugs.python.org/issue35986</a>，结论是 “人家没问题，是我自己的浏览器字体设置有问题”……</p>
<p>然而，我决定将这段文字保留在此书里，以便人们看到 “平日里软件维护是什么样的” —— 作为一个实例放在这里，很好。</p>
<p><a href="#fn1b"><small>↑Back to Content↑</small></a></p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>在任何一本编程书籍之中，关于字符串的内容总是很长 —— 就好像每本英语语法书中，关于动词的内容总是占全部内容的至少三分之二。这也没什么办法，因为处理字符串是计算机程序中最普遍的需求 —— 因为程序的主要功能就是完成人机交互，人们所用的就是字符串而不是二进制数字。</p>
<p>在计算机里，所有的东西最终都要被转换成数值。又由于计算机靠的是电路，所以，最终只能处理 <code>1</code> 和 <code>0</code>，于是，最基本的数值是二进制；于是，连整数、浮点数字，都要最终转换成二进制数值。这就是为什么在所有编程语言中 <code>1.1 + 2.2</code> 并不是你所想象的 <code>3.3</code> 的原因。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.1</span> + <span class="number">2.2</span></span><br></pre></td></tr></table></figure>
<pre><code>3.3000000000000003
</code></pre><p>因为最终所有的值都要转换成二进制 —— 这时候，小数的精度就有损耗，多次浮点数字转换成二进制相互运算之后再从二进制转换为十进制之后返回的结果，精度损耗就更大了。因此，在计算机上，浮点数字的精度总有极限。有兴趣进一步可以看看<a href="https://docs.python.org/3/library/decimal.html" target="_blank" rel="noopener">关于 decimal 模块的文档</a>。</p>
<p>字符串也一样。一个字符串由 0 个字符或者多个字符构成，它最终也要被转换成数值，再进一步被转换成二进制数值。空字符串的值是 <code>None</code>，即便是这个 <code>None</code> —— 也最终还是要被转换成二进制的 <code>0</code>。</p>
<h2 id="字符码表的转换"><a href="#字符码表的转换" class="headerlink" title="字符码表的转换"></a>字符码表的转换</h2><p>很久以前，计算机的中央处理器最多只能够处理 8 位二进制数值，所以，那时候的计算机只能处理 256 个字符，即，2<sup>8</sup> 个字符。那个时候计算机所使用的码表叫 ASCII。现在计算机的中央处理器，大多是 64 位的，所以可以使用 2<sup>64</sup> 容量的码表，叫做 <a href="https://zh.wikipedia.org/wiki/Unicode" target="_blank" rel="noopener">Unicode</a>。随着多年的收集，2018 年 6 月 5 日公布的 <code>11.0.0</code> 版本已经包含了 13 万个字符 —— 突破 10 万字符是在 2005 年<a href="#fn1" name="fn1b"><sup>[1]</sup></a>。</p>
<p>把单个字符转换成码值的函数是 <code>ord()</code>，它只接收单个字符，否则会报错；它返回该字符的  unicode 编码。与 <code>ord()</code> 相对的函数是 <code>chr()</code>，它接收且只接收一个整数作为参数，而后返回相应的字符。<code>ord()</code> 接收多个字符的话会报错。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line">ord(<span class="string">'a'</span>)</span><br><span class="line">chr(<span class="number">122</span>)</span><br><span class="line"></span><br><span class="line">ord(<span class="string">'氅'</span>)  <span class="comment"># 完了，汉字也有你不认识的吧？</span></span><br><span class="line">chr(<span class="number">25354</span>) <span class="comment"># 这个字估计你也不认识……</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ord('Python') # 这一句会报错</span></span><br></pre></td></tr></table></figure>
<pre><code>97
&apos;z&apos;
27653
&apos;挊&apos;
</code></pre><h2 id="字符串的标示"><a href="#字符串的标示" class="headerlink" title="字符串的标示"></a>字符串的标示</h2><p>标示一个字符串，有 4 种方式，用单引号、用双引号，用三个单引号或者三个双引号：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Simple is better than complex.'</span> <span class="comment"># 用单引号</span></span><br></pre></td></tr></table></figure>
<pre><code>&apos;Simple is better than complex.&apos;
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Simple is better than complex."</span> <span class="comment"># 用双引号</span></span><br></pre></td></tr></table></figure>
<pre><code>&apos;Simple is better than complex.&apos;
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用三个单引号。注意输出结果中的 \n</span></span><br><span class="line"><span class="comment"># 这个字符串，看起来是两行，保存在内存或者变量之中的时候，</span></span><br><span class="line"><span class="comment"># 是一整串，其中的换行是用 \n 表示的。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Simple is better than complex.</span></span><br><span class="line"><span class="string">Complex is better than complicated.</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<pre><code>&apos;\nSimple is better than complex.\nComplex is better than complicated.\n&apos;
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用三个双引号。注意输出结果中的 \n</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Simple is better than complex.</span></span><br><span class="line"><span class="string">Complex is better than complicated.</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<pre><code>&apos;\nSimple is better than complex.\nComplex is better than complicated.\n&apos;
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">print(</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Simple is better than complex.</span></span><br><span class="line"><span class="string">Complex is better than complicated.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">) <span class="comment">#用 print() 输出的时候，\n 就是不可见字符，字符串本身如下：</span></span><br><span class="line"><span class="comment"># '\nSimple is better than complex.\nComplex is better than complicated.\n'</span></span><br><span class="line"><span class="comment"># 其中的 \n 被打印出来的时候显示成换行</span></span><br></pre></td></tr></table></figure>
<pre><code>Simple is better than complex.
Complex is better than complicated.
</code></pre><h2 id="字符串与数值之间的转换"><a href="#字符串与数值之间的转换" class="headerlink" title="字符串与数值之间的转换"></a>字符串与数值之间的转换</h2><p>由数字构成的字符串，可以被转换成数值，转换整数用 <code>int()</code>，转换浮点数字用 <code>float()</code>。</p>
<p>与之相对，用 <code>str()</code>，可以将数值转换成字符串类型。</p>
<p>注意，int() 在接收字符串为参数的时候，只能做整数转换。下面代码最后一行会报错：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line">int(<span class="string">'3'</span>)</span><br><span class="line">float(<span class="string">'3'</span>)</span><br><span class="line">str(<span class="number">3.1415926</span>)</span><br><span class="line"><span class="comment"># int('3.1415926') # 这一行会报错</span></span><br></pre></td></tr></table></figure>
<pre><code>3
3.0
&apos;3.1415926&apos;
</code></pre><p><code>input()</code> 这个内建函数的功能是接收用户的键盘输入，而后将其作为字符串返回。它可以接收一个字符串作为参数，在接收用户键盘输入之前，会把这个参数输出到屏幕，作为给用户的提示语。这个参数是可选参数，直接写 <code>input()</code>，即，没有提供参数，那么它在要求用户输入的时候，就没有提示语。</p>
<p>以下代码会报错，因为 <code>age &lt; 18</code> 不是合法的逻辑表达式，因为 <code>age</code> 是由 <code>input()</code> 传递过来的字符串；于是，它不是数字，那么它不可以与数字比较……</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">age = input(<span class="string">'Please tell me your age: '</span>)</span><br><span class="line"><span class="keyword">if</span> age &lt; <span class="number">18</span>:</span><br><span class="line">    print(<span class="string">'I can not sell you drinks...'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'Have a nice drink!'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Please tell me your age:  19

---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

&lt;ipython-input-9-0573fe379e83&gt; in &lt;module&gt;
      1 age = input(&apos;Please tell me your age: &apos;)
----&gt; 2 if age &lt; 18:
      3     print(&apos;I can not sell you drinks...&apos;)
      4 else:
      5     print(&apos;Have a nice drink!&apos;)

TypeError: &apos;&lt;&apos; not supported between instances of &apos;str&apos; and &apos;int&apos;
</code></pre><p>要改成这样才可能行：<br>为什么是可能行而不是一定行？如果用户 <code>input</code> 键盘输入的是 <code>eighteen</code> 或者 <code>十八</code> 等，依然会导致 <code>int()</code> 失败并得到 <code>ValueError</code> 的报错。用户输入的不可控，可能会导致千奇百怪的报错。但在这里，我们先简化处理，在引导语中加入一个正确的示例并默认用户会按引导语正确输入。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">age = int(input(<span class="string">'''Please tell me your age:</span></span><br><span class="line"><span class="string"> an int number , e.g: 22</span></span><br><span class="line"><span class="string">'''</span>))</span><br><span class="line"><span class="keyword">if</span> age &lt; <span class="number">18</span>:</span><br><span class="line">    print(<span class="string">'I can not sell you drinks...'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'Have a nice drink!'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Please tell me your age:  19
Have a nice drink!
</code></pre><p><strong>注意</strong>：如果你用来浏览当前 <code>.ipynb</code> 文件的是那个桌面 App <a href="https://nteract.io/" target="_blank" rel="noopener">Nteract</a>，它目前不支持 input() 这个函数的调用……</p>
<h2 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h2><p>有一个重要的字符，叫做 “转义符”，<code>\</code>，也有的地方把它称为 “脱字符”，因为它的英文原文是 <em>Escaping Character</em>。它本身不被当作字符，你要想在字符串里含有这个字符，得这样写 <code>\\</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\\'</span></span><br></pre></td></tr></table></figure>
<pre><code>&apos;\\&apos;
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\'</span></span><br></pre></td></tr></table></figure>
<pre><code>  File &quot;&lt;ipython-input-10-d44a383620ab&gt;&quot;, line 1
    &apos;\&apos;
       ^
SyntaxError: EOL while scanning string literal
</code></pre><p>上面这一行报错信息是 <code>SyntaxError: EOL while scanning string literal</code>。这是因为 <code>\&#39;</code> 表示的是单引号字符 <code>&#39;</code>（Literal）—— 是可被输出到屏幕的 <code>&#39;</code>，而不是用来标示字符串的那个 <code>&#39;</code> —— 别急，无论哪个初学者第一次读到前面的句子都觉得有点莫名其妙…… —— 于是，Python 编译器扫描这个 “字符串” 的时候，还没找到标示字符串末尾的另外一个 <code>&#39;</code> 的时候就读到了 <code>EOL</code>（End Of Line）。</p>
<p>如果你想输出这么个字符串，<code>He said, it&#39;s fine.</code>，如果用双引号扩起来 <code>&quot;</code> 倒没啥问题，但是如果用单引号扩起来就麻烦了，因为编译器会把 <code>it</code> 后面的那个单引号 <code>&#39;</code> 当作字符串结尾。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'He said, it'</span>s fine.<span class="string">'</span></span><br></pre></td></tr></table></figure>
<pre><code>  File &quot;&lt;ipython-input-11-2bcf2ca6dd95&gt;&quot;, line 1
    &apos;He said, it&apos;s fine.&apos;
                 ^
SyntaxError: invalid syntax
</code></pre><p>于是你就得用转义符 <code>\</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要么你这么写：</span></span><br><span class="line"><span class="string">'He said, it\'s fine.'</span></span><br><span class="line"><span class="comment"># 要么你这么写：</span></span><br><span class="line"><span class="string">"He said, it's fine."</span></span><br><span class="line"><span class="comment"># 要么，不管用单引号还是双引号标示字符串，都习惯于用 \' 和 \" 书写属于字符串内部的引号……</span></span><br><span class="line"><span class="string">"He said, it\'s fine."</span></span><br></pre></td></tr></table></figure>
<pre><code>&quot;He said, it&apos;s fine.&quot;
&quot;He said, it&apos;s fine.&quot;
&quot;He said, it&apos;s fine.&quot;
</code></pre><p>转义符号 <code>\</code> 的另外两个常用形式是和 <code>t</code>、<code>n</code> 连起来用，<code>\t</code> 代表制表符（就是用 TAB <code>⇥</code> 键敲出来的东西），<code>\n</code> 代表换行符（就是用 Enter <code>⏎</code> 敲出来的东西）。</p>
<p>由于历史原因，Linux/Mac/Windows 操作系统中，换行符号的使用各不相同。Unix 类操作系统（包括现在的 MacOS），用的是 <code>\n</code>；Windows 用的是 <code>\r\n</code>，早期苹果公司的 Macintosh 用的是 <code>\r</code>（参见 <a href="https://en.wikipedia.org/wiki/Newline" target="_blank" rel="noopener">Wikipedia: Newline</a>）。</p>
<p>所以，一个字符串，有两种形式，<strong>raw</strong> 和 <strong>presentation</strong>，在后者中，<code>\t</code> 被转换成制表符，<code>\n</code> 被转换成换行。</p>
<p>在写程序的过程中，我们在代码中写的是 <em>raw</em>，而例如当我们调用 <code>print()</code> 将字符串输出到屏幕上时，是 <em>presentation</em>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"He said, it\'s fine."</span> <span class="comment"># raw</span></span><br><span class="line">print(s)                   <span class="comment"># presentation</span></span><br></pre></td></tr></table></figure>
<pre><code>He said, it&apos;s fine.
</code></pre><p>以后有时间去看看这两个内建函数，能了解更多细节：</p>
<blockquote>
<ul>
<li><strong>ascii</strong>(<em>object</em>) <a href="https://docs.python.org/3/library/functions.html#ascii" target="_blank" rel="noopener">https://docs.python.org/3/library/functions.html#ascii</a></li>
<li><strong>repr</strong>(<em>object</em>) <a href="https://docs.python.org/3/library/functions.html#repr" target="_blank" rel="noopener">https://docs.python.org/3/library/functions.html#repr</a></li>
</ul>
</blockquote>
<h2 id="字符串的操作符"><a href="#字符串的操作符" class="headerlink" title="字符串的操作符"></a>字符串的操作符</h2><p>字符串可以用空格 <code>&#39; &#39;</code> 或者 <code>+</code> 拼接：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Hey!'</span> + <span class="string">' '</span> + <span class="string">'You!'</span> <span class="comment"># 使用操作符 +</span></span><br></pre></td></tr></table></figure>
<pre><code>&apos;Hey! You!&apos;
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Hey!'</span> <span class="string">'You!'</span> <span class="comment"># 空格与 + 的作用是相同的。</span></span><br></pre></td></tr></table></figure>
<pre><code>&apos;Hey!You!&apos;
</code></pre><p>字符串还可以与整数倍操作符 <code>*</code> 操作，<code>&#39;Ha&#39; * 3</code> 的意思是说，把字符串 <code>&#39;Ha&#39;</code> 复制三遍：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Ha'</span> * <span class="number">3</span></span><br></pre></td></tr></table></figure>
<pre><code>&apos;HaHaHa&apos;
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'3.14'</span> * <span class="number">3</span></span><br></pre></td></tr></table></figure>
<pre><code>&apos;3.143.143.14&apos;
</code></pre><p>字符串还可以用 <code>in</code> 和 <code>not in</code> 操作符 —— 看看某个字符或者字符串是否被包含在某个字符串中，返回的是布尔值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'o'</span> <span class="keyword">in</span> <span class="string">'Hey, You!'</span></span><br></pre></td></tr></table></figure>
<pre><code>True
</code></pre><h2 id="字符串的索引"><a href="#字符串的索引" class="headerlink" title="字符串的索引"></a>字符串的索引</h2><p>字符串是由一系列的字符构成的。在 Python 当中，有一个容器（Container）的概念，这个概念前面提到过，后面还会深入讲解。现在需要知道的是，字符串是容器的一种；容器可分为两种，有序的和无序的 —— 字符串属于<strong>有序容器</strong>。</p>
<p>字符串里的每个字符，对应着一个从 <code>0</code> 开始的索引。比较有趣的是，索引可以是负数：</p>
<table>
<thead>
<tr>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>P</td>
<td>y</td>
<td>t</td>
<td>h</td>
<td>o</td>
<td>n</td>
</tr>
<tr>
<td>-6</td>
<td>-5</td>
<td>-4</td>
<td>-3</td>
<td>-2</td>
<td>-1</td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'Python'</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">    print(s.index(char), char)</span><br></pre></td></tr></table></figure>
<pre><code>0 P
1 y
2 t
3 h
4 o
5 n
</code></pre><p>对于有序容器中的元素 —— 字符串就是字符的有序容器 —— 由于它们是有索引的，所以我们可以根据索引提取容器中的值，你可以把 <code>[]</code> 当作是有序容器的操作符之一，我们姑且将其称为 “<em>索引操作符</em>”。注意以下代码第 3 行中，<code>s</code> 后面的 <code>[]</code>，以及里面的变量 <code>i</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'Python'</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">    print(s[i])</span><br><span class="line"></span><br><span class="line"><span class="comment">#上面的代码仅是为了演示索引操作符的使用，更简洁的写法是：</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<pre><code>P
y
t
h
o
n
</code></pre><p>我们可以使用<em>索引操作符</em>根据<em>索引**</em>提取*<em>字符串这个</em>有序容器<em>中的</em>一个或多个元素*，即，其中的字符或字符串。这个 “提取” 的动作有个专门的术语，叫做 “Slicing”（切片）。索引操作符 <code>[]</code> 中可以有一个、两个或者三个整数参数，如果有两个参数，需要用 <code>:</code> 隔开。它最终可以写成以下 4 种形式：</p>
<blockquote>
<ul>
<li><code>s[index]</code> —— 返回索引值为 <code>index</code> 的那个字符</li>
<li><code>s[start:]</code> —— 返回从索引值为 <code>start</code> 开始一直到字符串末尾的所有字符</li>
<li><code>s[start:stop]</code> —— 返回从索引值为 <code>start</code> 开始一直到索引值为 <code>stop</code> 的那个字符<em>之前</em>的所有字符</li>
<li><code>s[:stop]</code> —— 返回从字符串开头一直到索引值为 <code>stop</code> 的那个字符<em>之前</em>的所有字符</li>
<li><code>s[start:stop:step]</code> —— 返回从索引值为 <code>start</code> 开始一直到索引值为 <code>stop</code> 的那个字符<em>之前</em>的，以 <code>step</code> 为步长提取的所有字符</li>
</ul>
</blockquote>
<p>提醒：无论是 <code>range(1,2)</code>，或者 <code>random.randrange(100, 1000)</code> 又或者 <code>s[start:stop]</code> 都有一个相似的规律，包含左侧的 <code>1</code>, <code>100</code>, <code>start</code>，不包含右侧的 <code>2</code>, <code>1000</code>, <code>stop</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">'Python'</span></span><br><span class="line">s[<span class="number">1</span>]</span><br><span class="line">s[<span class="number">2</span>:]</span><br><span class="line">s[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">s[:<span class="number">5</span>]</span><br><span class="line">s[<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<pre><code>&apos;y&apos;
&apos;thon&apos;
&apos;tho&apos;
&apos;Pytho&apos;
&apos;yh&apos;
</code></pre><h2 id="处理字符串的内建函数"><a href="#处理字符串的内建函数" class="headerlink" title="处理字符串的内建函数"></a>处理字符串的内建函数</h2><p><a href="https://docs.python.org/3/library/functions.html#slice" target="_blank" rel="noopener">Python 内建函数</a>中，把字符串当做处理对象的有：<code>ord()</code>、<code>input()</code>、<code>int()</code>、<code>float()</code>、<code>len()</code>、<code>print()</code>。再次注意，<code>ord()</code> 只接收单个字符为参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line">ord(<span class="string">'\n'</span>)</span><br><span class="line">ord(<span class="string">'\t'</span>)</span><br><span class="line">ord(<span class="string">'\r'</span>)</span><br><span class="line">chr(<span class="number">65</span>) <span class="comment"># 与 ord() 相对的函数</span></span><br><span class="line">s = input(<span class="string">'请照抄一遍这个数字 3.14: '</span>)</span><br><span class="line">int(<span class="string">'3'</span>)</span><br><span class="line"><span class="comment"># int(s) 这一句会报错…… 所以暂时注释掉了</span></span><br><span class="line">float(s) * <span class="number">9</span></span><br><span class="line">len(s)</span><br><span class="line">print(s*<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<pre><code>10
9
13
&apos;A&apos;
请照抄一遍这个数字 3.14:  3.14
3
28.26
4
3.143.143.14
</code></pre><h2 id="处理字符串的-Method"><a href="#处理字符串的-Method" class="headerlink" title="处理字符串的 Method"></a>处理字符串的 Method</h2><p>在 Python 中，字符串是一个<strong>对象</strong> —— 更准确地讲，是 str 类（<code>Class str</code>）的对象。</p>
<p>第一部分尚未读完的你，暂时不用了解对象究竟是什么；只需要知道的是，一个对象的内部有很多函数…… 这些写在对象内部的函数，有个专门的名称，类的<strong>方法</strong>（Method）。问题在于，在讲解编程的内容里，“方法” 这个词（比如，处理数值的<em>方法</em>是……）随处可见；所以，<strong>为了避免歧义</strong>，以后的文字里，提到 “类的方法” 的时候，直接用 <strong>Method</strong> 这个英文单词……</p>
<p>字符串有很多可以调用的 Methods。以下介绍的 <code>str</code> Methods，在官方文档 “<a href="https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str" target="_blank" rel="noopener">Text Sequence Type</a>“ 中都可以找到。</p>
<p>调用 str 类的 Methods 是使用 <code>.</code> 这个符号，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Python'</span>.upper()</span><br></pre></td></tr></table></figure>
<h3 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h3><p>转换字符串大小写的是 <code>str.upper()</code>、<code>str.lower()</code> 和 <code>str.swapcase()</code>，以及 <code>str.casefold()</code>；另外，还有专门针对行首字母大写的 <code>str.capitalize()</code> 和针对每个词的首字母大写的 <code>str.title()</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line"><span class="string">'Now is better than never.'</span>.upper()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 Python 命令行工具之中，单个下划线，是个特殊变量；</span></span><br><span class="line"><span class="comment"># 保存着最近的语句或者表达式的结果</span></span><br><span class="line"><span class="comment"># 上一个 Cell 执行过后，_ 中保存着 'NOW IS BETTER THAN NEVER.'</span></span><br><span class="line"></span><br><span class="line">_.lower()</span><br></pre></td></tr></table></figure>
<pre><code>&apos;NOW IS BETTER THAN NEVER.&apos;

&apos;now is better than never.&apos;
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># casefold() 也是转换成小写，但它能处理更多欧洲语言字符</span></span><br><span class="line"></span><br><span class="line"><span class="string">'ß'</span>.casefold()           <span class="comment"># 德语字符中，大写 ß 的小写形式是 ss</span></span><br><span class="line">len(<span class="string">'ß'</span>.casefold())</span><br><span class="line"><span class="string">'ß'</span>.lower()              <span class="comment"># lower() 对这类字符无能为力……</span></span><br><span class="line">len(<span class="string">'ß'</span>.lower())</span><br><span class="line"><span class="comment"># casefold</span></span><br><span class="line"><span class="string">'\u0132'</span>                <span class="comment"># Ĳ 这个字符的 Unicode 编码</span></span><br><span class="line"><span class="string">'\u0132'</span>.casefold()</span><br><span class="line"><span class="string">'\u0132'</span>.lower()        <span class="comment"># 对这个字符来说，lower() 和 casefold 的效果一样</span></span><br><span class="line">len(<span class="string">'\u0132'</span>.casefold())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是一篇有用的文章：</span></span><br><span class="line"><span class="comment"># Truths programmers should know about case</span></span><br><span class="line"><span class="comment"># https://www.b-list.org/weblog/2018/nov/26/case/</span></span><br></pre></td></tr></table></figure>
<pre><code>&apos;ss&apos;
2
&apos;ß&apos;
1
&apos;Ĳ&apos;
&apos;ĳ&apos;
&apos;ĳ&apos;
1
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">'Now is better than never.'</span></span><br><span class="line">s.capitalize() <span class="comment"># 句首字母大写</span></span><br><span class="line">s.title() <span class="comment"># 每个单词首字母大写</span></span><br></pre></td></tr></table></figure>
<pre><code>&apos;Now is better than never.&apos;
&apos;Now Is Better Than Never.&apos;
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'Now is better than never.'</span></span><br><span class="line">s.swapcase() <span class="comment"># 逐个字符更替大小写</span></span><br><span class="line">s.title()</span><br><span class="line">s.title().swapcase()</span><br></pre></td></tr></table></figure>
<pre><code>&apos;nOW IS BETTER THAN NEVER.&apos;
&apos;Now Is Better Than Never.&apos;
&apos;nOW iS bETTER tHAN nEVER.&apos;
</code></pre><p>另外，还有个 <code>str.encode()</code> 在处理非英文字符串（比如中文）的时候，经常会用到：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># str.encode(encoding="utf-8", errors="strict")</span></span><br><span class="line"><span class="comment"># 关于更多可能的 encoding list, 请参阅：</span></span><br><span class="line"><span class="comment"># https://docs.python.org/3/library/codecs.html#standard-encodings</span></span><br><span class="line">s = <span class="string">'简单优于复杂。'</span></span><br><span class="line">s.encode()</span><br></pre></td></tr></table></figure>
<pre><code>b&apos;\xe7\xae\x80\xe5\x8d\x95\xe4\xbc\x98\xe4\xba\x8e\xe5\xa4\x8d\xe6\x9d\x82\xe3\x80\x82&apos;
</code></pre><h3 id="搜索与替换"><a href="#搜索与替换" class="headerlink" title="搜索与替换"></a>搜索与替换</h3><p>让我们从 <code>str.count()</code> 这个搜寻子字符串出现次数的 Method（即，<code>str</code> 这个 <code>Class</code> 中定义的函数）开始。</p>
<p>官方文档是这么写的：</p>
<blockquote>
<p><code>str.count(sub[,start[,end]])</code></p>
</blockquote>
<p>下面的函数说明加了默认值，以便初次阅读更容易理解：</p>
<blockquote>
<p><code>str.count(sub [,start=0[, end=len(str)]])</code></p>
</blockquote>
<p>这里的方括号 <code>[]</code> 表示该参数可选；方括号里再次嵌套了一个方括号，这个意思是说，在这个可选参数 <code>start</code> 出现的情况下，还可以再有一个可选参数 <code>end</code>；</p>
<p>而 <code>=</code> 表示该参数有个默认值。上述这段说明如果你感到熟悉的话，说明前面的内容确实阅读到位了…… 与大量 “前置引用” 相伴随的是知识点的重复出现。</p>
<blockquote>
<ul>
<li>只给定 <code>sub</code> 一个参数的话，于是从第一个字符开始搜索到字符串结束；</li>
<li>如果，随后给定了一个可选参数的话，那么它是 <code>start</code>，于是从 <code>start</code> 开始，搜索到字符串结束；</li>
<li>如果 <code>start</code> 之后还有参数的话，那么它是 <code>end</code>；于是从 <code>start</code> 开始，搜索到 <code>end - 1</code> 结束（即不包含索引值为 <code>end</code> 的那个字符）。</li>
</ul>
<p>返回值为字符串中 <code>sub</code> 出现的次数。</p>
</blockquote>
<p>注意：字符串中第一个字符的索引值是 <code>0</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">"""Simple is better than complex.</span></span><br><span class="line"><span class="string">Complex is better than complicated."""</span></span><br><span class="line">s.lower().count(<span class="string">'mp'</span>)</span><br><span class="line">s.lower().count(<span class="string">'mp'</span>, <span class="number">10</span>)</span><br><span class="line">s.lower().count(<span class="string">'mp'</span>, <span class="number">10</span>, <span class="number">30</span>)</span><br></pre></td></tr></table></figure>
<pre><code>4
3
1
</code></pre><p>以下是 <code>str</code> 的搜索与替换的 Methods：<code>str.find()</code>, <code>str.rfind()</code>, <code>str.index()</code> 的示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># str.find(sub[, start[, end]])</span></span><br><span class="line">print(<span class="string">'Example of str.find():'</span>)</span><br><span class="line">s = <span class="string">"""Simple is better than complex.</span></span><br><span class="line"><span class="string">Complex is better than complicated."""</span></span><br><span class="line">s.lower().find(<span class="string">'mpl'</span>)</span><br><span class="line">s.lower().find(<span class="string">'mpl'</span>, <span class="number">10</span>)</span><br><span class="line">s.lower().find(<span class="string">'mpl'</span>, <span class="number">10</span>, <span class="number">20</span>) <span class="comment"># 没有找到就返回 -1</span></span><br><span class="line">print()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Example of str.rfind():'</span>)</span><br><span class="line"><span class="comment"># str.rfind(sub[, start[, end]])</span></span><br><span class="line"><span class="comment"># rfind() 返回最后 sub 出现的那次的位置；find()是最早的那次</span></span><br><span class="line">s.lower().rfind(<span class="string">'mpl'</span>)</span><br><span class="line">s.lower().rfind(<span class="string">'mpl'</span>, <span class="number">10</span>)</span><br><span class="line">s.lower().rfind(<span class="string">'mpl'</span>, <span class="number">10</span>, <span class="number">20</span>) <span class="comment"># 没有找到就返回 -1</span></span><br><span class="line">print()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Example of str.index():'</span>)</span><br><span class="line"><span class="comment"># str.index(sub[, start[, end]])</span></span><br><span class="line"><span class="comment"># 作用与 find() 相同，但如果没找到的话，会触发 ValueError 异常</span></span><br><span class="line"><span class="comment"># https://docs.python.org/3/library/exceptions.html#ValueError</span></span><br><span class="line">s.lower().index(<span class="string">'mpl'</span>)</span><br><span class="line"><span class="comment"># str.rindex(sub[, start[, end]])</span></span><br><span class="line"><span class="comment"># 作用与 rfind() 相同，但如果没找到的话，会触发 ValueError 异常</span></span><br><span class="line">s.lower().rindex(<span class="string">'mpl'</span>)</span><br><span class="line">print()</span><br></pre></td></tr></table></figure>
<pre><code>Example of str.find():

2
24
-1
Example of str.rfind():
56
56
-1
Example of str.index():
2
56
</code></pre><p><code>str.startswith()</code> 和 <code>str.endswith()</code> 是用来判断一个<em>字符串</em>是否以某个<em>子字符串</em>起始或者结束的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"""Simple is better than complex.</span></span><br><span class="line"><span class="string">Complex is better than complicated."""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># str.startswith(prefix[, start[, end]])</span></span><br><span class="line">print(<span class="string">"s.lower().startswith('S'):"</span>, \</span><br><span class="line">      s.lower().startswith(<span class="string">'S'</span>))</span><br><span class="line">print(<span class="string">"s.lower().startswith('b', 10):"</span>, \</span><br><span class="line">      s.lower().startswith(<span class="string">'b'</span>, <span class="number">10</span>))</span><br><span class="line">print(<span class="string">"s.lower().startswith('e', 11, 20):"</span>, \</span><br><span class="line">      s.lower().startswith(<span class="string">'e'</span>, <span class="number">11</span>, <span class="number">20</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># str.endswith(suffix[, start[, end]])</span></span><br><span class="line">print(<span class="string">"s.lower().endswith('.'):"</span>, \</span><br><span class="line">      s.lower().endswith(<span class="string">'.'</span>))</span><br><span class="line">print(<span class="string">"s.lower().endswith('.', 10):"</span>, \</span><br><span class="line">      s.lower().endswith(<span class="string">'.'</span>, <span class="number">10</span>))</span><br><span class="line">print(<span class="string">"s.lower().endswith('.', 10, 20):"</span>, \</span><br><span class="line">      s.lower().endswith(<span class="string">'.'</span>, <span class="number">10</span>, <span class="number">20</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 好玩：中国人一不小心就会把这两个函数写成或者记成</span></span><br><span class="line"><span class="comment"># startwith() 和 endwith() —— 少写一个 s!</span></span><br></pre></td></tr></table></figure>
<pre><code>s.lower().startswith(&apos;S&apos;): False
s.lower().startswith(&apos;b&apos;, 10): True
s.lower().startswith(&apos;e&apos;, 11, 20): True
s.lower().endswith(&apos;.&apos;): True
s.lower().endswith(&apos;.&apos;, 10): True
s.lower().endswith(&apos;.&apos;, 10, 20): False
</code></pre><p>为了找到位置而进行搜索之前，你可能经常需要事先确认需要寻找的字符串在寻找对象中是否存在，这个时候，可以用 <code>in</code> 操作符：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"""Simple is better than complex.</span></span><br><span class="line"><span class="string">Complex is better than complicated."""</span></span><br><span class="line"><span class="comment"># 如果你只想知道 “有没有”，而无需知道 “在哪里”，那么可以用：</span></span><br><span class="line">print(<span class="string">'mpl'</span> <span class="keyword">in</span> s)</span><br></pre></td></tr></table></figure>
<pre><code>True
</code></pre><p>能搜索，就应该能替换 —— <code>str.replace()</code>，它的函数说明是这样的：</p>
<blockquote>
<p><code>str.replace(old, new[, count])</code></p>
</blockquote>
<p>用 <code>new</code> 替换 <code>old</code>，替换 <code>count</code> 个实例（实例：exmpale，每次处理的对象就是实例，即具体的操作对象），其中，<code>count</code> 这个参数是可选的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"""Simple is better than complex.</span></span><br><span class="line"><span class="string">Complex is better than complicated."""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># str.startswith(prefix[, start[, end]])</span></span><br><span class="line">print(<span class="string">"s.lower().replace('mp', '[ ]', 2):\n"</span>)</span><br><span class="line">print(s.lower().replace(<span class="string">'mp'</span>, <span class="string">'[ ]'</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<pre><code>s.lower().replace(&apos;mp&apos;, &apos;[ ]&apos;, 2):

si[ ]le is better than co[ ]lex.
complex is better than complicated.
</code></pre><p>另外，还有个专门替换 TAB（<code>\t</code>）的 Method，</p>
<blockquote>
<p><code>str.expandtabs( tabsize=8)</code></p>
</blockquote>
<p>它的作用非常简单，就是把字符串中的 TAB（<code>\t</code>）替换成空格，默认是替换成 <code>8</code> 个空格 —— 当然你也可以指定究竟替换成几个空格</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># str.expandtabs(tabsize=8)</span></span><br><span class="line">s = <span class="string">"Special\tcases\taren't\tspecial\tenough\tto\tbreak\tthe\trules."</span></span><br><span class="line">s.expandtabs()</span><br><span class="line">s.expandtabs(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<pre><code>&quot;Special cases   aren&apos;t  special enough  to      break   the     rules.&quot;
&quot;Special cases aren&apos;t  special enough  to  break the rules.&quot;
</code></pre><h3 id="去除子字符"><a href="#去除子字符" class="headerlink" title="去除子字符"></a>去除子字符</h3><blockquote>
<p><code>str.strip([chars])</code></p>
</blockquote>
<p>它最常用的场景是去除一个字符串首尾的所有空白，包括空格、TAB、换行符等等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">"\r \t Simple is better than complex.    \t \n"</span></span><br><span class="line">s</span><br><span class="line">s.strip()</span><br></pre></td></tr></table></figure>
<pre><code>&apos;\r \t Simple is better than complex.    \t \n&apos;

&apos;Simple is better than complex.&apos;
</code></pre><p>但是，如果给定了一个字符串作为参数，那么参数字符串中的所有字母都会被当做需要从首尾剔除的对象，直到新的首尾字母不包含在参数中，就会停止剔除：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">"Simple is better than complex."</span></span><br><span class="line">s</span><br><span class="line">s.strip(<span class="string">'Six.p'</span>)    <span class="comment"># p 全部处理完之后，p 并不在首尾，所以原字符串中的 p 字母不受影响；</span></span><br><span class="line">s.strip(<span class="string">'pSix.mle'</span>) <span class="comment"># 这一次，首尾的 p 被处理了…… 参数中的字符顺序对结果没有影响，换成 Sipx.mle 也一样……</span></span><br></pre></td></tr></table></figure>
<pre><code>&apos;Simple is better than complex.&apos;
&apos;mple is better than comple&apos;
&apos; is better than co&apos;
</code></pre><p>还可以只对左侧处理，<code>str.lstrip()</code> 或者只对右侧处理，<code>str.rstrip()</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># str.lstrip([chars])</span></span><br><span class="line">s = <span class="string">"Simple is better than complex."</span></span><br><span class="line">s</span><br><span class="line">s.lstrip(<span class="string">'Six.p'</span>)    <span class="comment"># p 全部处理完之后，p 并不在首部，所以原字符串中的 p 字母不受影响；</span></span><br><span class="line">s.lstrip(<span class="string">'pSix.mle'</span>) <span class="comment"># 这一次，首部的 p 被处理了…… 参数中的字符顺序对结果没有影响，换成 Sipx.mle 也一样……</span></span><br></pre></td></tr></table></figure>
<pre><code>&apos;Simple is better than complex.&apos;
&apos;mple is better than complex.&apos;
&apos; is better than complex.&apos;
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># str.rstrip([chars])</span></span><br><span class="line">s = <span class="string">"Simple is better than complex."</span></span><br><span class="line">s</span><br><span class="line">s.rstrip(<span class="string">'Six.p'</span>)    <span class="comment"># p 全部处理完之后，p 并不在尾部，所以原字符串中的 p 字母不受影响；</span></span><br><span class="line">s.rstrip(<span class="string">'pSix.mle'</span>) <span class="comment"># 这一次，尾部的 p 被处理了…… 参数中的字符顺序对结果没有影响，换成 Sipx.mle 也一样……</span></span><br></pre></td></tr></table></figure>
<pre><code>&apos;Simple is better than complex.&apos;
&apos;Simple is better than comple&apos;
&apos;Simple is better than co&apos;
</code></pre><h3 id="拆分字符串"><a href="#拆分字符串" class="headerlink" title="拆分字符串"></a>拆分字符串</h3><p>在计算机里，数据一般保存在文件之中。计算机擅长处理的是 “格式化数据”，即，这些数据按照一定的格式排列 —— 电子表格、数据库，就是一种保存方式。Microsoft 的 Excel 和 Apple 的 Numbers，都可以将表格导出为 <code>.csv</code> 文件。这是文本文件，里面的每一行可能由多个数据构成，数据之间用 <code>,</code>（或 <code>;</code>、<code>\t</code>）分隔：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Name,Age,Location</span><br><span class="line">John,18,New York</span><br><span class="line">Mike,22,San Francisco</span><br><span class="line">Janny,25,Miami</span><br><span class="line">Sunny,21,Shanghai</span><br></pre></td></tr></table></figure>
<p>文本文件中的这样一段内容，被读进来之后，保存在某个变量，那么，那个变量的值长成这个样子：</p>
<blockquote>
<p><code>&#39;Name,Age,Location\nJohn,18,New York\nMike,22,San Francisco\nJanny,25,Miami\nSunny,21,Shanghai&#39;</code></p>
</blockquote>
<p>我们可以对这样的字符串进行很多操作，最常用的比如，<code>str.splitlines()</code>, <code>str.split()</code>；还有个 <code>str.partition()</code>，有空的人可以去<a href="https://docs.python.org/3/library/stdtypes.html#str.partition" target="_blank" rel="noopener">官方文档</a>看看说明。</p>
<p><code>str.splitlines()</code> 返回的是个列表（List）—— 这又是一个前面曾简要提起过，但会在后面的章节才能详细讲解的概念 —— 由被拆分的每一行作为其中的元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">"""Name,Age,Location</span></span><br><span class="line"><span class="string">John,18,New York</span></span><br><span class="line"><span class="string">Mike,22,San Francisco</span></span><br><span class="line"><span class="string">Janny,25,Miami</span></span><br><span class="line"><span class="string">Sunny,21,Shanghai"""</span></span><br><span class="line"></span><br><span class="line">s                 <span class="comment"># s 被打印出来的时候，\n 都被转换成换行了</span></span><br><span class="line">s.splitlines()    <span class="comment"># 注意输出结果前后的方括号，[]，表示这个返回结果是一个 List</span></span><br></pre></td></tr></table></figure>
<pre><code>&apos;Name,Age,Location\nJohn,18,New York\nMike,22,San Francisco\nJanny,25,Miami\nSunny,21,Shanghai&apos;

[&apos;Name,Age,Location&apos;,
 &apos;John,18,New York&apos;,
 &apos;Mike,22,San Francisco&apos;,
 &apos;Janny,25,Miami&apos;,
 &apos;Sunny,21,Shanghai&apos;]
</code></pre><p><code>str.split()</code>, 是将一个字符串，根据分隔符进行拆分：</p>
<blockquote>
<p><code>str.split(sep=None, maxsplit=-1)</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">"""Name,Age,Location</span></span><br><span class="line"><span class="string">John,18,New York</span></span><br><span class="line"><span class="string">Mike,22,San Francisco</span></span><br><span class="line"><span class="string">Janny,25,Miami</span></span><br><span class="line"><span class="string">Sunny,21,Shanghai"""</span></span><br><span class="line"></span><br><span class="line">r = s.splitlines()[<span class="number">2</span>]   <span class="comment"># 取出返回列表中索引值为 2 的那一行</span></span><br><span class="line">r</span><br><span class="line">r.split()               <span class="comment"># 如果没有给 str.split() 传递参数，那么默认为用 None 分割（各种空白，比如，\t 和 \r 都被当作 None）</span></span><br><span class="line">r.split(sep=<span class="string">','</span>)</span><br><span class="line">r.split(<span class="string">','</span>)            <span class="comment"># 上一行可以这样写。</span></span><br><span class="line"></span><br><span class="line">r.split(sep=<span class="string">','</span>, maxsplit=<span class="number">1</span>)  <span class="comment"># 第二个参数指定拆分几次</span></span><br><span class="line"><span class="comment"># r.split(sep=',', 1)         # 上一行不能这样写。</span></span><br><span class="line">r.split(sep=<span class="string">','</span>, maxsplit=<span class="number">0</span>)  <span class="comment"># 0 次，即不拆分</span></span><br><span class="line">r.split(sep=<span class="string">','</span>, maxsplit=<span class="number">-1</span>) <span class="comment"># 默认值是 -1，拆分全部</span></span><br></pre></td></tr></table></figure>
<pre><code>&apos;Mike,22,San Francisco&apos;
[&apos;Mike,22,San&apos;, &apos;Francisco&apos;]
[&apos;Mike&apos;, &apos;22&apos;, &apos;San Francisco&apos;]
[&apos;Mike&apos;, &apos;22&apos;, &apos;San Francisco&apos;]
[&apos;Mike&apos;, &apos;22,San Francisco&apos;]
[&apos;Mike,22,San Francisco&apos;]
[&apos;Mike&apos;, &apos;22&apos;, &apos;San Francisco&apos;]
</code></pre><h3 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h3><p><code>str.join()</code> 是将来非常常用的，它的官方文档说明却很少：</p>
<blockquote>
<p><code>str.join(_iterable_)</code></p>
<p>Return a string which is the concatenation of the strings in iterable. A <em><a href="https://docs.python.org/3/library/exceptions.html#TypeError" target="_blank" rel="noopener"><code>TypeError</code></a></em> will be raised if there are any non-string values in iterable, including <a href="https://docs.python.org/3/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> objects. The separator between elements is the string providing this method.</p>
</blockquote>
<p>它接收的参数是 <a href="https://docs.python.org/3/glossary.html#term-iterable" target="_blank" rel="noopener">iterable</a>，虽然你还没办法知道 iterable 究竟是什么，但这个 Method 的例子貌似可以看懂（可能你会产生 “那个方括号究竟是干什么的” 的疑问，也可能对前面章节提到的列表还有印象）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">''</span></span><br><span class="line">t = [<span class="string">'P'</span>, <span class="string">'y'</span>, <span class="string">'t'</span>, <span class="string">'h'</span>, <span class="string">'o'</span>, <span class="string">'n'</span>]</span><br><span class="line">s.join(t)</span><br></pre></td></tr></table></figure>
<pre><code>&apos;Python&apos;
</code></pre><h3 id="字符串排版"><a href="#字符串排版" class="headerlink" title="字符串排版"></a>字符串排版</h3><p>将字符串居中放置 —— 前提是设定整行的长度：</p>
<blockquote>
<p><code>str.center(width[, fillchar])</code></p>
</blockquote>
<p>注意，第 2 个参数可选，且只接收单个字符 —— <code>char</code> 是 <em>character</em> 的缩写。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">'Sparse is better than dense!'</span></span><br><span class="line">s.title().center(<span class="number">60</span>)</span><br><span class="line">s.title().center(<span class="number">60</span>, <span class="string">'='</span>)</span><br><span class="line">s.title().center(<span class="number">10</span>) <span class="comment"># 如果宽度参数小于字符串长度，则返回原字符串</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">'Sparse is better than dense!'</span></span><br><span class="line">s.title().rjust(<span class="number">60</span>)</span><br><span class="line">s.title().rjust(<span class="number">60</span>, <span class="string">'.'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>&apos;                Sparse Is Better Than Dense!                &apos;

&apos;================Sparse Is Better Than Dense!================&apos;

&apos;Sparse Is Better Than Dense!&apos;

&apos;                                Sparse Is Better Than Dense!&apos;

&apos;................................Sparse Is Better Than Dense!&apos;
</code></pre><p>将字符串靠左或者靠右对齐放置：</p>
<blockquote>
<ul>
<li><code>str.ljust(width)</code></li>
<li><code>str.rjust(width)</code></li>
</ul>
</blockquote>
<p>另外，还有个字符串 Method 是，将字符串转换成左侧由 <code>0</code> 填充的指定长度字符串。例如，这在批量生成文件名的时候就很有用……</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">    filename = str(i).zfill(<span class="number">3</span>) + <span class="string">'.mp3'</span></span><br><span class="line">    print(filename)</span><br></pre></td></tr></table></figure>
<pre><code>001.mp3
002.mp3
003.mp3
004.mp3
005.mp3
006.mp3
007.mp3
008.mp3
009.mp3
010.mp3
</code></pre><h3 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h3><p>所谓对字符串进行格式化，指的是将特定变量插入字符串特定位置的过程。常用的 Methods 有两个，一个是 <code>str.format()</code>，另外一个是 <code>f-string</code>。</p>
<h4 id="使用-str-format"><a href="#使用-str-format" class="headerlink" title="使用 str.format()"></a>使用 str.format()</h4><p>这个 Method 的<a href="https://docs.python.org/3/library/stdtypes.html#str.format" target="_blank" rel="noopener">官方文档说明</a>，你现在是死活看不懂的：</p>
<blockquote>
<p><code>str.format(*args, **kwargs)</code></p>
</blockquote>
<p>参数前面多了个 <code>*</code>…… 没办法，现在讲不清楚，讲了也听不明白…… 先跳过，以下只关注怎么用这个 Method。</p>
<p>它的作用是：</p>
<blockquote>
<ul>
<li>在一个字符串中，插入一个或者多个占位符 —— 用大括号 <code>{}</code> 括起来；</li>
<li>而后将 <code>str.format()</code> 相应的参数，依次插入占位符中；</li>
</ul>
</blockquote>
<p>占位符中可以使用由零开始的索引。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line">name = <span class="string">'John'</span></span><br><span class="line">age = <span class="number">25</span></span><br><span class="line"><span class="string">'&#123;&#125; is &#123;&#125; years old.'</span>.format(name, age)</span><br><span class="line"><span class="comment"># 不写占位符索引就默认每个占位符的索引从第一个开始是 0, 1, 2 ...（占位符数量 - 1)</span></span><br><span class="line"><span class="comment"># '&#123;&#125; &#123;&#125;'.format(a, b) 和 '&#123;0&#125; &#123;1&#125;'.format(a, b) 是一样的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># '&#123;0&#125; is &#123;2&#125; years old.'.format(name, age)</span></span><br><span class="line"><span class="comment"># 这一句会报错，因为 2 超出实际参数索引极限</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个连续使用的大括号，不被认为是占位符；且只打印出一对大括号</span></span><br><span class="line"><span class="string">"Are you &#123;0&#125;? :-&#123;&#123;+&#125;&#125;"</span>.format(name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># "%s is %d years old." % (name, age)</span></span><br><span class="line"><span class="comment"># 上一行这是兼容 Python 2 的老式写法，可以从此忽略……</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># str.fomrat() 里可以直接写表达式……</span></span><br><span class="line"><span class="string">'&#123;&#125; is a grown up? &#123;&#125;'</span>.format(name, age &gt;= <span class="number">18</span>)</span><br></pre></td></tr></table></figure>
<pre><code>&apos;John is 25 years old.&apos;
&apos;Are you John? :-{+}&apos;
&apos;John is a grown up? True&apos;
</code></pre><h4 id="使用-f-string"><a href="#使用-f-string" class="headerlink" title="使用 f-string"></a>使用 f-string</h4><p><em>f-string</em> 与 <code>str.format()</code> 的功用差不多，只是写法简洁一些 —— 在字符串标示之前加上一个字母 <code>f</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># https://docs.python.org/3/library/stdtypes.html#printf-style-bytes-formatting</span></span><br><span class="line"><span class="comment"># f-string</span></span><br><span class="line"></span><br><span class="line">name = <span class="string">'John'</span></span><br><span class="line">age = <span class="number">25</span></span><br><span class="line"><span class="string">f'<span class="subst">&#123;name&#125;</span> is <span class="subst">&#123;age&#125;</span> years old.'</span></span><br><span class="line"><span class="string">f'<span class="subst">&#123;name&#125;</span> is a grown up? <span class="subst">&#123;age &gt;= <span class="number">18</span>&#125;</span>'</span></span><br></pre></td></tr></table></figure>
<pre><code>&apos;John is 25 years old.&apos;
&apos;John is a grown up? True&apos;
</code></pre><p>只不过，str.format() 的用法中，索引顺序可以任意指定，于是相对更为灵活，下面的例子只是为了演示参数位置可以任意指定：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">'John'</span></span><br><span class="line">age = <span class="number">25</span></span><br><span class="line"><span class="string">'&#123;1&#125; is &#123;0&#125; years old.'</span>.format(name, age)</span><br></pre></td></tr></table></figure>
<pre><code>&apos;25 is John years old.&apos;
</code></pre><h3 id="字符串属性"><a href="#字符串属性" class="headerlink" title="字符串属性"></a>字符串属性</h3><p>字符串还有一系列的 Methods，返回的是布尔值，用来判断字符串的构成属性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># str.isalnum()</span></span><br><span class="line">print(<span class="string">"'1234567890'.isalnum():"</span>, \</span><br><span class="line">      <span class="string">'1234567890'</span>.isalnum()) <span class="comment"># '3.14'.isalnum() 返回的是 False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># str.isalpha()</span></span><br><span class="line">print(<span class="string">"'abcdefghij'.isalpha():"</span>, \</span><br><span class="line">      <span class="string">'abcdefghij'</span>.isalpha())</span><br><span class="line"></span><br><span class="line"><span class="comment"># str.isascii()</span></span><br><span class="line">print(<span class="string">"'山巅一寺一壶酒'.isascii():"</span>, \</span><br><span class="line">      <span class="string">'山巅一寺一壶酒'</span>.isascii())</span><br><span class="line"></span><br><span class="line"><span class="comment"># str.isdecimal()</span></span><br><span class="line">print(<span class="string">"'0.123456789'.isdecimal():"</span>, \</span><br><span class="line">      <span class="string">'0.1234567890'</span>.isdecimal())</span><br><span class="line"></span><br><span class="line"><span class="comment"># str.isdigit()</span></span><br><span class="line">print(<span class="string">"'0.123456789'.isdigit():"</span>, \</span><br><span class="line">      <span class="string">'0.1234567890'</span>.isdigit())       <span class="comment">#  注意，如果字符串是 identifier，返回值也是 False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># str.isnumeric()</span></span><br><span class="line">print(<span class="string">"'0.123456789'.isnumeric():"</span>, \</span><br><span class="line">      <span class="string">'0.1234567890'</span>.isnumeric())</span><br><span class="line"></span><br><span class="line"><span class="comment"># str.islower()</span></span><br><span class="line">print(<span class="string">"'Continue'.islower():"</span>, \</span><br><span class="line">      <span class="string">'Continue'</span>.islower())</span><br><span class="line"></span><br><span class="line"><span class="comment"># str.isupper()</span></span><br><span class="line">print(<span class="string">"'Simple Is Better Than Complex'.isupper():"</span>, \</span><br><span class="line">      <span class="string">'Simple Is Better Than Complex'</span>.isupper())</span><br><span class="line"></span><br><span class="line"><span class="comment"># str.istitle()</span></span><br><span class="line">print(<span class="string">"'Simple Is Better Than Complex'.istitle():"</span>, \</span><br><span class="line">      <span class="string">'Simple Is Better Than Complex'</span>.istitle())</span><br><span class="line"></span><br><span class="line"><span class="comment"># str.isprintable()</span></span><br><span class="line">print(<span class="string">"'\t'.isprintable():"</span>, \</span><br><span class="line">      <span class="string">'\t'</span>.isprintable())</span><br><span class="line"></span><br><span class="line"><span class="comment"># str.isspace()</span></span><br><span class="line">print(<span class="string">"'\t'.isspace():"</span>, \</span><br><span class="line">      <span class="string">'\t'</span>.isspace())</span><br><span class="line"></span><br><span class="line"><span class="comment"># str.isidentifier()</span></span><br><span class="line">print(<span class="string">"'for'.isidentifier():"</span>, \</span><br><span class="line">      <span class="string">'for'</span>.isidentifier())</span><br></pre></td></tr></table></figure>
<pre><code>&apos;1234567890&apos;.isalnum(): True
&apos;abcdefghij&apos;.isalpha(): True
&apos;山巅一寺一壶酒&apos;.isascii(): False
&apos;0.123456789&apos;.isdecimal(): False
&apos;0.123456789&apos;.isdigit(): False
&apos;0.123456789&apos;.isnumeric(): False
&apos;Continue&apos;.islower(): False
&apos;Simple Is Better Than Complex&apos;.isupper(): False
&apos;Simple Is Better Than Complex&apos;.istitle(): True
&apos;    &apos;.isprintable(): False
&apos;    &apos;.isspace(): True
&apos;for&apos;.isidentifier(): True
</code></pre><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>这一章节显得相当繁杂。然而，这一章和下一章（关于容器），都是 “用来锻炼自己耐心的好材料”……</p>
<p>不过，若是自己动手整理成一个表格，总结归纳一下这一章节的内容，你就会发现其实没多繁杂，总之就还是那点事，怎么处理字符串？用操作符、用内建函数，用 Methods。只不过，字符串的操作符和数值的操作符不一样 —— 类型不一样，操作符就当然不一样了么！—— 最不一样的地方是，字符串是有序容器的一种，所以，它有索引，所以可以根据索引提取…… 至于剩下的么，就是很常规的了，用函数处理，用 Methods 处理，只不过，Methods 相对多了一点而已。</p>
<p>整理成表格之后，就会发现想要全部记住其实并没多难……</p>
<blockquote>
<ul>
<li>为了表格在一屏中可以正确显示，本来应该规规矩矩写 <code>str.xxx</code>，但写成了 <code>s.xxx</code>……</li>
<li>另外，操作那一行，为了分类记忆方便，把 <code>len()</code> 和 <code>s.join()</code> 也放进去了……</li>
</ul>
</blockquote>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/string-concepts.png?raw=true" alt></p>
<p>“记住” 的方法并不是马上就只盯着表格看…… 正确方法是反复阅读这一章内容中的代码，并逐一运行，查看输出结果；还要顺手改改看看，多多体会。多次之后，再看着表格回忆知识点，直到牢记为止。</p>
<h2 id="为什么数值没有像字符串值这样详细论述？"><a href="#为什么数值没有像字符串值这样详细论述？" class="headerlink" title="为什么数值没有像字符串值这样详细论述？"></a>为什么数值没有像字符串值这样详细论述？</h2><p>上一章中，我们概括地讲了各种类型的值的运算。而后并没有继续深入讲解数字的运算，而是直接 “跳” 到了这一章关于字符串的内容。其实，只要一张表格和一个列表就足够了（因为之前零零散散都讲过）：</p>
<p>Python 针对数字常用的操作符和内建函数，按照<strong>优先级</strong>从低到高排列：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>操作</th>
<th>结果</th>
<th>官方文档链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>加</td>
<td><code>1 + 2</code></td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>减</td>
<td><code>2 - 1</code></td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>乘</td>
<td><code>3 * 5</code></td>
<td>15</td>
<td></td>
</tr>
<tr>
<td>除</td>
<td><code>6 / 2</code></td>
<td>3.0</td>
<td></td>
</tr>
<tr>
<td>商</td>
<td><code>7 // 3</code></td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>余</td>
<td><code>7 % 3</code></td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>负</td>
<td><code>-6</code></td>
<td>-6</td>
<td></td>
</tr>
<tr>
<td>正</td>
<td><code>+6</code></td>
<td>6</td>
<td></td>
</tr>
<tr>
<td>绝对值</td>
<td><code>abs(-1)</code></td>
<td>1</td>
<td><a href="https://docs.python.org/3/library/functions.html#abs" target="_blank" rel="noopener"><code>abs()</code></a></td>
</tr>
<tr>
<td>转换为整数</td>
<td><code>int(3.14)</code></td>
<td>3</td>
<td><a href="https://docs.python.org/3/library/functions.html#int" target="_blank" rel="noopener"><code>int()</code></a></td>
</tr>
<tr>
<td>转换为浮点数</td>
<td><code>float(3)</code></td>
<td>3.0</td>
<td><a href="https://docs.python.org/3/library/functions.html#float" target="_blank" rel="noopener"><code>float()</code></a></td>
</tr>
<tr>
<td>商余</td>
<td><code>divmod(7, 3)</code></td>
<td>2, 1</td>
<td><a href="https://docs.python.org/3/library/functions.html#divmod" target="_blank" rel="noopener"><code>divmod()</code></a></td>
</tr>
<tr>
<td>幂</td>
<td><code>pow(2, 10)</code></td>
<td>1024</td>
<td><a href="https://docs.python.org/3/library/functions.html#pow" target="_blank" rel="noopener"><code>pow()</code></a></td>
</tr>
<tr>
<td>幂</td>
<td><code>3 ** 2</code></td>
<td>9</td>
</tr>
</tbody>
</table>
<p>Python 用来处理数值的内建函数：</p>
<blockquote>
<ul>
<li><code>abs(n)</code> 函数返回参数 <code>n</code> 的<em>绝对值</em>；</li>
<li><code>int(n)</code> 用来将<em>浮点数字</em> <code>n</code> 转换成<em>整数</em>；</li>
<li><code>float(n)</code> 用来将<em>整数</em> <code>n</code> 转换成<em>浮点数字</em>；</li>
<li><code>divmod(n, m)</code> 用来计算  <code>n</code>  除以  <code>m</code>，返回两个整数，一个是<em>商</em>，另外一个是<em>余</em>；</li>
<li><code>pow(n, m)</code> 用来做乘方运算，返回 <code>n</code> 的 <code>m</code> <em>次方</em>；</li>
<li><code>round(n)</code> 返回离浮点数字 <code>n</code> 最近的那个<em>整数</em>。</li>
</ul>
</blockquote>
<p>Python 做更为复杂的数学计算的模块（Module）是 math module，参阅：</p>
<blockquote>
<p><a href="https://docs.python.org/3/library/math.html" target="_blank" rel="noopener">https://docs.python.org/3/library/math.html</a></p>
</blockquote>
<hr>
<p><strong>脚注</strong></p>
<p><a name="fn1">[1]</a>：请查阅 <a href="https://en.wikipedia.org/wiki/Unicode" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Unicode</a></p>
<p><a href="#fn1b"><small>↑Back to Content↑</small></a></p>
<h1 id="数据容器"><a href="#数据容器" class="headerlink" title="数据容器"></a>数据容器</h1><p>在 Python 中，有个<strong>数据容器</strong>（Container）的概念。</p>
<p>其中包括<strong>字符串</strong>、由 <code>range()</code> 函数生成的<strong>等差数列</strong>、<strong>列表</strong>（List）、<strong>元组</strong>（Tuple）、<strong>集合</strong>（Set）、<strong>字典</strong>（Dictionary）。</p>
<p>这些容器，各有各的用处。其中又分为<em>可变</em>容器（Mutable）和<em>不可变</em>容器（Immutable）。可变的有列表、集合、字典；不可变的有字符串、<code>range()</code> 生成的等差数列、元组。集合，又分为 <em>Set</em> 和 <em>Frozen Set</em>；其中，Set 是<em>可变的</em>，Frozen Set 是<em>不可变的</em>。</p>
<p>字符串、由 <code>range()</code> 函数生成的等差数列、列表、元组是<strong>有序类型</strong>（Sequence Type），而集合与字典是<em>无序</em>的。</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/python-containers-final.png?raw=true" alt></p>
<p>另外，集合没有<em>重合</em>元素。</p>
<h2 id="迭代（Iterate）"><a href="#迭代（Iterate）" class="headerlink" title="迭代（Iterate）"></a>迭代（Iterate）</h2><p>数据容器里的元素是可以被<strong>迭代的</strong>（Iterable），它们其中包含的元素，可以被逐个访问，以便被处理。</p>
<p>对于数据容器，有一个操作符，<code>in</code>，用来判断某个元素是否属于某个容器。</p>
<p>由于数据容器的可迭代性，再加上这个操作符 <code>in</code>，在 Python 语言里写循环格外容易且方便（以字符串这个字符的容器作为例子）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> <span class="string">'Python'</span>:</span><br><span class="line">  print(c)</span><br></pre></td></tr></table></figure>
<pre><code>P
y
t
h
o
n
</code></pre><p>在 Python 出现之前，想要完成这样一个访问字符串中的每一个字符的循环，大抵上应该是这样的（比如 C 语言）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Written in C</span><br><span class="line"><span class="keyword">char</span> *<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,<span class="built_in">string</span>);</span><br><span class="line"><span class="keyword">int</span> i=<span class="built_in">strlen</span>(<span class="built_in">string</span>);</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(k&lt;i)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%c"</span>, <span class="built_in">string</span>[k]);</span><br><span class="line">      k++;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p> 在 Python 中，简单的 for 循环，只需要指定一个次数就可以了，因为有 range() 这个函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">  print(i)</span><br></pre></td></tr></table></figure>
<pre><code>0
1
2
3
4
5
6
7
8
9
</code></pre><p>即便是用比 C 更为 “现代” 一点的 JavaScript，也大抵上应该是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，有时候我们也需要比较复杂的计数器，不过，Python 也不只有 <code>for</code> 循环，还有 <code>while</code> 循环，在必要的时候可以写复杂的计数器。</p>
<h2 id="列表（List）"><a href="#列表（List）" class="headerlink" title="列表（List）"></a>列表（List）</h2><p>列表和字符串一样，是个<em>有序类型</em>（Sequence Type）的容器，其中包含着有索引编号的元素。</p>
<p>列表中的元素可以是不同类型。不过，在解决现实问题的时候，我们总是倾向于创建由同一个类型的数据构成的列表。遇到由不同类型数据构成的列表，我们更可能做的是想办法把不同类型的数据分门别类地拆分出来，整理清楚 —— 这种工作甚至有个专门的名称与之关联：<em>数据清洗</em>。</p>
<h3 id="列表的生成"><a href="#列表的生成" class="headerlink" title="列表的生成"></a>列表的生成</h3><p>生成一个列表，有以下几种方式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a_list = []</span><br><span class="line">b_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">list(), <span class="keyword">or</span> list(iterable)            <span class="comment"># 这是 Type Casting</span></span><br><span class="line">[(expression <span class="keyword">with</span> x) <span class="keyword">for</span> x <span class="keyword">in</span> iterable]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a_list = []</span><br><span class="line">a_list.append(<span class="number">1</span>)</span><br><span class="line">a_list.append(<span class="number">2</span>)</span><br><span class="line">print(a_list, <span class="string">f'has a length of <span class="subst">&#123;len(a_list)&#125;</span>.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#range() 返回的不是 list，需要用 list() 转换，否则也没办法调用 .append()</span></span><br><span class="line">b_list = list(range(<span class="number">1</span>, <span class="number">9</span>))</span><br><span class="line">b_list.append(<span class="number">11</span>)</span><br><span class="line">print(b_list, <span class="string">f'has a length of <span class="subst">&#123;len(b_list)&#125;</span>.'</span>)</span><br><span class="line"></span><br><span class="line">c_list = [<span class="number">2</span>**x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">8</span>)]</span><br><span class="line">print(c_list, <span class="string">f'has a length of <span class="subst">&#123;len(c_list)&#125;</span>.'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>[1, 2] has a length of 2.
[1, 2, 3, 4, 5, 6, 7, 8, 11] has a length of 9.
[1, 2, 4, 8, 16, 32, 64, 128] has a length of 8.
</code></pre><p>这最后一种方式颇为神奇：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>**x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">8</span>)]</span><br></pre></td></tr></table></figure>
<p>这种做法，叫做 <strong><a href="https://docs.python.org/3.7/tutorial/datastructures.html#tut-listcomps" target="_blank" rel="noopener">List Comprehension</a></strong>。</p>
<p><em>Comprehend</em> 这个词的意思除了 “理解” 之外，还有另外一个意思，就是 “包括、囊括” —— 这样的话，你就大概能理解这种做法为什么被称作 <em>List Comprehension</em> 了。中文翻译中，怎么翻译的都有，“列表生成器”、“列表生成式” 等等，都挺好。但是，被翻译成 “列表解析器”，就不太好了，给人的感觉是操作反了……</p>
<p>List comprehension 可以嵌套使用 <code>for</code>，甚至可以加上条件 <code>if</code>。官方文档里有个例子，是用来把两个元素并不完全相同的列表去同后拼成一个列表（下面稍作了改写）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">n = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成一个 n 个元素的序列，每个元素是 1~100 之间的随机数</span></span><br><span class="line">a_list = [random.randrange(<span class="number">1</span>, <span class="number">100</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">print(<span class="string">f'a_list comprehends <span class="subst">&#123;len(a_list)&#125;</span> random numbers: <span class="subst">&#123;a_list&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 a_list 里把偶数都挑出来</span></span><br><span class="line">b_list = [x <span class="keyword">for</span> x <span class="keyword">in</span> a_list <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">print(<span class="string">f'... and it has <span class="subst">&#123;len(b_list)&#125;</span> even numbers: <span class="subst">&#123;b_list&#125;</span>'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>a_list comprehends 10 random numbers: [52, 34, 7, 96, 33, 79, 95, 18, 37, 46]
... and it has 5 even numbers: [52, 34, 96, 18, 46]
</code></pre><h3 id="列表的操作符-1"><a href="#列表的操作符-1" class="headerlink" title="列表的操作符"></a>列表的操作符</h3><p>列表的操作符和字符串一样，因为它们都是有序容器。列表的操作符有：</p>
<blockquote>
<ul>
<li>拼接：<code>+</code>（与字符串不一样的地方是，不能用空格 <code>&#39; &#39;</code> 了）</li>
<li>复制：<code>*</code></li>
<li>逻辑运算：<code>in</code> 和 <code>not in</code>，<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code>、<code>!=</code>、<code>==</code></li>
</ul>
</blockquote>
<p>而后两个列表也和两个字符串一样，可以被比较，即，可以进行逻辑运算；比较方式也跟字符串一样，从两个列表各自的第一个元素开始逐个比较，“一旦决出胜负马上停止”：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line">a_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b_list = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">c_list = a_list + b_list * <span class="number">3</span></span><br><span class="line">c_list</span><br><span class="line"><span class="number">7</span> <span class="keyword">not</span> <span class="keyword">in</span> c_list</span><br><span class="line">a_list &gt; b_list</span><br></pre></td></tr></table></figure>
<pre><code>[1, 2, 3, 4, 5, 6, 4, 5, 6, 4, 5, 6]
True
False
</code></pre><h3 id="根据索引提取列表元素"><a href="#根据索引提取列表元素" class="headerlink" title="根据索引提取列表元素"></a>根据索引提取列表元素</h3><p>列表当然也可以根据索引操作，但由于列表是可变序列，所以，不仅可以提取，还可以删除，甚至替换。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">n = <span class="number">3</span></span><br><span class="line">a_list = [random.randrange(<span class="number">65</span>, <span class="number">91</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">b_list = [chr(random.randrange(<span class="number">65</span>, <span class="number">91</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">print(a_list)</span><br><span class="line">c_list = a_list + b_list + a_list * <span class="number">2</span></span><br><span class="line">print(c_list)</span><br><span class="line"></span><br><span class="line">print()</span><br><span class="line"><span class="comment"># 根据索引提取（Slicing）</span></span><br><span class="line">print(c_list[<span class="number">3</span>])        <span class="comment"># 返回索引值为 3 的元素值</span></span><br><span class="line">print(c_list[:])        <span class="comment"># 相当于 c_list，返回整个列表</span></span><br><span class="line">print(c_list[<span class="number">5</span>:])       <span class="comment"># 从索引为 5 的值开始直到末尾</span></span><br><span class="line">print(c_list[:<span class="number">3</span>])       <span class="comment"># 从索引 0 开始，直到索引 3 之前（不包括 3）</span></span><br><span class="line">print(c_list[<span class="number">2</span>:<span class="number">6</span>])      <span class="comment"># 从索引 2 开始，直到索引 6 之前（不包括 6）</span></span><br><span class="line"></span><br><span class="line">print()</span><br><span class="line"><span class="comment"># 根据索引删除</span></span><br><span class="line"><span class="keyword">del</span> c_list[<span class="number">3</span>]</span><br><span class="line">print(c_list)           <span class="comment"># del 是个命令，del c_list[3] 是一个语句；不能这么写：print(del c_list[3])</span></span><br><span class="line"><span class="keyword">del</span> c_list[<span class="number">5</span>:<span class="number">8</span>]</span><br><span class="line">print(c_list)</span><br><span class="line"></span><br><span class="line">print()</span><br><span class="line"><span class="comment"># 根据索引替换</span></span><br><span class="line">c_list[<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>] = [<span class="string">'a'</span>, <span class="number">2</span>]  <span class="comment"># s[start:stop:step] = t，跟 range 的三个参数类似；</span></span><br><span class="line">                         <span class="comment"># len(t) = len([start:stop:step]) 必须为真</span></span><br><span class="line">print(c_list)</span><br></pre></td></tr></table></figure>
<pre><code>[77, 66, 79]
[77, 66, 79, &apos;L&apos;, &apos;Z&apos;, &apos;R&apos;, 77, 66, 79, 77, 66, 79]

L
[77, 66, 79, &apos;L&apos;, &apos;Z&apos;, &apos;R&apos;, 77, 66, 79, 77, 66, 79]
[&apos;R&apos;, 77, 66, 79, 77, 66, 79]
[77, 66, 79]
[79, &apos;L&apos;, &apos;Z&apos;, &apos;R&apos;]

[77, 66, 79, &apos;Z&apos;, &apos;R&apos;, 77, 66, 79, 77, 66, 79]
[77, 66, 79, &apos;Z&apos;, &apos;R&apos;, 77, 66, 79]

[77, &apos;a&apos;, 79, 2, &apos;R&apos;, 77, 66, 79]
</code></pre><p>需要注意的地方是：<strong>列表</strong>（List）是可变序列，而<strong>字符串</strong>（str）是不可变序列，所以，对字符串来说，虽然也可以根据索引提取，但没办法根据索引删除或者替换。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'Python'</span>[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">print(s)</span><br><span class="line"><span class="keyword">del</span> s[<span class="number">2</span>]  <span class="comment"># 这一句会报错</span></span><br></pre></td></tr></table></figure>
<pre><code>tho

---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

&lt;ipython-input-7-c9c999709965&gt; in &lt;module&gt;
      1 s = &apos;Python&apos;[2:5]
      2 print(s)
----&gt; 3 del s[3]  # 这一句会报错

TypeError: &apos;str&apos; object doesn&apos;t support item deletion
</code></pre><p>之前提到过：</p>
<blockquote>
<p>字符串常量（String Literal）是不可变有序容器，所以，虽然字符串也有一些 Methods 可用，但那些 Methods 都不改变它们自身，而是在操作后返回一个值给另外一个变量。</p>
</blockquote>
<p>而对于列表这种<em>可变容器</em>，我们可以对它进行操作，结果是<em>它本身被改变</em>了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'Python'</span></span><br><span class="line">L = list(s)</span><br><span class="line">print(s)</span><br><span class="line">print(L)</span><br><span class="line"><span class="keyword">del</span> L[<span class="number">2</span>]</span><br><span class="line">print(L) <span class="comment"># 用 del 对 L 操作之后，L 本身少了 1 个元素</span></span><br></pre></td></tr></table></figure>
<pre><code>Python
[&apos;P&apos;, &apos;y&apos;, &apos;t&apos;, &apos;h&apos;, &apos;o&apos;, &apos;n&apos;]
[&apos;P&apos;, &apos;y&apos;, &apos;h&apos;, &apos;o&apos;, &apos;n&apos;]
</code></pre><h3 id="列表可用的内建函数"><a href="#列表可用的内建函数" class="headerlink" title="列表可用的内建函数"></a>列表可用的内建函数</h3><p>列表和字符串都是容器，它们可使用的内建函数也其实都是一样的：</p>
<blockquote>
<ul>
<li><code>len()</code></li>
<li><code>max()</code></li>
<li><code>min()</code></li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">n = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 3 个随机数，构成一个列表</span></span><br><span class="line">a_list = [random.randrange(<span class="number">65</span>, <span class="number">91</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">b_list = [chr(random.randrange(<span class="number">65</span>, <span class="number">91</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">print(a_list)</span><br><span class="line">print(b_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表可以使用操作符 + 和*</span></span><br><span class="line">c_list = a_list + b_list + a_list * <span class="number">2</span></span><br><span class="line">print(c_list)</span><br><span class="line"></span><br><span class="line">a_list *= <span class="number">3</span></span><br><span class="line">print(a_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 内建函数操作 len()、max()、min()</span></span><br><span class="line">print(len(c_list))</span><br><span class="line">print(max(b_list)) <span class="comment"># 内建函数内部做了异常处理，可以比较字符和数字 —— 初学者最讨厌这种事情了……</span></span><br><span class="line">print(min(b_list)) <span class="comment"># 注意，max() 和 min() 应用的是 b_list, len() 应用的是 c_list —— 请自行找到对应的 list 进行分析。</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'X'</span> <span class="keyword">not</span> <span class="keyword">in</span> b_list)</span><br></pre></td></tr></table></figure>
<pre><code>[89, 84, 85]
[&apos;X&apos;, &apos;B&apos;, &apos;X&apos;]
[89, 84, 85, &apos;X&apos;, &apos;B&apos;, &apos;X&apos;, 89, 84, 85, 89, 84, 85]
[89, 84, 85, 89, 84, 85, 89, 84, 85]
12
X
B
False
</code></pre><h3 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h3><p>字符串常量和 range() 都是不可变的（Immutable）；而列表则是<strong>可变类型</strong>（Mutable type），所以，它最起码可以被排序 —— 使用 <code>sort()</code> Method：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">n = <span class="number">10</span></span><br><span class="line">a_list = [random.randrange(<span class="number">1</span>, <span class="number">100</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">print(<span class="string">f'a_list comprehends <span class="subst">&#123;len(a_list)&#125;</span> random numbers:\n'</span>, a_list)</span><br><span class="line"></span><br><span class="line">a_list.sort()</span><br><span class="line">print(<span class="string">'the list sorted:\n'</span>, a_list)</span><br><span class="line"></span><br><span class="line">a_list.sort(reverse=<span class="literal">True</span>) <span class="comment">#reverse 参数，默认是 False</span></span><br><span class="line">print(<span class="string">'the list sorted reversely:\n'</span>, a_list)</span><br></pre></td></tr></table></figure>
<pre><code>a_list comprehends 10 random numbers:
 [98, 9, 95, 15, 80, 70, 98, 82, 88, 46]
the list sorted:
 [9, 15, 46, 70, 80, 82, 88, 95, 98, 98]
the list sorted reversely:
 [98, 98, 95, 88, 82, 80, 70, 46, 15, 9]
</code></pre><p>如果列表中的元素全都是由字符串构成的，当然也可以排序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">n = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">a_list = [chr(random.randrange(<span class="number">65</span>, <span class="number">91</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line"><span class="comment"># chr() 函数会返回指定 ascii 码的字符，ord('A') 是 65</span></span><br><span class="line">print(<span class="string">f'a_list comprehends <span class="subst">&#123;len(a_list)&#125;</span> random string elements:\n'</span>, a_list)</span><br><span class="line"></span><br><span class="line">a_list.sort()</span><br><span class="line">print(<span class="string">'the list sorted:\n'</span>, a_list)</span><br><span class="line"></span><br><span class="line">a_list.sort(reverse=<span class="literal">True</span>) <span class="comment">#reverse 参数，默认是 False</span></span><br><span class="line">print(<span class="string">'the list sorted reversely:\n'</span>, a_list)</span><br><span class="line"></span><br><span class="line">print()</span><br><span class="line"></span><br><span class="line">b_list = [chr(random.randrange(<span class="number">65</span>, <span class="number">91</span>)) +\</span><br><span class="line">            chr(random.randrange(<span class="number">97</span>, <span class="number">123</span>))\</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line"><span class="comment"># 可以在行末加上 \ 符号，表示 “该行未完待续……”</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">f'b_list comprehends <span class="subst">&#123;len(b_list)&#125;</span> random string elements:\n'</span>, b_list)</span><br><span class="line"></span><br><span class="line">b_list.sort()</span><br><span class="line">print(<span class="string">'the sorted:\n'</span>, b_list)</span><br><span class="line"></span><br><span class="line">b_list.sort(key=str.lower, reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># key 参数，默认是 None</span></span><br><span class="line"><span class="comment"># key=str.lower 的意思是，在比较排序的时候，先全都转换成小写再比较排序……</span></span><br><span class="line"><span class="comment"># —— 但并不改变原有值</span></span><br><span class="line">print(<span class="string">'the sorted reversely:\n'</span>, b_list)</span><br></pre></td></tr></table></figure>
<pre><code>a_list comprehends 10 random string elements:
 [&apos;B&apos;, &apos;U&apos;, &apos;H&apos;, &apos;D&apos;, &apos;C&apos;, &apos;V&apos;, &apos;V&apos;, &apos;Q&apos;, &apos;U&apos;, &apos;P&apos;]
the list sorted:
 [&apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;H&apos;, &apos;P&apos;, &apos;Q&apos;, &apos;U&apos;, &apos;U&apos;, &apos;V&apos;, &apos;V&apos;]
the list sorted reversely:
 [&apos;V&apos;, &apos;V&apos;, &apos;U&apos;, &apos;U&apos;, &apos;Q&apos;, &apos;P&apos;, &apos;H&apos;, &apos;D&apos;, &apos;C&apos;, &apos;B&apos;]

b_list comprehends 10 random string elements:
 [&apos;Nl&apos;, &apos;Mh&apos;, &apos;Ta&apos;, &apos;By&apos;, &apos;Ul&apos;, &apos;Nc&apos;, &apos;Gu&apos;, &apos;Rp&apos;, &apos;Pv&apos;, &apos;Bu&apos;]
the sorted:
 [&apos;Bu&apos;, &apos;By&apos;, &apos;Gu&apos;, &apos;Mh&apos;, &apos;Nc&apos;, &apos;Nl&apos;, &apos;Pv&apos;, &apos;Rp&apos;, &apos;Ta&apos;, &apos;Ul&apos;]
the sorted reversely:
 [&apos;Ul&apos;, &apos;Ta&apos;, &apos;Rp&apos;, &apos;Pv&apos;, &apos;Nl&apos;, &apos;Nc&apos;, &apos;Mh&apos;, &apos;Gu&apos;, &apos;By&apos;, &apos;Bu&apos;]
</code></pre><p><strong>注意</strong>：不能乱比较…… 被比较的元素应该是同一类型 —— 所以，不是由同一种数据类型元素构成的列表，不能使用 <code>sort()</code> Method。下面的代码会报错：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a_list = [<span class="number">1</span>, <span class="string">'a'</span>, <span class="string">'c'</span>]</span><br><span class="line">a_list = a_list.sort() <span class="comment"># 这一句会报错</span></span><br></pre></td></tr></table></figure>
<pre><code>---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

&lt;ipython-input-12-acb9480a455d&gt; in &lt;module&gt;
      1 a_list = [1, &apos;a&apos;, &apos;c&apos;]
----&gt; 2 a_list = a_list.sort() # 这一句会报错

TypeError: &apos;&lt;&apos; not supported between instances of &apos;str&apos; and &apos;int&apos;
</code></pre><p><strong>可变序列</strong>还有一系列可用的 <strong>Methods</strong>：<code>a.append()</code>，<code>a.clear()</code>，<code>a.copy()</code>，<code>a.extend(t)</code>，<code>a.insert(i，x)</code>，<code>a.pop([i])</code>，<code>a.remove(x)</code>，<code>a.reverse()</code>……</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">n = <span class="number">3</span></span><br><span class="line">a_list = [random.randrange(<span class="number">65</span>, <span class="number">91</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">b_list = [chr(random.randrange(<span class="number">65</span>, <span class="number">91</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">print(a_list)</span><br><span class="line">c_list = a_list + b_list + a_list * <span class="number">2</span></span><br><span class="line">print(c_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在末尾追加一个元素</span></span><br><span class="line">c_list.append(<span class="string">'100'</span>)</span><br><span class="line">print(c_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空序列</span></span><br><span class="line">print()</span><br><span class="line">print(a_list)</span><br><span class="line">a_list.clear()</span><br><span class="line">print(a_list)</span><br><span class="line"></span><br><span class="line">print()</span><br><span class="line"><span class="comment"># 拷贝一个列表</span></span><br><span class="line">d_list = c_list.copy()</span><br><span class="line">print(d_list)</span><br><span class="line"><span class="keyword">del</span> d_list[<span class="number">6</span>:<span class="number">8</span>]</span><br><span class="line">print(d_list)</span><br><span class="line">print(c_list)             <span class="comment"># 对一个拷贝操作，不会更改 “原件”</span></span><br><span class="line"></span><br><span class="line">print()</span><br><span class="line"><span class="comment"># 演示拷贝 .copy() 与赋值 = 的不同</span></span><br><span class="line">e_list = d_list</span><br><span class="line"><span class="keyword">del</span> e_list[<span class="number">6</span>:<span class="number">8</span>]</span><br><span class="line">print(e_list)</span><br><span class="line">print(d_list)             <span class="comment"># 对 e_list 操作，相当于对 d_list 操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在末尾追加一个列表</span></span><br><span class="line">print()</span><br><span class="line">print(a_list)</span><br><span class="line">a_list.extend(c_list)      <span class="comment"># 相当于 a_list += c_list</span></span><br><span class="line">print(a_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在某索引位置插入一个元素</span></span><br><span class="line">print()</span><br><span class="line">print(a_list)</span><br><span class="line">a_list.insert(<span class="number">1</span>, <span class="string">'example'</span>)   <span class="comment"># 在索引 1 的位置插入 'example'</span></span><br><span class="line">a_list.insert(<span class="number">3</span>, <span class="string">'example'</span>)   <span class="comment"># 在索引 3 的位置插入 'example'；</span></span><br><span class="line">print(a_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># a_list.sort() 这一句会出错，因为当前列表中的元素，是 int 和 str 混合的。</span></span><br><span class="line"></span><br><span class="line">print()</span><br><span class="line">print(a_list)</span><br><span class="line">a_list.reverse()</span><br><span class="line">print(a_list)</span><br><span class="line">x = a_list.reverse() <span class="comment"># reverse() 只对当前序列操作，并不返回一个逆序列表；返回值是 None</span></span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>
<pre><code>[90, 88, 73]
[90, 88, 73, &apos;T&apos;, &apos;N&apos;, &apos;Y&apos;, 90, 88, 73, 90, 88, 73]
[90, 88, 73, &apos;T&apos;, &apos;N&apos;, &apos;Y&apos;, 90, 88, 73, 90, 88, 73, &apos;100&apos;]

[90, 88, 73]
[]

[90, 88, 73, &apos;T&apos;, &apos;N&apos;, &apos;Y&apos;, 90, 88, 73, 90, 88, 73, &apos;100&apos;]
[90, 88, 73, &apos;T&apos;, &apos;N&apos;, &apos;Y&apos;, 73, 90, 88, 73, &apos;100&apos;]
[90, 88, 73, &apos;T&apos;, &apos;N&apos;, &apos;Y&apos;, 90, 88, 73, 90, 88, 73, &apos;100&apos;]

[90, 88, 73, &apos;T&apos;, &apos;N&apos;, &apos;Y&apos;, 88, 73, &apos;100&apos;]
[90, 88, 73, &apos;T&apos;, &apos;N&apos;, &apos;Y&apos;, 88, 73, &apos;100&apos;]

[]
[90, 88, 73, &apos;T&apos;, &apos;N&apos;, &apos;Y&apos;, 90, 88, 73, 90, 88, 73, &apos;100&apos;]

[90, 88, 73, &apos;T&apos;, &apos;N&apos;, &apos;Y&apos;, 90, 88, 73, 90, 88, 73, &apos;100&apos;]
[90, &apos;example&apos;, 88, &apos;example&apos;, 73, &apos;T&apos;, &apos;N&apos;, &apos;Y&apos;, 90, 88, 73, 90, 88, 73, &apos;100&apos;]

[90, &apos;example&apos;, 88, &apos;example&apos;, 73, &apos;T&apos;, &apos;N&apos;, &apos;Y&apos;, 90, 88, 73, 90, 88, 73, &apos;100&apos;]
[&apos;100&apos;, 73, 88, 90, 73, 88, 90, &apos;Y&apos;, &apos;N&apos;, &apos;T&apos;, 73, &apos;example&apos;, 88, &apos;example&apos;, 90]
None
</code></pre><p>有一个命令、两个 Methods 与删除单个元素相关联，<code>del</code>，<code>a.pop([i])</code>，<code>a.remove(x)</code>，请注意它们之间的区别。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">n = <span class="number">3</span></span><br><span class="line">a_list = [random.randrange(<span class="number">65</span>, <span class="number">91</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">print(a_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入</span></span><br><span class="line">print()</span><br><span class="line">a_list.insert(<span class="number">1</span>, <span class="string">'example'</span>)   <span class="comment"># 在索引 1 的位置插入 'example'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">print()</span><br><span class="line">print(a_list)</span><br><span class="line">a_list.remove(<span class="string">'example'</span>)      <span class="comment"># 去除 'example' 这个元素，如果有多个 'example'，只删除第一个</span></span><br><span class="line">print(a_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pop() 删除并返回被删除的值</span></span><br><span class="line"></span><br><span class="line">print()</span><br><span class="line">print(a_list)</span><br><span class="line">p = a_list.pop(<span class="number">2</span>)      <span class="comment"># 去除索引为 2 的元素，且返回元素的值，赋值给 p</span></span><br><span class="line">print(a_list)</span><br><span class="line">print(p)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pop() 与 del，或者 remove() 的区别</span></span><br><span class="line">print()</span><br><span class="line">a_list.insert(<span class="number">2</span>, <span class="string">'example'</span>)</span><br><span class="line">a_list.insert(<span class="number">2</span>, <span class="string">'example'</span>)</span><br><span class="line">print(a_list)</span><br><span class="line"><span class="keyword">del</span> a_list[<span class="number">2</span>]</span><br><span class="line">print(a_list)</span><br><span class="line"></span><br><span class="line">print()</span><br><span class="line">print(a_list.remove(<span class="string">'example'</span>)) <span class="comment"># a_list.remove() 这个 Method 的返回值是 None</span></span><br><span class="line">print(a_list)</span><br></pre></td></tr></table></figure>
<pre><code>[88, 84, 69]

[88, &apos;example&apos;, 84, 69]
[88, 84, 69]

[88, 84, 69]
[88, 84]
69

[88, 84, &apos;example&apos;, &apos;example&apos;]
[88, 84, &apos;example&apos;]

None
[88, 84]
</code></pre><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>看起来是个新概念，例子全部读完也很是要花上一段时间，然而，从操作上来看，操作列表和操作字符串的差异并不大，重点在于一个是 Immutable，另外一个是 Mutable，所以，例如像 <code>a.sort()</code>，<code>a.remove()</code> 这样的事，列表能做，字符串不能做 —— 字符串也可以排序，但那是排序之后返回给另外一个变量；而列表可以直接改变自身……</p>
<p>而整理成表格之后呢，理解与记忆真的是零压力：</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/list-concepts.png?raw=true" alt></p>
<h2 id="元组（Tuple）"><a href="#元组（Tuple）" class="headerlink" title="元组（Tuple）"></a>元组（Tuple）</h2><p>在完整掌握列表的创建与操作之后，再理解元组（Tuple）就容易了，因为它们之间的主要区别只有两个：</p>
<blockquote>
<ul>
<li>List 是<em>可变</em>有序容器，Tuple 是<em>不可变</em>有序容器。</li>
<li>List 用<em>方括号</em>标识 <code>[]</code>，Tuple 用<em>圆括号</em> 标识 <code>()</code>。</li>
</ul>
</blockquote>
<p>创建一个元组的时候，用圆括号：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = ()</span><br></pre></td></tr></table></figure>
<p>这样就创建了一个空元组。</p>
<p>多个元素之间，用 <code>,</code> 分离。</p>
<p>创建一个含多个元素的元组，可以省略这个括号。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>   <span class="comment"># 不建议这种写法</span></span><br><span class="line">b = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment"># 在创建元组的时候建议永远不省略圆括号……</span></span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line">a == b</span><br></pre></td></tr></table></figure>
<pre><code>(1, 2, 3)
(1, 2, 3)
True
</code></pre><p><strong>注意</strong>：创建单个元素的元组，无论是否使用圆括号，在那唯一的元素后面一定要<em>补上一个逗号</em> <code>,</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span>, <span class="comment"># 注意这个末尾的逗号 , 它使得 a 变量被定义为一个元组，而不是数字</span></span><br><span class="line">a</span><br><span class="line"></span><br><span class="line">b = <span class="number">2</span>  <span class="comment"># 整数，赋值</span></span><br><span class="line">b</span><br><span class="line"></span><br><span class="line">c = (<span class="number">2</span>) <span class="comment"># 不是元组</span></span><br><span class="line">c</span><br><span class="line">type(c) <span class="comment"># 还是 int</span></span><br><span class="line"></span><br><span class="line">d = (<span class="number">2</span>,) <span class="comment"># 这才是元组</span></span><br><span class="line">d</span><br><span class="line">a == d</span><br></pre></td></tr></table></figure>
<pre><code>(2,)
2
2
int
(2,)
True
</code></pre><p>元组是不可变序列，所以，你没办法从里面删除元素。</p>
<p>但是，你可以在末尾追加元素。所以，严格意义上，对元组来讲，“不可变” 的意思是说，“<strong>当前已有部分不可变</strong>”……</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>,</span><br><span class="line">print(a)</span><br><span class="line">print(id(a))</span><br><span class="line">a += <span class="number">3</span>, <span class="number">5</span></span><br><span class="line">print(a)</span><br><span class="line">print(id(a)) <span class="comment"># id 并不相同 —— 实际上是在内存中另外新创建了一个元组……</span></span><br></pre></td></tr></table></figure>
<pre><code>(1,)
4593032496
(1, 3, 5)
4592468976
</code></pre><p>初学者总是很好奇 List 和 Tuple 的区别。首先是使用场景，在将来需要更改的时候，创建 List<br>；在将来不需要更改的时候，创建 Tuple。其次，从计算机的角度来看，Tuple 相对于 List 占用更小的内存。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">10000</span> <span class="comment">#@param &#123;type:"number"&#125;</span></span><br><span class="line">a = range(n)</span><br><span class="line">b = tuple(a) <span class="comment"># 把 a 转换成元组</span></span><br><span class="line">c = list(a) <span class="comment"># 把 a 转换成列表</span></span><br><span class="line">a.__sizeof__()</span><br><span class="line">b.__sizeof__()</span><br><span class="line">c.__sizeof__()</span><br></pre></td></tr></table></figure>
<pre><code>48

80024

90088
</code></pre><p>等你了解了 Tuple 的标注方式，你就会发现，<code>range()</code> 函数返回的等差数列就是一个 Tuple —— <code>range(6)</code> 就相当于 <code>(0, 1, 2, 3, 4, 5)</code>。</p>
<h2 id="集合（Set）"><a href="#集合（Set）" class="headerlink" title="集合（Set）"></a>集合（Set）</h2><p><strong>集合</strong>（Set）这个容器类型与列表不同的地方在于，首先它<em>不包含重合元素</em>，其次它是<em>无序</em>的；进而，集合又分为两种，Set，<em>可变的</em>，Frozen Set，<em>不可变的</em>。</p>
<p>创建一个集合，用<strong>花括号</strong> <code>{}</code> 把元素括起来，用 <code>,</code> 把元素隔开：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">primes = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>&#125;</span><br><span class="line">primes</span><br></pre></td></tr></table></figure>
<pre><code>{2, 3, 5, 7, 11, 13, 17}
</code></pre><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>注意：创建空集合的时候，必须用 <code>set()</code>，而不能用 <code>{}</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line">a = &#123;&#125; <span class="comment"># 注意这样创建的是一个 dict（字典），而不是 set 集合</span></span><br><span class="line">b = set() <span class="comment"># 这样创建的才是空集合</span></span><br><span class="line">type(a)</span><br><span class="line">type(b)</span><br></pre></td></tr></table></figure>
<pre><code>dict
set
</code></pre><p>也可以将序列数据转换（Casting）为集合。转换后，返回的是一个已<strong>去重</strong>的集合。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line">a = <span class="string">"abcabcdeabcdbcdef"</span></span><br><span class="line">b = range(<span class="number">10</span>)</span><br><span class="line">c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line">d = (<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'e'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>)</span><br><span class="line">set(a)</span><br><span class="line">set(b)</span><br><span class="line">set(c)</span><br><span class="line">set(d)</span><br></pre></td></tr></table></figure>
<pre><code>{&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;}
{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
{1, 2, 3}
{&apos;a&apos;, &apos;b&apos;, &apos;e&apos;}
</code></pre><p>Set 当然也可以进行 <em>Comprehension</em>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">"abcabcdeabcdbcdef"</span></span><br><span class="line">b = &#123;x <span class="keyword">for</span> x <span class="keyword">in</span> a <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">'abc'</span>&#125;</span><br><span class="line">b</span><br></pre></td></tr></table></figure>
<pre><code>{&apos;d&apos;, &apos;e&apos;, &apos;f&apos;}
</code></pre><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>将序列类型数据转换成 Set，就等于<strong>去重</strong>。当然，也可以用 <code>in</code> 来判断某个元素是否属于这个集合。<code>len()</code>、<code>max()</code>、<code>min()</code>，也都可以用来操作 Set，但 <code>del</code> 却不行 —— 因为 Set 中的元素没有索引（它不是有序容器）。从 Set 里删除元素，得用 <code>set.remove(elem)</code>；而 Frozen Set 是不可变的，所以不能用 <code>set.remove(elem)</code> 操作。</p>
<p>对于集合，有相应的操作符可以对它们进行集合运算：</p>
<blockquote>
<ul>
<li>并集：<code>|</code></li>
<li>交集：<code>&amp;</code></li>
<li>差集：<code>-</code></li>
<li>对称差集：<code>^</code></li>
</ul>
</blockquote>
<p>之前用 <code>set(&#39;abcabcdeabcdbcdef&#39;)</code> 作为简单例子还凑合能用；但这样对读者无意义的集合，无助于进一步的理解。</p>
<p>事实上，每种数据结构（Data Structures —— 在这一章里，我们一直用的概念是 “容器”，其实是指同一事物的两种称呼）都有自己的应用场景。比如，当我们需要管理很多用户时，集合就可以派上很大用场。</p>
<p>假定两个集合中有些人是 admins，有些人是 moderators：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">admins = &#123;<span class="string">'Moose'</span>, <span class="string">'Joker'</span>, <span class="string">'Joker'</span>&#125;</span><br><span class="line">moderators = &#123;<span class="string">'Ann'</span>, <span class="string">'Chris'</span>, <span class="string">'Jane'</span>, <span class="string">'Moose'</span>, <span class="string">'Zero'</span>&#125;</span><br></pre></td></tr></table></figure>
<p>那么：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">admins = &#123;<span class="string">'Moose'</span>, <span class="string">'Joker'</span>, <span class="string">'Joker'</span>&#125;</span><br><span class="line">moderators = &#123;<span class="string">'Ann'</span>, <span class="string">'Chris'</span>, <span class="string">'Jane'</span>, <span class="string">'Moose'</span>, <span class="string">'Zero'</span>&#125;</span><br><span class="line"></span><br><span class="line">admins                 <span class="comment"># 去重自动完成</span></span><br><span class="line"><span class="string">'Joker'</span> <span class="keyword">in</span> admins      <span class="comment"># Joker 是否是 admins？</span></span><br><span class="line"><span class="string">'Joker'</span> <span class="keyword">in</span> moderators  <span class="comment"># Joker 是否是 moderator？</span></span><br><span class="line">admins | moderators    <span class="comment"># admins、moderator，或者身兼两职的，即，两个角色中的所有人 in admins or moderators or both</span></span><br><span class="line">admins &amp; moderators    <span class="comment"># 既是 admins 又是 moderator 的都有谁？in both admins and moderators</span></span><br><span class="line">admins - moderators    <span class="comment"># 是 admins 但不是 moderator 的都有谁？in admins but not in moderators</span></span><br><span class="line">admins ^ moderators    <span class="comment"># admins 和 moderator 中不是身兼两职的都有谁？in admins or moderator but not both</span></span><br></pre></td></tr></table></figure>
<pre><code>{&apos;Joker&apos;, &apos;Moose&apos;}
True
False
{&apos;Ann&apos;, &apos;Chris&apos;, &apos;Jane&apos;, &apos;Joker&apos;, &apos;Moose&apos;, &apos;Zero&apos;}
{&apos;Moose&apos;}
{&apos;Joker&apos;}
{&apos;Ann&apos;, &apos;Chris&apos;, &apos;Jane&apos;, &apos;Joker&apos;, &apos;Zero&apos;}
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这个 cell 集合运算图示需要安装 matplotlib 和 matplotlib-venn</span></span><br><span class="line"><span class="comment"># !pip install matplotlib</span></span><br><span class="line"><span class="comment"># !pip install matplotlib-venn</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib_venn <span class="keyword">import</span> venn2</span><br><span class="line"></span><br><span class="line">admins = &#123;<span class="string">'Moose'</span>, <span class="string">'Joker'</span>, <span class="string">'Joker'</span>&#125;</span><br><span class="line">moderators = &#123;<span class="string">'Ann'</span>, <span class="string">'Chris'</span>, <span class="string">'Jane'</span>, <span class="string">'Moose'</span>, <span class="string">'Zero'</span>&#125;</span><br><span class="line"></span><br><span class="line">v = venn2(subsets=(admins, moderators), set_labels=(<span class="string">'admins'</span>, <span class="string">'moderators'</span>))</span><br><span class="line">v.get_label_by_id(<span class="string">'11'</span>).set_text(<span class="string">'\n'</span>.join(admins &amp; moderators))</span><br><span class="line">v.get_label_by_id(<span class="string">'10'</span>).set_text(<span class="string">'\n'</span>.join(admins - moderators))</span><br><span class="line">v.get_label_by_id(<span class="string">'01'</span>).set_text(<span class="string">'\n'</span>.join(moderators - admins))</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/Part.1.E.6.containers_66_0.png?raw=true" alt="png"></p>
<p>以上的操作符，都有另外一个版本，即，用 Set 这个类的 Methods 完成。</p>
<table>
<thead>
<tr>
<th style="text-align:center">意义</th>
<th style="text-align:center">操作符</th>
<th style="text-align:center">Methods</th>
<th style="text-align:center">Methods 相当于</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">并集</td>
<td style="text-align:center"><code>&#124;</code></td>
<td style="text-align:center"><code>set.union(*others)</code></td>
<td style="text-align:center"><code>set &#124; other &#124; …</code></td>
</tr>
<tr>
<td style="text-align:center">交集</td>
<td style="text-align:center"><code>&amp;</code></td>
<td style="text-align:center"><code>set.intersection(*others)</code></td>
<td style="text-align:center"><code>set &amp; other &amp; ...</code></td>
</tr>
<tr>
<td style="text-align:center">差集</td>
<td style="text-align:center"><code>-</code></td>
<td style="text-align:center"><code>set.difference(*others)</code></td>
<td style="text-align:center"><code>set - other - ...</code></td>
</tr>
<tr>
<td style="text-align:center">对称差集</td>
<td style="text-align:center"><code>^</code></td>
<td style="text-align:center"><code>set.symmetric_difference(other)</code></td>
<td style="text-align:center"><code>set ^ other</code></td>
</tr>
</tbody>
</table>
<p>注意，并集、交集、差集的 Methods，可以接收多个集合作为参数 <code>(*other)</code>，但对称差集 Method 只接收一个参数 <code>(other)</code>。</p>
<p>对于集合，推荐更多使用 Methods 而不是操作符的主要原因是：更易读 —— 对人来说，因为有意义、有用处的代码终将需要人去维护。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line">admins = &#123;<span class="string">'Moose'</span>, <span class="string">'Joker'</span>, <span class="string">'Joker'</span>&#125;</span><br><span class="line">moderators = &#123;<span class="string">'Chris'</span>, <span class="string">'Moose'</span>, <span class="string">'Jane'</span>, <span class="string">'Zero'</span>&#125;</span><br><span class="line"></span><br><span class="line">admins.union(moderators)</span><br><span class="line">admins.intersection(moderators)</span><br><span class="line">admins.difference(moderators)</span><br><span class="line">admins.symmetric_difference(moderators)</span><br></pre></td></tr></table></figure>
<pre><code>{&apos;Chris&apos;, &apos;Jane&apos;, &apos;Joker&apos;, &apos;Moose&apos;, &apos;Zero&apos;}
{&apos;Moose&apos;}
{&apos;Joker&apos;}
{&apos;Chris&apos;, &apos;Jane&apos;, &apos;Joker&apos;, &apos;Zero&apos;}
</code></pre><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><p>两个集合之间可以进行逻辑比较，返回布尔值。</p>
<p><strong>set</strong> <code>==</code> <strong>other</strong></p>
<blockquote>
<p><code>True</code>: set 与 other 相同</p>
</blockquote>
<p><strong>set</strong> <code>!=</code> <strong>other</strong></p>
<blockquote>
<p><code>True</code>: set 与 other 不同</p>
</blockquote>
<p><strong>isdisjoint</strong>(<em>other</em>)</p>
<blockquote>
<p><code>True</code>: set 与 other 非重合；即，<code>set &amp; other == None</code></p>
</blockquote>
<p><strong>issubset</strong>(<em>other</em>)，<strong>set</strong> <code>&lt;=</code> <strong>other</strong></p>
<blockquote>
<p><code>True</code>: set 是 other 的子集</p>
</blockquote>
<p><strong>set</strong> <code>&lt;</code> <strong>other</strong></p>
<blockquote>
<p><code>True</code>: set 是 other 的真子集，相当于 <code>set &lt;= other &amp;&amp; set != other</code></p>
</blockquote>
<p><strong>issuperset</strong>(<em>other</em>)，<strong>set</strong> <code>&gt;=</code> <strong>other</strong></p>
<blockquote>
<p><code>True</code>: set 是 other 的超集</p>
</blockquote>
<p><strong>set</strong> <code>&gt;</code> <strong>other</strong></p>
<blockquote>
<p><code>True</code>: set 是 other 的真超集，相当于 <code>set &gt;= other &amp;&amp; set != other</code></p>
</blockquote>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>对于集合，有以下更新它自身的 Method：</p>
<p><strong>add</strong>(<em>elem</em>)</p>
<blockquote>
<p>把 elem 加入集合</p>
</blockquote>
<p><strong>remove</strong>(<em>elem</em>)</p>
<blockquote>
<p>从集合中删除 elem；如果集合中不包含该 elem，会产生 KeyError 错误。</p>
</blockquote>
<p><strong>discard</strong>(<em>elem</em>)</p>
<blockquote>
<p>如果该元素存在于集合中，删除它。</p>
</blockquote>
<p><strong>pop</strong>(<em>elem</em>)</p>
<blockquote>
<p>从集合中删除 elem，并返回 elem 的值，针对空集合做此操作会产生 KeyError 错误。</p>
</blockquote>
<p><strong>clear</strong>()<br>从集合中删除所有元素。</p>
<p><strong>set.update</strong>(*<em>others</em>)，相当于 <code>set |= other | ...</code></p>
<blockquote>
<p>更新 set, 加入 others 中的所有元素；</p>
</blockquote>
<p><strong>set.intersection_update</strong>(*<em>others</em>)，相当于 <code>set &amp;= other &amp; ...</code></p>
<blockquote>
<p>更新 set, 保留同时存在于 set 和所有 others 之中的元素；</p>
</blockquote>
<p><strong>set.difference_update</strong>(*<em>others</em>)，相当于 <code>set -= other | ...</code></p>
<blockquote>
<p>更新 set, 删除所有在 others 中存在的元素；</p>
</blockquote>
<p><strong>set.symmetric_difference_update</strong>(<em>other</em>)，相当于 <code>set ^= other</code></p>
<blockquote>
<p>更新 set, 只保留存在于 set 或 other 中的元素，但不保留同时存在于 set 和 other 中的元素；<strong>注意</strong>，该 Method <em>只接收一个参数</em>。</p>
</blockquote>
<h3 id="冻结集合"><a href="#冻结集合" class="headerlink" title="冻结集合"></a>冻结集合</h3><p>还有一种集合，叫做冻结集合（Frozen Set），Frozen Set 之于 Set，正如 Tuple 之于 List，前者是不可变容器（Immutable），后者是可变容器（Mutable），无非是为了节省内存使用而设计的类别。</p>
<p>有空去看看这个链接就可以了：</p>
<blockquote>
<p><a href="https://docs.python.org/3/library/stdtypes.html#frozenset" target="_blank" rel="noopener">https://docs.python.org/3/library/stdtypes.html#frozenset</a></p>
</blockquote>
<h2 id="字典（Dictionary）"><a href="#字典（Dictionary）" class="headerlink" title="字典（Dictionary）"></a>字典（Dictionary）</h2><p>Map 是容器中的单独一类，<strong>映射</strong>（Map）容器。映射容器只有一种，叫做<strong>字典</strong>（Dictionary）。先看一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">phonebook = &#123;<span class="string">'ann'</span>:<span class="number">6575</span>, <span class="string">'bob'</span>:<span class="number">8982</span>, <span class="string">'joe'</span>:<span class="number">2598</span>, <span class="string">'zoe'</span>:<span class="number">1225</span>&#125;</span><br><span class="line">phonebook</span><br></pre></td></tr></table></figure>
<p>字典里的每个元素，由两部分组成，<em>key</em>（键）和 <em>value</em>（值），二者由一个冒号连接。</p>
<p>比如，<code>&#39;ann&#39;:6575</code> 这个字典元素，<em>key</em> 是 <code>&#39;ann&#39;</code>，<em>value</em> 是 <code>6575</code>。</p>
<p>字典直接使用 <em>key</em> 作为索引，并映射到与它匹配的 <em>value</em>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">phonebook = &#123;<span class="string">'ann'</span>:<span class="number">6575</span>, <span class="string">'bob'</span>:<span class="number">8982</span>, <span class="string">'joe'</span>:<span class="number">2598</span>, <span class="string">'zoe'</span>:<span class="number">1225</span>&#125;</span><br><span class="line">phonebook[<span class="string">'bob'</span>]</span><br></pre></td></tr></table></figure>
<pre><code>8982
</code></pre><p>在同一个字典里，<em>key</em> 都是唯一的。当创建字典的时候，如果其中有重复的 <em>key</em> 的话，就跟 Set 那样会 “<strong>自动去重</strong>” —— 保留的是众多重复的 <em>key</em> 中的最后一个 <em>key:value</em>（或者说，最后一个 <em>key:value</em> “之前那个 <em>key</em> 的 <em>value</em> 被<strong>更新</strong>了”)。字典这个数据类型之所以叫做 Map（映射），是因为字典里的 <em>key</em> 都映射且只映射一个对应的 <em>value</em>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">phonebook = &#123;<span class="string">'ann'</span>:<span class="number">6575</span>, <span class="string">'bob'</span>:<span class="number">8982</span>, <span class="string">'joe'</span>:<span class="number">2598</span>, <span class="string">'zoe'</span>:<span class="number">1225</span>, <span class="string">'ann'</span>:<span class="number">6585</span>&#125;</span><br><span class="line">phonebook</span><br></pre></td></tr></table></figure>
<pre><code>{&apos;ann&apos;: 6585, &apos;bob&apos;: 8982, &apos;joe&apos;: 2598, &apos;zoe&apos;: 1225}
</code></pre><p>在已经了解如何操作列表之后，再去理解字典的操作，其实没什么难度，无非就是字典多了几个 Methods。</p>
<p>提蓄一下自己的耐心，把下面的若干行代码都仔细阅读一下，猜一猜输出结果都是什么？</p>
<h3 id="字典的生成"><a href="#字典的生成" class="headerlink" title="字典的生成"></a>字典的生成</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line">aDict = &#123;&#125;</span><br><span class="line">bDict = &#123;<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>, <span class="string">'c'</span>:<span class="number">3</span>&#125;</span><br><span class="line">aDict</span><br><span class="line">bDict</span><br></pre></td></tr></table></figure>
<pre><code>{}
{&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3}
</code></pre><h3 id="更新某个元素"><a href="#更新某个元素" class="headerlink" title="更新某个元素"></a>更新某个元素</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line">phonebook1 = &#123;<span class="string">'ann'</span>:<span class="number">6575</span>, <span class="string">'bob'</span>:<span class="number">8982</span>, <span class="string">'joe'</span>:<span class="number">2598</span>, <span class="string">'zoe'</span>:<span class="number">1225</span>, <span class="string">'ann'</span>:<span class="number">6585</span>&#125;</span><br><span class="line"></span><br><span class="line">phonebook1[<span class="string">'joe'</span>]</span><br><span class="line">phonebook1[<span class="string">'joe'</span>] = <span class="number">5802</span></span><br><span class="line">phonebook1</span><br><span class="line">phonebook1[<span class="string">'joe'</span>]</span><br></pre></td></tr></table></figure>
<pre><code>2598
{&apos;ann&apos;: 6585, &apos;bob&apos;: 8982, &apos;joe&apos;: 5802, &apos;zoe&apos;: 1225}
5802
</code></pre><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line">phonebook1 = &#123;<span class="string">'ann'</span>:<span class="number">6575</span>, <span class="string">'bob'</span>:<span class="number">8982</span>, <span class="string">'joe'</span>:<span class="number">2598</span>, <span class="string">'zoe'</span>:<span class="number">1225</span>, <span class="string">'ann'</span>:<span class="number">6585</span>&#125;</span><br><span class="line">phonebook2 = &#123;<span class="string">'john'</span>:<span class="number">9876</span>, <span class="string">'mike'</span>:<span class="number">5603</span>, <span class="string">'stan'</span>:<span class="number">6898</span>, <span class="string">'eric'</span>:<span class="number">7898</span>&#125;</span><br><span class="line"></span><br><span class="line">phonebook1.update(phonebook2)</span><br><span class="line">phonebook1</span><br></pre></td></tr></table></figure>
<pre><code>{&apos;ann&apos;: 6585,
 &apos;bob&apos;: 8982,
 &apos;joe&apos;: 2598,
 &apos;zoe&apos;: 1225,
 &apos;john&apos;: 9876,
 &apos;mike&apos;: 5603,
 &apos;stan&apos;: 6898,
 &apos;eric&apos;: 7898}
</code></pre><h3 id="删除某个元素"><a href="#删除某个元素" class="headerlink" title="删除某个元素"></a>删除某个元素</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line">phonebook1 = &#123;<span class="string">'ann'</span>:<span class="number">6575</span>, <span class="string">'bob'</span>:<span class="number">8982</span>, <span class="string">'joe'</span>:<span class="number">2598</span>, <span class="string">'zoe'</span>:<span class="number">1225</span>, <span class="string">'ann'</span>:<span class="number">6585</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> phonebook1[<span class="string">'ann'</span>]</span><br><span class="line">phonebook1</span><br></pre></td></tr></table></figure>
<pre><code>{&apos;bob&apos;: 8982, &apos;joe&apos;: 2598, &apos;zoe&apos;: 1225}
</code></pre><h3 id="逻辑操作符-2"><a href="#逻辑操作符-2" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">phonebook1 = &#123;<span class="string">'ann'</span>:<span class="number">6575</span>, <span class="string">'bob'</span>:<span class="number">8982</span>, <span class="string">'joe'</span>:<span class="number">2598</span>, <span class="string">'zoe'</span>:<span class="number">1225</span>, <span class="string">'ann'</span>:<span class="number">6585</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">'ann'</span> <span class="keyword">in</span> phonebook1</span><br><span class="line"></span><br><span class="line">phonebook1.keys()</span><br><span class="line"><span class="string">'stan'</span> <span class="keyword">in</span> phonebook1.keys()</span><br><span class="line"></span><br><span class="line">phonebook1.values()</span><br><span class="line"><span class="number">1225</span> <span class="keyword">in</span> phonebook1.values()</span><br><span class="line"></span><br><span class="line">phonebook1.items()</span><br><span class="line">(<span class="string">'stan'</span>, <span class="number">6898</span>) <span class="keyword">in</span> phonebook1.items()</span><br></pre></td></tr></table></figure>
<pre><code>True
dict_keys([&apos;ann&apos;, &apos;bob&apos;, &apos;joe&apos;, &apos;zoe&apos;])
False
dict_values([6585, 8982, 2598, 1225])
True
dict_items([(&apos;ann&apos;, 6585), (&apos;bob&apos;, 8982), (&apos;joe&apos;, 2598), (&apos;zoe&apos;, 1225)])
False
</code></pre><h3 id="可用来操作的内建函数"><a href="#可用来操作的内建函数" class="headerlink" title="可用来操作的内建函数"></a>可用来操作的内建函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line">phonebook1 = &#123;<span class="string">'ann'</span>:<span class="number">6575</span>, <span class="string">'bob'</span>:<span class="number">8982</span>, <span class="string">'joe'</span>:<span class="number">2598</span>, <span class="string">'zoe'</span>:<span class="number">1225</span>, <span class="string">'ann'</span>:<span class="number">6585</span>&#125;</span><br><span class="line">phonebook2 = &#123;<span class="string">'john'</span>:<span class="number">9876</span>, <span class="string">'mike'</span>:<span class="number">5603</span>, <span class="string">'stan'</span>:<span class="number">6898</span>, <span class="string">'eric'</span>:<span class="number">7898</span>&#125;</span><br><span class="line">phonebook1.update(phonebook2)</span><br><span class="line"></span><br><span class="line">len(phonebook1)</span><br><span class="line">max(phonebook1)</span><br><span class="line">min(phonebook1)</span><br><span class="line">list(phonebook1)</span><br><span class="line">tuple(phonebook1)</span><br><span class="line">set(phonebook1)</span><br><span class="line">sorted(phonebook1)</span><br><span class="line">sorted(phonebook1, reverse=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<pre><code>8
&apos;zoe&apos;
&apos;ann&apos;
[&apos;ann&apos;, &apos;bob&apos;, &apos;joe&apos;, &apos;zoe&apos;, &apos;john&apos;, &apos;mike&apos;, &apos;stan&apos;, &apos;eric&apos;]
(&apos;ann&apos;, &apos;bob&apos;, &apos;joe&apos;, &apos;zoe&apos;, &apos;john&apos;, &apos;mike&apos;, &apos;stan&apos;, &apos;eric&apos;)
{&apos;ann&apos;, &apos;bob&apos;, &apos;eric&apos;, &apos;joe&apos;, &apos;john&apos;, &apos;mike&apos;, &apos;stan&apos;, &apos;zoe&apos;}
[&apos;ann&apos;, &apos;bob&apos;, &apos;eric&apos;, &apos;joe&apos;, &apos;john&apos;, &apos;mike&apos;, &apos;stan&apos;, &apos;zoe&apos;]
[&apos;zoe&apos;, &apos;stan&apos;, &apos;mike&apos;, &apos;john&apos;, &apos;joe&apos;, &apos;eric&apos;, &apos;bob&apos;, &apos;ann&apos;]
</code></pre><h3 id="常用-Methods"><a href="#常用-Methods" class="headerlink" title="常用 Methods"></a>常用 Methods</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line">phonebook1 = &#123;<span class="string">'ann'</span>:<span class="number">6575</span>, <span class="string">'bob'</span>:<span class="number">8982</span>, <span class="string">'joe'</span>:<span class="number">2598</span>, <span class="string">'zoe'</span>:<span class="number">1225</span>, <span class="string">'ann'</span>:<span class="number">6585</span>&#125;</span><br><span class="line">phonebook2 = &#123;<span class="string">'john'</span>:<span class="number">9876</span>, <span class="string">'mike'</span>:<span class="number">5603</span>, <span class="string">'stan'</span>:<span class="number">6898</span>, <span class="string">'eric'</span>:<span class="number">7898</span>&#125;</span><br><span class="line"></span><br><span class="line">phonebook3 = phonebook2.copy()</span><br><span class="line">phonebook3</span><br><span class="line"></span><br><span class="line">phonebook3.clear()</span><br><span class="line">phonebook3</span><br><span class="line"></span><br><span class="line">phonebook2                      <span class="comment"># .copy() 的 “原件” 不会发生变化</span></span><br><span class="line"></span><br><span class="line">p = phonebook1.popitem()</span><br><span class="line">p</span><br><span class="line">phonebook1</span><br><span class="line"></span><br><span class="line">p = phonebook1.pop(<span class="string">'adam'</span>, <span class="number">3538</span>)</span><br><span class="line">p</span><br><span class="line">phonebook1</span><br><span class="line"></span><br><span class="line">p = phonebook1.get(<span class="string">'adam'</span>, <span class="number">3538</span>)</span><br><span class="line">p</span><br><span class="line">phonebook1</span><br><span class="line"></span><br><span class="line">p = phonebook1.setdefault(<span class="string">'adam'</span>, <span class="number">3538</span>)</span><br><span class="line">p</span><br><span class="line">phonebook1</span><br></pre></td></tr></table></figure>
<pre><code>{&apos;john&apos;: 9876, &apos;mike&apos;: 5603, &apos;stan&apos;: 6898, &apos;eric&apos;: 7898}
{}
{&apos;john&apos;: 9876, &apos;mike&apos;: 5603, &apos;stan&apos;: 6898, &apos;eric&apos;: 7898}
(&apos;zoe&apos;, 1225)
{&apos;ann&apos;: 6585, &apos;bob&apos;: 8982, &apos;joe&apos;: 2598}
3538
{&apos;ann&apos;: 6585, &apos;bob&apos;: 8982, &apos;joe&apos;: 2598}
3538
{&apos;ann&apos;: 6585, &apos;bob&apos;: 8982, &apos;joe&apos;: 2598}
3538
{&apos;ann&apos;: 6585, &apos;bob&apos;: 8982, &apos;joe&apos;: 2598, &apos;adam&apos;: 3538}
</code></pre><h2 id="迭代各种容器中的元素"><a href="#迭代各种容器中的元素" class="headerlink" title="迭代各种容器中的元素"></a>迭代各种容器中的元素</h2><p>我们总是有这样的需求：对容器中的元素逐一进行处理（运算）。这样的时候，我们就用 <code>for</code> 循环去迭代它们。</p>
<p>对于迭代 <code>range()</code> 和 <code>list</code> 中的元素我们已经很习惯了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<pre><code>0
1
2
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<pre><code>1
2
3
</code></pre><h3 id="迭代的同时获取索引"><a href="#迭代的同时获取索引" class="headerlink" title="迭代的同时获取索引"></a>迭代的同时获取索引</h3><p>有时，我们想同时得到有序容器中的元素及其索引，那么可以调用 <code>enumerate()</code> 函数来帮我们：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'Python'</span></span><br><span class="line"><span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(s):</span><br><span class="line">    print(i, c)</span><br></pre></td></tr></table></figure>
<pre><code>0 P
1 y
2 t
3 h
4 o
5 n
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(range(<span class="number">3</span>)):</span><br><span class="line">    print(i, v)</span><br></pre></td></tr></table></figure>
<pre><code>0 0
1 1
2 2
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="string">'ann'</span>, <span class="string">'bob'</span>, <span class="string">'joe'</span>, <span class="string">'john'</span>, <span class="string">'mike'</span>]</span><br><span class="line"><span class="keyword">for</span> i, L <span class="keyword">in</span> enumerate(L):</span><br><span class="line">    print(i, L)</span><br></pre></td></tr></table></figure>
<pre><code>0 ann
1 bob
2 joe
3 john
4 mike
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="string">'ann'</span>, <span class="string">'bob'</span>, <span class="string">'joe'</span>, <span class="string">'john'</span>, <span class="string">'mike'</span>)</span><br><span class="line"><span class="keyword">for</span> i, t <span class="keyword">in</span> enumerate(t):</span><br><span class="line">    print(i, t)</span><br></pre></td></tr></table></figure>
<pre><code>0 ann
1 bob
2 joe
3 john
4 mike
</code></pre><h3 id="迭代前排序"><a href="#迭代前排序" class="headerlink" title="迭代前排序"></a>迭代前排序</h3><p>可以用 <code>sorted()</code> 和 <code>reversed()</code> 在迭代前先排好序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="string">'bob'</span>, <span class="string">'ann'</span>, <span class="string">'john'</span>, <span class="string">'mike'</span>, <span class="string">'joe'</span>)</span><br><span class="line"><span class="keyword">for</span> i, t <span class="keyword">in</span> enumerate(sorted(t)):</span><br><span class="line">    print(i, t)</span><br></pre></td></tr></table></figure>
<pre><code>0 ann
1 bob
2 joe
3 john
4 mike
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="string">'bob'</span>, <span class="string">'ann'</span>, <span class="string">'john'</span>, <span class="string">'mike'</span>, <span class="string">'joe'</span>)</span><br><span class="line"><span class="keyword">for</span> i, t <span class="keyword">in</span> enumerate(sorted(t, reverse=<span class="literal">True</span>)):</span><br><span class="line">    print(i, t)</span><br></pre></td></tr></table></figure>
<pre><code>0 mike
1 john
2 joe
3 bob
4 ann
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="string">'bob'</span>, <span class="string">'ann'</span>, <span class="string">'john'</span>, <span class="string">'mike'</span>, <span class="string">'joe'</span>)</span><br><span class="line"><span class="keyword">for</span> i, t <span class="keyword">in</span> enumerate(reversed(t)):</span><br><span class="line">    print(i, t)</span><br></pre></td></tr></table></figure>
<pre><code>0 joe
1 mike
2 john
3 ann
4 bob
</code></pre><h3 id="同时迭代多个容器"><a href="#同时迭代多个容器" class="headerlink" title="同时迭代多个容器"></a>同时迭代多个容器</h3><p>可以在 <code>zip()</code> 这个函数的帮助下，同时迭代两个或者两个以上的容器中的元素（这样做的前提是，多个容器中的元素数量最好相同）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chars = <span class="string">'abcdefghijklmnopqrstuvwxyz'</span></span><br><span class="line">nums = range(<span class="number">1</span>, <span class="number">27</span>)</span><br><span class="line"><span class="keyword">for</span> c, n <span class="keyword">in</span> zip(chars, nums):</span><br><span class="line">    print(<span class="string">f"Let's assume <span class="subst">&#123;c&#125;</span> represents <span class="subst">&#123;n&#125;</span>."</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Let&apos;s assume a represents 1.
Let&apos;s assume b represents 2.
Let&apos;s assume c represents 3.
Let&apos;s assume d represents 4.
Let&apos;s assume e represents 5.
Let&apos;s assume f represents 6.
Let&apos;s assume g represents 7.
Let&apos;s assume h represents 8.
Let&apos;s assume i represents 9.
Let&apos;s assume j represents 10.
Let&apos;s assume k represents 11.
Let&apos;s assume l represents 12.
Let&apos;s assume m represents 13.
Let&apos;s assume n represents 14.
Let&apos;s assume o represents 15.
Let&apos;s assume p represents 16.
Let&apos;s assume q represents 17.
Let&apos;s assume r represents 18.
Let&apos;s assume s represents 19.
Let&apos;s assume t represents 20.
Let&apos;s assume u represents 21.
Let&apos;s assume v represents 22.
Let&apos;s assume w represents 23.
Let&apos;s assume x represents 24.
Let&apos;s assume y represents 25.
Let&apos;s assume z represents 26.
</code></pre><h3 id="迭代字典中的元素"><a href="#迭代字典中的元素" class="headerlink" title="迭代字典中的元素"></a>迭代字典中的元素</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">phonebook1 = &#123;<span class="string">'ann'</span>:<span class="number">6575</span>, <span class="string">'bob'</span>:<span class="number">8982</span>, <span class="string">'joe'</span>:<span class="number">2598</span>, <span class="string">'zoe'</span>:<span class="number">1225</span>, <span class="string">'ann'</span>:<span class="number">6585</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> phonebook1:</span><br><span class="line">    print(key, phonebook1[key])</span><br></pre></td></tr></table></figure>
<pre><code>ann 6585
bob 8982
joe 2598
zoe 1225
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">phonebook1 = &#123;<span class="string">'ann'</span>:<span class="number">6575</span>, <span class="string">'bob'</span>:<span class="number">8982</span>, <span class="string">'joe'</span>:<span class="number">2598</span>, <span class="string">'zoe'</span>:<span class="number">1225</span>, <span class="string">'ann'</span>:<span class="number">6585</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> phonebook1.items():</span><br><span class="line">    print(key, value)</span><br></pre></td></tr></table></figure>
<pre><code>ann 6585
bob 8982
joe 2598
zoe 1225
</code></pre><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>这一章的内容，只不过是 “多” 而已，一旦逻辑关系理顺，就会觉得很简单。而这一章的开头，已经是最好的总结了。</p>
<p>最后需要补充的，只是两个参考链接，以后有什么搞不明白的地方，去那里翻翻就能找到答案：</p>
<blockquote>
<ul>
<li><a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries" target="_blank" rel="noopener">https://docs.python.org/3/tutorial/datastructures.html#dictionaries</a></li>
<li><a href="https://docs.python.org/3/library/stdtypes.html#typesmapping" target="_blank" rel="noopener">https://docs.python.org/3/library/stdtypes.html#typesmapping</a></li>
</ul>
</blockquote>
<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><p>我们需要处理的数据，一定是很多，所以才必须由计算机帮我们处理 —— 大量的数据保存、读取、写入，需要的就是文件（Files）。在这一章里，我们只介绍最简单的文本文件。</p>
<h2 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h2><p>创建一个文件，最简单的方式就是用 Python 的内建函数 <code>open()</code>。</p>
<p><code>open()</code> 函数的<a href="https://docs.python.org/3/library/functions.html#open" target="_blank" rel="noopener">官方文档</a>很长，以下是个简化版：</p>
<blockquote>
<p><code>open(file, mode=&#39;r&#39;)</code></p>
</blockquote>
<p>第二个参数，<code>mode</code>，默认值是 <code>&#39;r&#39;</code>，可用的 <code>mode</code> 有以下几种：</p>
<table>
<thead>
<tr>
<th>参数字符</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&#39;r&#39;</code></td>
<td>只读模式</td>
</tr>
<tr>
<td><code>&#39;w&#39;</code></td>
<td>写入模式（重建）</td>
</tr>
<tr>
<td><code>&#39;x&#39;</code></td>
<td>排他模式 —— 如果文件已存在则打开失败</td>
</tr>
<tr>
<td><code>&#39;a&#39;</code></td>
<td>追加模式 —— 在已有文件末尾追加</td>
</tr>
<tr>
<td><code>&#39;b&#39;</code></td>
<td>二进制文件模式</td>
</tr>
<tr>
<td><code>&#39;t&#39;</code></td>
<td>文本文件模式（默认）</td>
</tr>
<tr>
<td><code>&#39;+&#39;</code></td>
<td>读写模式（更新）</td>
</tr>
</tbody>
</table>
<p>创建一个新文件，用这样一个语句就可以：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(<span class="string">'/tmp/test-file.txt'</span>, <span class="string">'w'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>&lt;_io.TextIOWrapper name=&apos;/tmp/test-file.txt&apos; mode=&apos;w&apos; encoding=&apos;UTF-8&apos;&gt;
</code></pre><p>当然，更多的时候，我们会把这个函数的返回值，一个所谓的 <a href="https://docs.python.org/3/glossary.html#term-file-object" target="_blank" rel="noopener">file object</a>，保存到一个变量中，以便后面调用这个 file object 的各种 Methods，比如获取文件名 <code>file.name</code>，比如关闭文件 <code>file.close()</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'/tmp/test-file.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line">print(f.name)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<pre><code>/tmp/test-file.txt
</code></pre><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>删除文件，就得调用 <code>os</code> 模块了。删除文件之前，要先确认文件是否存在，否则删除命令会失败。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'/tmp/test-file1.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line">print(f.name)</span><br><span class="line">f.close() <span class="comment">#关闭文件，否则无法删除文件</span></span><br><span class="line"><span class="keyword">if</span> os.path.exists(f.name):</span><br><span class="line">    os.remove(f.name)</span><br><span class="line">    print(<span class="string">f'<span class="subst">&#123;f.name&#125;</span> deleted.'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">f'<span class="subst">&#123;f.name&#125;</span> does not exist.'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>/tmp/test-file1.txt
/tmp/test-file1.txt deleted.
</code></pre><h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><p>创建文件之后，我们可以用 <code>f.write()</code> 把数据写入文件，也可以用 <code>f.read()</code> 读取文件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'/tmp/test-file.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line">f.write(<span class="string">'first line\nsecond line\nthird line\n'</span>)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'/tmp/test-file.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line">s = f.read()</span><br><span class="line">print(s)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<pre><code>first line
second line
third line
</code></pre><p>文件有很多行的时候，我们可以用 <code>file.readline()</code> 操作，这个 Method 每次调用，都会返回文件中的新一行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'/tmp/test-file.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line">f.write(<span class="string">'first line\nsecond line\nthird line\n'</span>)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'/tmp/test-file.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line">s = f.readline()    <span class="comment"># 返回的是 'first line\n'</span></span><br><span class="line">print(s)</span><br><span class="line">s = f.readline()    <span class="comment"># 返回的是 'second line\n'</span></span><br><span class="line">print(s)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<pre><code>first line
second line
</code></pre><p><strong>注意</strong>，返回结果好像跟你想的不太一样。这时候，之前见过的 <code>str.strip()</code> 就派上用场了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'/tmp/test-file.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line">f.write(<span class="string">'first line\nsecond line\nthird line\n'</span>)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'/tmp/test-file.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line">s = f.readline().strip()    <span class="comment"># 返回的是 'first line'，'\n' 被去掉了……</span></span><br><span class="line">print(s)</span><br><span class="line">s = f.readline().strip()    <span class="comment"># 返回的是 'second line'，'\n' 被去掉了……</span></span><br><span class="line">print(s)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<pre><code>first line
second line
</code></pre><p>与之相对的，我们可以使用 <code>file.readlines()</code> 这个 Method，将文件作为一个列表返回，列表中的每个元素对应着文件中的每一行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'/tmp/test-file.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line">f.write(<span class="string">'first line\nsecond line\nthird line\n'</span>)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'/tmp/test-file.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line">s = f.readlines()    <span class="comment"># 返回的是一个列表，注意，readlines，最后的 's'</span></span><br><span class="line">print(s)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<pre><code>[&apos;first line\n&apos;, &apos;second line\n&apos;, &apos;third line\n&apos;]
</code></pre><p>既然返回的是列表，那么就可以被迭代，逐一访问每一行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'/tmp/test-file.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line">f.write(<span class="string">'first line\nsecond line\nthird line\n'</span>)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'/tmp/test-file.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">    print(line)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<pre><code>first line
second line
third line
</code></pre><p>与之相对的，我们也可以用 <code>file.writelines()</code> 把一个列表写入到一个文件中，按索引顺序（从 0 开始）逐行写入列表的对应元素：：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a_list = [<span class="string">'first line\n'</span>, <span class="string">'second line\n'</span>, <span class="string">'third line\n'</span>]</span><br><span class="line">f = open(<span class="string">'/tmp/test-file.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line">f.writelines(a_list)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'/tmp/test-file.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">    print(line)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<pre><code>first line
second line
third line
</code></pre><h2 id="with-语句块"><a href="#with-语句块" class="headerlink" title="with 语句块"></a>with 语句块</h2><p>针对文件操作，Python 有个另外的语句块写法，更便于阅读：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(...) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(...)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>这样，就可以把针对当前以特定模式打开的某个文件的各种操作都写入同一个语句块了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'/tmp/test-file.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">'first line\nsecond line\nthird line\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'/tmp/test-file.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">        print(line)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> os.path.exists(f.name):</span><br><span class="line">    os.remove(f.name)</span><br><span class="line">    print(<span class="string">f'<span class="subst">&#123;f.name&#125;</span> deleted.'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">f'<span class="subst">&#123;f.name&#125;</span> does not exist.'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>first line
second line
third line
test-file.txt deleted.
</code></pre><p>另外，用 <code>with</code> 语句块的另外一个附加好处就是不用写 <code>file.close()</code> 了……</p>
<h2 id="另一个完整的程序"><a href="#另一个完整的程序" class="headerlink" title="另一个完整的程序"></a>另一个完整的程序</h2><p>若干年前，我在写某本书的时候，需要一个例子 —— 用来说明 “<strong>即便是结论正确，论证过程乱七八糟也不行！</strong>”</p>
<p>作者就是这样，主要任务之一就是给论点找例子找论据。找得到不仅<em>恰当</em>且又<em>精彩</em>的例子和论据的，就是好作者。后面这个 “<em>精彩</em>” 二字要耗费很多时间精力，因为它意味着说 “要找到<em>很多</em>例子而后在里面选出<em>最精彩</em>的那个！” —— 根本不像很多人以为的那样，是所谓的 “信手拈来”。</p>
<p>找了很多例子都不满意…… 终于有一天，我看到这么个说法：</p>
<blockquote>
<p>如果把字母 <code>a</code> 计为 <code>1</code>、<code>b</code> 计为 <code>2</code>、<code>c</code> 计为 <code>3</code> …… <code>z</code> 计为 <code>26</code>，那么：</p>
<ul>
<li>knowledge = 96</li>
<li>hardwork = 98</li>
<li>attitude = 100</li>
</ul>
<p>所以结论是：</p>
<ul>
<li>知识（<em>knowledge</em>）与勤奋（<em>hardwork</em>）固然都很重要；</li>
<li>但是，决定成败的却是态度（<strong>attitude</strong>）！</li>
</ul>
</blockquote>
<p>结论虽然有道理 —— 可这论证过程实在是太过分了罢……</p>
<p>我很高兴，觉得这就是个<em>好例子</em>！并且，加工一下，会让读者觉得很精彩 —— 如果能找到一些按照同样的计算方式能得到 100 的单词，并且还是那种一看就是 “反例” 的单词……</p>
<p>凭直觉，英文单词几十万，如此这般等于 100 的单词岂不是数不胜数？并且，一定会有很多负面意义的单词如此计算也等于 100 罢？然而，这种事情凭直觉是不够的，手工计算又会被累死…… 于是，面对如此荒谬的论证过程，我们竟然 “无话可说”。</p>
<p>幸亏我是会写程序的人。所以，不会 “干着急没办法”，我有能力让计算机帮我把活干了。</p>
<p>很快就搞定了，找到很多很多个如此计算加起来等于 100 的英文单词，其中包括：</p>
<blockquote>
<ul>
<li>connivance（纵容）</li>
<li>coyness（羞怯）</li>
<li>flurry（慌张）</li>
<li>impotence（阳痿）</li>
<li>stress（压力）</li>
<li>tuppence（微不足道的东西）</li>
<li>……</li>
</ul>
</blockquote>
<p>所以，决定成败的可以是 “慌张”（flurry），甚至是 “阳痿”（impotence）？这不明显是胡说八道嘛！</p>
<p>—— 精彩例子制作完毕，我把它放进了书里。</p>
<p>那，具体的过程是什么样的呢？</p>
<p>首先我得找到一个英文单词列表，很全的那种。这事用不着写程序，Google 一下就可以了。我搜索的关键字是 “<a href="https://www.google.com/search?q=english+word+list" target="_blank" rel="noopener">english word list</a>”，很直观吧？然后就找到一个：<a href="https://github.com/dwyl/english-words" target="_blank" rel="noopener">https://github.com/dwyl/english-words</a>；这个链接里有一个 <a href="https://raw.githubusercontent.com/dwyl/english-words/master/words_alpha.txt" target="_blank" rel="noopener">words-alpha.txt</a> 文件，其中包含接近 37,0101 个单词，应该够用了！下载下来用程序处理就可以了！</p>
<p>因为文件里每行一个单词，所以，就让程序打开文件，将文件读入一个列表，而后迭代这个列表，逐一计算那个单词每个字母所代表的数字，并加起来看看是否等于 100？如果是，就将它们输出到屏幕…… 好像不是很难。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'words_alpha.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> file.readlines():</span><br><span class="line">        <span class="keyword">pass</span> <span class="comment"># 先用 pass 占个位，一会儿再写计算过程</span></span><br></pre></td></tr></table></figure>
<p>按照上面那说法，把 <code>a</code> 记为 <code>1</code>，直至把 <code>z</code> 记为 <code>26</code>，这事并不难，因为有 <code>ord()</code> 函数啊 —— 这个函数返回字符的 Unicode 编码：<code>ord(&#39;a&#39;)</code> 的值是 <code>97</code>，那按上面的说法，用 <code>ord(&#39;a&#39;) - 96</code> 就相当于得到了 <code>1</code> 这个数值…… 而 <code>ord(&#39;z&#39;) - 96</code> 就会得到 <code>26</code> 这个数值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ord(<span class="string">'a'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>97
</code></pre><p>那么，计算 <code>&#39;knowledge&#39;</code> 这个字符串的代码很简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">word = <span class="string">'knowledge'</span></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">    sum += ord(char) - <span class="number">96</span></span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure>
<pre><code>96
</code></pre><p>果然，得到的数值等于 <code>96</code> —— 不错。把它写成一个函数罢：<code>sum_of_word(word)</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_of_word</span><span class="params">(word)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">        sum += ord(char) - <span class="number">96</span></span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line"></span><br><span class="line">sum_of_word(<span class="string">'attitude'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>100
</code></pre><p>那让程序就算把几十万行都算一遍也好像很简单了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_of_word</span><span class="params">(word)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">        sum += ord(char) - <span class="number">96</span></span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'words_alpha.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> file.readlines():</span><br><span class="line">        <span class="keyword">if</span> sum_of_word(word) == <span class="number">100</span>:</span><br><span class="line">            print(word)</span><br></pre></td></tr></table></figure>
<pre><code>abstrusenesses
acupuncturist
adenochondrosarcoma
...
worshipability
zeuctocoelomatic
zygapophysis
</code></pre><p>嗯？怎么输出结果跟想得不一样？找到的词怎么都 “奇形怪状” 的…… 而且，输出结果中也没有 <code>attitude</code> 这个词。</p>
<p>插入个中止语句，<code>break</code>，把找到的第一个词中的每个字符和它所对应的值都拿出来看看？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_of_word</span><span class="params">(word)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">        sum += ord(char) - <span class="number">96</span></span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'words_alpha.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> file.readlines():</span><br><span class="line">        <span class="keyword">if</span> sum_of_word(word) == <span class="number">100</span>:</span><br><span class="line">            print(word)</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> word:        <span class="comment"># 把字母和值都打出来，看看对不对？</span></span><br><span class="line">                print(c, ord(c) - <span class="number">96</span>)</span><br><span class="line">            <span class="keyword">break</span>                 <span class="comment"># 找到一个之后就停下来。</span></span><br></pre></td></tr></table></figure>
<pre><code>abstrusenesses

a 1
b 2
s 19
t 20
r 18
u 21
s 19
e 5
n 14
e 5
s 19
s 19
e 5
s 19

 -86
</code></pre><p>怎么有个 <code>-86</code>？！仔细看看输出结果，看到每一行之间都被插入了一个空行，想到应该是从文件里读出的行中，包含 <code>\n</code> 这种换行符…… 如果是那样的话，那么 <code>ord(&#39;\n&#39;) -96</code> 返回的结果是 <code>-86</code> 呢，怪不得找到的词都 “奇形怪状” 的……</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ord(<span class="string">'\n'</span>) <span class="number">-96</span></span><br></pre></td></tr></table></figure>
<pre><code>-86
</code></pre><p>改进一下呗 —— 倒也简单，在计算前把读入字符串前后的空白字符都给删掉就好了，用 <code>str.strip()</code> 就可以了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_of_word</span><span class="params">(word)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">        sum += ord(char) - <span class="number">96</span></span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'words_alpha.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> file.readlines():</span><br><span class="line">        <span class="keyword">if</span> sum_of_word(word.strip()) == <span class="number">100</span>:</span><br><span class="line">            print(word)</span><br></pre></td></tr></table></figure>
<pre><code>abactinally
abatements
abbreviatable
...
zithern
zoogleas
zorgite
</code></pre><p>如果想把符合条件的词保存到一个文件 <code>results.txt</code> 里的话，那么：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_of_word</span><span class="params">(word)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">        sum += ord(char) - <span class="number">96</span></span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'results.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> result:</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'words_alpha.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> file:</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> file.readlines():</span><br><span class="line">            <span class="keyword">if</span> sum_of_word(word.strip()) == <span class="number">100</span>:</span><br><span class="line">                result.write(word)</span><br></pre></td></tr></table></figure>
<p>竟然这么简单就搞定了？！</p>
<p>这 10 行的代码，在几秒钟内从 370,101 个英文单词中找到 3,771 个如此计算等于 100 的词汇。</p>
<p>喝着咖啡翻一翻 <code>results.txt</code>，很快就找到了那些用来做反例格外恰当的词汇。</p>
<p>真无法想象当年的自己若是不懂编程的话现在会是什么样子……</p>
<h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><p>这一章我们介绍了文本文件的基本操作：</p>
<blockquote>
<ul>
<li>打开文件，直接用内建函数，<code>open()</code>，基本模式有 <code>r</code> 和 <code>w</code>；</li>
<li>删除文件，得调用 <code>os</code> 模块，使用 <code>os.remove()</code>，删除文件前最好确认文件确实存在……</li>
<li>读写文件分别有 <code>file.read()</code>、<code>file.write()</code>、<code>file.readline()</code>、<code>file.readlines()</code>、<code>file.writelines()</code>；</li>
<li>可以用 <code>with</code> 把相关操作都放入同一个语句块……</li>
</ul>
</blockquote>
<h1 id="如何从容应对含有过多-“过早引用”-的知识？"><a href="#如何从容应对含有过多-“过早引用”-的知识？" class="headerlink" title="如何从容应对含有过多 “过早引用” 的知识？"></a>如何从容应对含有过多 “过早引用” 的知识？</h1><p>“过早引用”（<a href="https://en.wikipedia.org/wiki/Forward_declaration#id=Forward_reference" target="_blank" rel="noopener">Forward References</a>，另译为 “前置引用”），原本是计算机领域的术语。</p>
<p>在几乎所有的编程语言中，对于变量的使用，都有 “先声明再使用” 的要求。直接使用未声明的变量是被禁止的。Python 中，同样如此。如果在从未给 <code>an_undefined_variable</code> 赋值的情况下，直接调用这个变量，比如，<code>print(an_undefined_variable)</code>，那就会报错：<code>NameError: name &#39;an_undefined_variable&#39; is not defined</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(an_undefined_variable)</span><br></pre></td></tr></table></figure>
<pre><code>---------------------------------------------------------------------------

NameError                                 Traceback (most recent call last)

&lt;ipython-input-1-7e0e1cc14e37&gt; in &lt;module&gt;
----&gt; 1 print(an_undefined_variable)

NameError: name &apos;an_undefined_variable&apos; is not defined
</code></pre><p>充满过早引用的知识结构，在大脑中会构成类似 M.C. Escher 善画的那种 “不可能图形” 那样的 “结构”。</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/four-cones.png?raw=true" alt></p>
<p>在上图中，前三个椎形一般不会造成视觉困惑 —— 尤其是第一个。</p>
<p>若是加上虚线，比如，第二个和第三个，那么由于我们预设虚线表示 “原本应该看不见的部分”，于是，<code>C</code> 点的位置相对于 <code>B</code> 和 <code>D</code> 应该更靠近自己；<code>C&#39;</code> 的位置，相对于 <code>B&#39;</code> 和 <code>D&#39;</code> 应该更远离自己……</p>
<p>然而，在第四个椎形中，由于 <code>B&quot;D&quot;</code> 和 <code>A&quot;C&quot;</code> 都是实线，于是，我们一下子就失去了判断依据，不知道 <code>C&quot;</code> 究竟是离自己更近还是更远？</p>
<p>对一个点的位置困惑，连带着它与其它三个点之间的关系。可若那不是锥体，而是立方体呢？每个点的位置困惑会造成对它与更多点之间的更多联系的困惑…… 若是更多面体呢？</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/2_necker_cubes.png?raw=true" alt></p>
<p>把这些令人困惑的点，比喻成 “过早引用”，你就明白为什么 “很多过早引用” 的知识结构会那么令人困惑，处理起来那么令人疲惫了吧？</p>
<h2 id="过早引用就是无所不在"><a href="#过早引用就是无所不在" class="headerlink" title="过早引用就是无所不在"></a>过早引用就是无所不在</h2><p>可生活、学习、工作，都不是计算机，它们可不管这套，管它是否定义过，管它是否定义清晰，直接甩出来就用的情况比比皆是。</p>
<p>对绝大多数 “不懂事” 的小朋友来说，几乎所有痛苦的根源都来自这里：“懂事” 的定义究竟是怎样的呢？什么样算作懂事，什么样算作不懂事？弄不好，即便整个童年都在揣摩这个事，到最后还是迷迷糊糊。他们的父母，从未想过对孩子说话也好提要求也好，最好 “先声明再使用”，或者即便事先声明过也语焉不详…… 于是，这些可怜的孩子，能做的只有在惶恐中摸索，就好像在黑暗中拼图一样。</p>
<p>可事实上，他们的父母也不容易。因为确实有太多细节，给小朋友讲了也没用，或者讲也讲不清楚，又或者拼命解释清楚了，但小朋友就是听不进去…… 所以，令人恼火的 “过早引用”，有时候真的是只能那样的存在。</p>
<p>谈恋爱的时候也是这样。太多的概念，千真万确地属于过早引用。爱情这东西究竟是什么，刚开始的时候谁都弄不大明白。并且事实证明，身边的绝大多数人跟自己一样迷糊。至于从小说电影里获得的 “知识”，虽然自己看心神愉悦，但几乎肯定给对方带来无穷无尽的烦恼 —— 于对方来说你撒出来的是漫天飞舞的过早引用……</p>
<p>到了工作阶段，技术岗位还相对好一点，其他领域，哪哪儿都是过早引用，并且还隐藏着不可见，搞得人们都弄出了一门玄学，叫做 “潜规则”。</p>
<p>人们岁数越大，交朋友越来越不容易。最简单的解释就是，每个人的历史，对他人来说都构成 “过早引用”。所以，理解万岁？太难了吧，幼儿园、小学的时候，人们之间几乎不需要刻意相互理解，都没觉得有这个必要；中学的时候，相互理解就已经开始出现不同程度的困难了，因为过早引用的积累。大学毕业之后，再工作上几年，不仅相互理解变得越来越困难，还有另外一层更大的压力 —— 生活中要处理的事情越来越多，脑力消耗越来越大，遇到莫名其妙的过早引用，哪儿有心思处理？</p>
<h2 id="不懂也要硬着头皮读完"><a href="#不懂也要硬着头皮读完" class="headerlink" title="不懂也要硬着头皮读完"></a>不懂也要硬着头皮读完</h2><p>这是事实：大多数难以掌握的技能都有这个特点。人们通常用 “学习曲线陡峭” 来形容这类知识，只不过，这种形容只限于形容而已，对学习没有实际的帮助。面对这样的实际情况，有没有一套有效的应对策略呢？</p>
<p>首先是要学会一个重要的技能：</p>
<blockquote>
<p><strong>读不懂也要读完，然后重复很多遍。</strong></p>
</blockquote>
<p>这是最重要的起点。听起来简单，甚至有点莫名其妙 —— 但以后你就会越来越深刻地体会到，这么简单的策略，绝大多数人竟然不懂，也因此吃了很多很多亏。</p>
<p>充满了过早引用的知识结构，就不可能是一遍就读懂的。别说这种信息密度极高的复杂且重要的知识获取了，哪怕你去看一部好电影，也要多刷几遍才能彻底看懂，不是嘛？比如，Quentin Tarantino 导演的 <a href="https://www.imdb.com/title/tt0110912/" target="_blank" rel="noopener">Pulp Fiction (1994)</a>、David Fincher 导演的 <a href="https://www.imdb.com/title/tt0137523/" target="_blank" rel="noopener">Fight Club (1999)</a>、Christopher Nolan 导演的 <a href="https://www.imdb.com/title/tt1375666/" target="_blank" rel="noopener">Inception (2010)</a>、或者 Martin Scorsese 导演的 <a href="https://www.imdb.com/title/tt1130884/" target="_blank" rel="noopener">Shutter Island (2010)</a>……</p>
<p>所以，从一开始就要做好<em>将要重复很多遍</em>的准备，从一开始就要做好<em>第一次只能读懂个大概</em>的准备。</p>
<p>古人说，读书百遍其义自见，道理就在这里了 —— 只不过，他们那时候没有计算机术语可以借用，所以，这道理本身成了 “过早引用”，对那些根本就没有过 “读书百遍” 经历的人，绝对以为那只不过是在忽悠自己……</p>
<p>有经验的读书者，拿来一本书开始自学技能的时候，他会先翻翻目录（Table Of Contents），看看其中有没有自己完全没有接触过的概念；然后再翻翻术语表（Glossary），看看是否可以尽量理解；而后会看看索引（Index），根据页码提示，直接翻到相关页面进一步查找…… 在通读书籍之前，还会看看书后的参考文献（References），看看此书都引用了哪些大牛的书籍，弄不好会顺手多买几本。</p>
<p>这样做，显然是老到 —— 这么做的最大好处是 “尽力消解了大量的过早引用”，为自己减少了极大的理解负担。</p>
<p>所以，第一遍的正经手段是 “<strong>囫囵吞枣</strong>地读完”。</p>
<p>囫囵吞枣从一开始就是贬义词。但在当前这个特殊的情况下，它是最好的策略。那些只习惯于一上来就仔细认真的人，在这里很吃亏，因为他们越是仔细认真，越是容易被各种过早引用搞得灰心丧气；相应地，他们的挫败感积累得越快；到最后弄不好最先放弃的是他们 —— 失败的原因竟然是因为 “太仔细了”……</p>
<p>第一遍囫囵吞枣，用个正面一点的描述，就是 “<em>为探索未知领域先画个潦草的地图</em>”。地图这东西，有总比没有好；虽然说它最好精确，但即便是 “不精确的地图” 也比 “完全没地图” 好一万倍，对吧？更何况，这地图总是可以不断校正的，不是吗？世界上哪个地图不是一点一点校正过来才变成今天这般精确的呢？</p>
<h2 id="磨练-“只字不差”-的能力"><a href="#磨练-“只字不差”-的能力" class="headerlink" title="磨练 “只字不差” 的能力"></a>磨练 “只字不差” 的能力</h2><p>通过阅读习得新技能（尤其是 “尽量只通过阅读习得新技能”），肯定与 “通过阅读获得心灵愉悦” 很不相同。</p>
<p>读个段子、读个小说，读个当前热搜文章，通常情况下不需要 “精读” —— 草草浏览已经足够，顶多对自己特别感兴趣的地方，慢下来仔细看看……</p>
<p>但是，若是为了习得新技能去阅读，就要施展 “<strong>只字不差地阅读</strong>” 这项专门的技能。</p>
<p>对，“只字不差地阅读” 是所有自学能力强的人都会且都经常使用的技能。尤其是当你在阅读一个重要概念的定义之时，你就是这么干的：定义中的每个字都是有用的，每个词的内涵外延都是需要进行推敲的，它是什么，它不是什么，它的内涵外延都是什么，因此，在使用的时候需要注意什么……</p>
<p>很有趣的一个现象是，绝大多数自学能力差的人，都是把一切都当作小说去看，随便看看，粗略看看……</p>
<p>你有没有注意到一个现象，人们在看电影的时候，绝大多数人会错过绝大多数细节；但这好像并不会削减他们的观影体验；并且，他们有能力使用错过了无数细节之后剩下的那些碎片拼接出一个 “完整的故事” —— 当然，通常干脆是 “另一个貌似完整的故事”。于是，当你在跟他们讨论同一个电影的时候，常常像是你们没坐在同一个电影院，看的不是同一个电影似的……</p>
<p>所谓的自学能力差，很可能最重要的坑就在这里：</p>
<blockquote>
<p>每一次学习新技能的时候，很多人只不过是因为做不到只字不差地阅读，于是总是会错过很多细节；于是，最终就好像 “看了另外一个山寨版电影一样”，实际上 “习得了另外一个山寨版技能”……</p>
</blockquote>
<p>在学习 Python 语言的过程中，有个例子可以说明以上的现象。</p>
<p>在 Python 语言中，<code>for</code> 循环可以附加一个 <code>else</code> 部分。你到 Google 上搜索一下 <a href="https://www.google.com/search?q=for+else+python" target="_blank" rel="noopener"><code>for else python</code></a> 就能看到有多少人在 “追问” 这是干什么的？还有另外一些链接，会告诉你 “for… else” 这个 “秘密” 的含义，将其称为 “语法糖” 什么的……</p>
<p>其实，<a href="https://docs.python.org/3/tutorial/controlflow.html#break-and-continue-statements-and-else-clauses-on-loops" target="_blank" rel="noopener">官方教程</a>里写的非常清楚的，并且还给出了一个例子：</p>
<blockquote>
<p>Loop statements may have an else clause; it is executed when the loop terminates through exhaustion of the list (with for) or when the condition becomes false (with while), but not when the loop is terminated by a break statement. This is exemplified by the following loop, which searches for prime numbers:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; &gt;&gt;&gt; <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">10</span>):</span><br><span class="line">&gt; ...     <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">&gt; ...         <span class="keyword">if</span> n % x == <span class="number">0</span>:</span><br><span class="line">&gt; ...             print(n, <span class="string">'equals'</span>, x, <span class="string">'*'</span>, n//x)</span><br><span class="line">&gt; ...             <span class="keyword">break</span></span><br><span class="line">&gt; ...     <span class="keyword">else</span>:</span><br><span class="line">&gt; ...         <span class="comment"># loop fell through without finding a factor</span></span><br><span class="line">&gt; ...         print(n, <span class="string">'is a prime number'</span>)</span><br><span class="line">&gt; ...</span><br><span class="line">&gt; <span class="number">2</span> <span class="keyword">is</span> a prime number</span><br><span class="line">&gt; <span class="number">3</span> <span class="keyword">is</span> a prime number</span><br><span class="line">&gt; <span class="number">4</span> equals <span class="number">2</span> * <span class="number">2</span></span><br><span class="line">&gt; <span class="number">5</span> <span class="keyword">is</span> a prime number</span><br><span class="line">&gt; <span class="number">6</span> equals <span class="number">2</span> * <span class="number">3</span></span><br><span class="line">&gt; <span class="number">7</span> <span class="keyword">is</span> a prime number</span><br><span class="line">&gt; <span class="number">8</span> equals <span class="number">2</span> * <span class="number">4</span></span><br><span class="line">&gt; <span class="number">9</span> equals <span class="number">3</span> * <span class="number">3</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>只有两种情况，</p>
<blockquote>
<ul>
<li>要么干脆就没读过，</li>
<li>要么是读了，却没读到这个细节……</li>
</ul>
</blockquote>
<p>—— 后者更为可怕，跟花了同样的钱看了另外一个残缺版本的电影似的……</p>
<p>为什么说 “只字不差地阅读” 是一项专门的技能呢？你自己试过就知道了。明明你已经刻意让自己慢下来，也刻意揣摩每个字每个词的含义，甚至为了理解正确，做了很多笔记…… 可是，当你再一次 “只字不差地阅读” 的时候，你经常会 “惊讶地发现”，自己竟然有若干处遗漏的地方！对，这就是一种需要多次练习、长期训练才能真正掌握的技能。绝对不像听起来那么简单。</p>
<p>所以，<em>到了第二遍第三遍就必须施展 “只字不差地阅读” 这项专门的技能了</em>，只此一点，你就已然<strong>与众不同</strong>了。</p>
<h2 id="好的记忆力很重要"><a href="#好的记忆力很重要" class="headerlink" title="好的记忆力很重要"></a>好的记忆力很重要</h2><p>“就算读不懂也要读完” 的更高境界，是 “<strong>就算不明白也要先记住</strong>”。</p>
<p>人们普遍讨厌 “死记硬背”…… 不过，说实话，这很肤浅。虽然确实也有 “擅长死记硬背却就是什么都不会的人”，但是，其实有更多记忆力强的人，实际上更可能是 “博闻强识”。</p>
<p>面对 “过早引用” 常见的知识领域，好记忆力是超强加分项。记不清、记不住、甚至干脆忘了 —— 这是自学过程中最耽误事的缺点。尤其在有 “过早引用知识点” 存在的时候，更是如此。</p>
<p>然而，很多人并没有意识到的是，记忆力也是 “一门手艺” 而已。并且，事实上，它是任何时候都可以通过刻意练习加强的 “手艺”。</p>
<p>更为重要的是，记忆力这个东西，有一百种方法去弥补 —— 比如，最明显、最简单的办法就是 “好记性不如烂笔头”……</p>
<p>所以，在绝大多数正常情况下，所谓的 “记不清、记不住、甚至干脆忘了”，都只不过是懒的结果 —— 若是一个人懒，且不肯承认自己懒，又因为不肯承认而已就不去纠正，那…… 那就算了，那就那么活下去罢。</p>
<p>然而，提高对有效知识的记忆力还有另外一个简单实用的方法 —— 而市面上有各种 “快速记忆法”，通常相对于这个方法来看用处并不大。</p>
<p>这个方法就是以下要讲到的 “整理归纳总结” —— <strong>反复做整理归纳总结，记不住才怪呢！</strong></p>
<h2 id="尽快开始整理归纳总结"><a href="#尽快开始整理归纳总结" class="headerlink" title="尽快开始整理归纳总结"></a>尽快开始整理归纳总结</h2><p>从另外一个角度，这类体系的知识书籍，对作者来说，不仅是挑战，还是摆脱不了的负担。</p>
<p>Python 官方网站上的 <a href="https://docs.python.org/3/tutorial/index.html" target="_blank" rel="noopener">The Python Tutorial</a>，是公认的最好的 Python 教材 —— 因为那是 Python 语言的作者 <a href="https://en.wikipedia.org/wiki/Guido_van_Rossum" target="_blank" rel="noopener">Guido van Rossum</a> 写的……</p>
<p>虽然 Guido van Rossum 已经很小心了，但还是没办法在讲解上避免大量的过早引用。他的小心体现在，在目录里就出现过五次 <strong>More</strong>：</p>
<blockquote>
<ul>
<li>More Control Flow Tools</li>
<li>More on Defining Functions</li>
<li>More on Lists</li>
<li>More on Conditions</li>
<li>More on Modules</li>
</ul>
</blockquote>
<p>好几次，他都是先粗略讲过，而后在另外一处再重新深入一遍…… 这显然是一个最尽力的作者了 —— 无论是在创造一个编程语言上，还是在写一本教程上。</p>
<p>然而，即便如此，这本书对任何初学者来说，都很难。当个好作者不容易。</p>
<p>于是，这只能是读者自己的工作了 —— 因为即便是最牛的作者，也只能到这一步了。</p>
<p>第一遍囫囵吞枣之后，马上就要开始 “<strong>总结</strong>、<strong>归纳</strong>、<strong>整理</strong>、<strong>组织</strong> 关键知识点” 的工作。自己动手完成这些工作，是所谓学霸的特点。他们只不过是掌握了这样一个其他人从未想过必须掌握的简单技巧。他们一定有个本子，里面是各种<em>列表</em>、<em>示意图</em>、<em>表格</em> —— 这些都是最常用的知识（概念）整理组织归纳工具，这些工具的用法看起来简单的要死。</p>
<p>这个技巧说出来、看起来都非常简单。然而，也许正因为它看起来如此简单，才被绝大多数人忽略…… 与学霸们相对，绝大多数非学霸都有一模一样的糊弄自己的理由：反正有别人做好的，拿过来用就是了！—— 听起来那么理直气壮……</p>
<p>可实际上，<strong>自己动手做做就知道了</strong> —— 整理、归纳、组织，再次反复，是个相当麻烦的过程。非学霸们自己不动手做的真正原因只不过是：嫌麻烦、怕麻烦。一个字总结，就是，<strong>懒</strong>！可是，谁愿意承认自己懒呢？没有人愿意。于是，都给自己找个冠冕堂皇的理由，比如，上面说的 “反正别人已经做好了，我为什么还要再做一遍呢？” 再比如，“这世界就是懒人推进的！”</p>
<p>久而久之，各种爱面子的说法完美地达成了自我欺骗的效果，最后连自己都信了！于是，身上多了一个明明存在却永远找不到的漏洞 —— <strong>且不自知</strong>。</p>
<p>我在第一次粗略读过整个 <a href="https://docs.python.org/3/tutorial/datastructures.html" target="_blank" rel="noopener">Python Official Tutorial</a> 中的第五章之后，顺手整理了一下 Containers 的概念表格：</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/python-containers.png?raw=true" alt></p>
<p><strong>可这张图错了！</strong></p>
<p>因为我最早 “合理囫囵吞枣” 的时候，<code>Bytes</code> 这种数据类型全部跳过；而后来多轮反复之后继续深入，又去读 <a href="https://docs.python.org/3/reference/datamodel.html" target="_blank" rel="noopener">The Python Language Reference</a> 的第五章 <code>Data Model</code> 之后，<code>发现 Set</code> 也有 Immutable，是 <code>Frozen Set</code>…… 当然，最错的是，整理的过程中，一不小心把 “Ordered” 给弄反了！</p>
<p>于是肯定需要再次整理，若干次改进之后，那张图就变成了下面这个样子：</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/python-containers-final.png?raw=true" alt></p>
<blockquote>
<p>另外，从 Python 3.7 开始，Dictionary 是 insertion ordered 了：<br><br><a href="https://docs.python.org/3/library/collections.html#ordereddict-objects" target="_blank" rel="noopener">https://docs.python.org/3/library/collections.html#ordereddict-objects</a></p>
</blockquote>
<p>这个自己动手的过程其实真的 “很麻烦”，但它实际上是帮助自己强化记忆的过程，并且对自我记忆强化来说，绝对是不可或缺的过程。习惯于自己动手做罢！习惯于自己不断修改罢！</p>
<p>再给你看个善于学习的人的例子：</p>
<blockquote>
<p><a href="https://nvie.com/posts/iterators-vs-generators/" target="_blank" rel="noopener">https://nvie.com/posts/iterators-vs-generators/</a></p>
</blockquote>
<p>作者 Vincent Driessen 在这个帖子里写到：</p>
<blockquote>
<p>I’m writing this post as a pocket reference for later.</p>
</blockquote>
<p>人家随手做个图，都舍不得不精致：</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/iter-relationships.gif?raw=true" alt></p>
<p>自学能力强的人有个特点，就是<strong>不怕麻烦</strong>。小时候经常听到母亲念叨，“怕麻烦！那还活着干嘛啊？活着多麻烦啊！” —— 深刻。</p>
<h2 id="先关注使用再研究原理"><a href="#先关注使用再研究原理" class="headerlink" title="先关注使用再研究原理"></a>先关注使用再研究原理</h2><p>作为人类，我们原本很擅长运用自己并不真正理解的物件、技能、原理、知识的……</p>
<p>三千多年以前，一艘欧洲腓尼基人的商船在贝鲁斯河上航行的时候搁浅了…… 于是，船员们纷纷登上沙滩。饿了怎么办？架火做饭呗。吃完饭，船员们惊讶地发现锅下面的沙地上有很多亮晶晶、闪闪发光的东西！今天的化学知识对当年的他们来说，是那一生不可触摸的 “过早引用”。他们并不懂这个东西的本质、原理，但稍加研究，他们发现的是，锅底沾有他们运输的天然苏打…… 于是，他们的总结是，天然苏打和沙子（我们现在知道沙子中含有石英砂）被火烧，可能会产生这个东西。几经实验，成功了。于是，腓尼基人学会了制做玻璃球，发了大财……</p>
<p>两千五六百年之前，释加牟尼用他的理解以及在那个时代有限的概念详细叙述了打坐的感受 —— 他曾连续打坐 6 年。今天，西方科学家们在深入研究脑科学的时候，发现 <a href="https://en.wikipedia.org/wiki/Meditation" target="_blank" rel="noopener">Meditation</a> 对大脑有特别多的好处…… 这些好处就是好处，与宗教全然没有任何关系的好处。</p>
<blockquote>
<ul>
<li><a href="https://www.washingtonpost.com/news/inspired-life/wp/2015/05/26/harvard-neuroscientist-meditation-not-only-reduces-stress-it-literally-changes-your-brain/" target="_blank" rel="noopener">Harvard neuroscientist: Meditation not only reduces stress, here’s how it changes your brain</a></li>
<li><a href="https://www.psychologytoday.com/us/blog/use-your-mind-change-your-brain/201305/is-your-brain-meditation" target="_blank" rel="noopener">This Is Your Brain on Meditation – The science explaining why you should meditate every day</a></li>
<li><a href="https://news.harvard.edu/gazette/story/2018/04/harvard-researchers-study-how-mindfulness-may-change-the-brain-in-depressed-patients/" target="_blank" rel="noopener">Researchers study how it seems to change the brain in depressed patients</a></li>
<li><a href="https://www.scientificamerican.com/article/meditations-calming-effects-pinpointed-in-brain/" target="_blank" rel="noopener">Meditation’s Calming Effects Pinpointed in the Brain</a></li>
<li><a href="https://www.newscientist.com/article/2149489-different-meditation-types-train-distinct-parts-of-your-brain/" target="_blank" rel="noopener">Different meditation types train distinct parts of your brain</a></li>
</ul>
</blockquote>
<p>你看，我们原本就是可以直接使用自己并不真正理解的物件、技能、原理、知识的！可为什么后来就不行了呢？</p>
<p>或者说，从什么时候开始，我们开始害怕自己并不真正理解的东西，不敢去用，甚至连试都不敢去试了呢？</p>
<p>有一个相当恼人的解释：<strong>上学上坏了</strong>。</p>
<p>学校里教的全都是属于 “先声明再使用” 的知识。反过来，不属于这种体系架构的知识，学校总是回避的 —— 比如，关于投资与交易的课程，从来看不见地球上有哪个义务教育体系把它纳入教学范围。虽然，投资与交易，是每个人都应该掌握、都必须掌握的不可或缺的技能，某种意义上它甚至比数学语文都更重要，然而，学校就是不会真教这样的东西。</p>
<p>而且，现在的人上学的时间越来越长。小学、初中、高中、本科加起来 16 年…… 这么长时间的 “熏陶”，只能给大多数人造成幻觉，严重、深刻，甚至不可磨灭的幻觉，误以为所有的知识都是这种类型…… 可偏偏，这世界上真正有用的、真正必要的知识，几乎全都不是这种类型 —— 颇令人恼火。</p>
<p>现在的你，不一样了 —— 你要跳出来。养成一个习惯：</p>
<blockquote>
<p>不管怎么样，先用起来，反正，研究透原理，不可能马上做到，需要时间漫漫。</p>
</blockquote>
<p>用错了没关系，改正就好。用得不好没关系，用多了就会好。只要开始用起来，理解速度就会加快 —— 实践出真知，不是空话。</p>
<p>有的时候，就是因为没有犯过错，所以不可能有机会改正，于是，就从未做对过。</p>
<h2 id="尊重前人的总结和建议"><a href="#尊重前人的总结和建议" class="headerlink" title="尊重前人的总结和建议"></a>尊重前人的总结和建议</h2><p>生活中，年轻人最常犯的错误就是把那句话当作屁：</p>
<blockquote>
<p>不听老人言，吃亏在眼前。</p>
</blockquote>
<p>对年轻人来讲，老人言确实很讨厌，尤其是与自己当下的感受相左的时候。</p>
<p>然而，这种 “讨厌” 的感觉，更多的时候是陷阱，因为那些老人言只不过是过早引用，所以，在年轻人的脑子里 “无法执行”，“报错为类型错误”……</p>
<p>于是，很多人一不小心就把 “不听老人言” 和 “独立思考” 混淆起来，然后最终自己吃了亏。可尴尬在于，等自己意识到自己吃亏了的时候吧，大量的时间早已飘逝，是为 “无力回天”。</p>
<p>你可以观察到一个现象，学霸（好学生）的特点之一就是 “老师让干啥就干啥”，没废话。</p>
<p>比如，上面告诉你了，“必须自己动手”，那你就从现在开始老老实实地在一切必要的情况下自己动手去 “<strong>总结</strong>、<strong>归纳</strong>、<strong>整理</strong>、<strong>组织</strong> 关键知识点”…… 那你就必然能够学好。但针对这么个建议，你反复在那里问，“为什么呀？”，“有没有更简单的办法啊？”…… 那你就完了，死定了。</p>
<p>学写代码的过程中，有很多重要的东西实际上并不属于 “编程语言范畴”。比如，如何为变量命名、如何组织代码，这些 “规范”，不是违背了就会马上死掉的<a href="#fn1" name="fn1b"><sup>[1]</sup></a>；并且，初来乍到的时候，这些东西看起来就是很啰嗦、很麻烦的…… 然而，这些东西若是不遵守，甚至干脆不了解，那么最终的结果是，你永远不可能写出大项目，永远是小打小闹 —— 至于为什么，可以用那句你最讨厌的话回答你：</p>
<blockquote>
<p>等你长大了就懂了……</p>
</blockquote>
<p>自学编程的好处之一，就是有机会让一个人见识到 “规范”、“建议” 的好处。也有机会让一个人见识到不遵守这些东西会吃怎样的亏（往往是现世报）。</p>
<p>Python 中有一个概念叫 PEP，Python Enhancement Proposals，必须找时间阅读，反复阅读，牢记于心：</p>
<blockquote>
<p><a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0008/</a></p>
</blockquote>
<p>到最后，你会体会到，这不只是编程的事，这种东西背后的思考与体量，对整个人生都有巨大帮助。</p>
<hr>
<p><strong>脚注</strong></p>
<p><a name="fn1">[1]</a>：也可能真的会死…… 请看一篇 2018 年 9 月份的一则新闻，发生在旧金山的事情：<a href="https://www.theregister.co.uk/2018/09/20/developer_work_shooting/" target="_blank" rel="noopener">Developer goes rogue, shoots four colleagues at ERP code maker</a></p>
<p><a href="#fn1b"><small>↑Back to Content↑</small></a></p>
<h1 id="官方教程：The-Python-Tutorial"><a href="#官方教程：The-Python-Tutorial" class="headerlink" title="官方教程：The Python Tutorial"></a>官方教程：The Python Tutorial</h1><p>虽然，第一部分总计七章关于编程内容的编排是非常特别且相当有效的：</p>
<blockquote>
<ul>
<li>它并没有像其它教程那样，从 “Hello world!” 入手；</li>
<li>它也没有使用与市面上所有编程教材一样的内容先后顺序；</li>
<li>它一上来就让你明白了程序的灵魂：布尔运算；</li>
<li>它很快就让你明白有意义的程序其实只有两个核心构成：运算和流程控制；</li>
<li>它让你很快理解函数从另外一个角度看只不过是 “程序员作为用户所使用的产品”；</li>
<li>它让你重点掌握了最初级却最重要的数据类型，字符串；</li>
<li>它让你从容器的角度了解了 Python 中绝大多数 “重要的数据类型”；</li>
<li>最重要的是，它不承诺你 “速成”，但承诺 “领你入门”…… 显然，它做到了。</li>
</ul>
</blockquote>
<p>但是，第一部分的内容核心目标是让你 “<strong>脱盲</strong>” —— 它的作用还做不到让你 “已然学会编程”，它更多是让你从此开始有能力去阅读更多的重要资源，比如，官方的教程和参考。第一部分的内容更像地图上的 “<strong>图例</strong>”，而不是地图本身。</p>
<p>第一部分反复读过之后，最重要的结果就是：</p>
<blockquote>
<p>现在你有能力自己查询官方文档了……</p>
</blockquote>
<p>起码，在此之后，再去阅读 <a href="https://docs.python.org/3/tutorial/index.html" target="_blank" rel="noopener">The Python Tutorial</a>，不那么费力了，最起码，可以靠自己理解绝大多数内容……</p>
<p>在继续阅读本书内容的同时，有空就要反复翻 The Python Tutorial。</p>
<h2 id="官方文档中最重要的链接"><a href="#官方文档中最重要的链接" class="headerlink" title="官方文档中最重要的链接"></a>官方文档中最重要的链接</h2><p>Python 也许是目前所有编程语言中在文档建设（Documenting）方面做得最好的（好像真的不需要在这句话后面加上 “之一”）。Python 社区为了建设完善的文档，甚至有专门的文档制作工具 —— 得益于 Python 社区从一开始就非常重视<a href="https://devguide.python.org/documenting/" target="_blank" rel="noopener">文档规范</a> —— <a href="http://www.sphinx-doc.org/en/master/" target="_blank" rel="noopener">Sphinx</a>。你在网络上最经常看到的计算机类文档，很可能都在这个网站上：<a href="https://readthedocs.org" target="_blank" rel="noopener">Read the Docs</a>……</p>
<p>Python 的官方文档网址是：</p>
<blockquote>
<p><a href="https://docs.python.org/3/" target="_blank" rel="noopener">https://docs.python.org/3/</a></p>
</blockquote>
<p>其中对初学者最重要的两个链接是：</p>
<blockquote>
<ul>
<li><strong><a href="https://docs.python.org/3/tutorial/index.html" target="_blank" rel="noopener">Tutorial</a></strong>: <a href="https://docs.python.org/3/tutorial/index.html" target="_blank" rel="noopener">https://docs.python.org/3/tutorial/index.html</a></li>
<li><strong><a href="https://docs.python.org/3/library/index.html" target="_blank" rel="noopener">Library Reference</a></strong>: <a href="https://docs.python.org/3/library/index.html" target="_blank" rel="noopener">https://docs.python.org/3/library/index.html</a></li>
</ul>
</blockquote>
<p>理论上来讲，只要有了基础的概念，自己反复阅读官方的 The Python Tutorial 是最好的，没什么入门书籍比它更好 —— 因为它的作者是 Python 的作者，那个被称为 “善意独裁者” 的 <a href="https://en.wikipedia.org/wiki/Guido_van_Rossum" target="_blank" rel="noopener">Guido van Rossum</a>。</p>
<p>此人很帅，但更帅的是他的车牌（摘自 Guido van Rossume 的<a href="https://gvanrossum.github.io" target="_blank" rel="noopener">个人主页</a>）：</p>
<p><img data-src="https://gvanrossum.github.io//images/license.jpg?raw=true" alt></p>
<h2 id="为什么一定要阅读官方文档"><a href="#为什么一定要阅读官方文档" class="headerlink" title="为什么一定要阅读官方文档"></a>为什么一定要阅读官方文档</h2><p>买一两本 Python 教程是不可能完整掌握 Python 的 —— 其实，这句话里的 Python 替换成任何一种语言也是一样的。</p>
<p>教程和官方文档的各种属性是非常不一样的，比如，针对读者群，组织方式，语言表达…… 最不一样的地方在 “全面性”。任何一本单独的教程，都不可能像官方文档那样全面。各种单独教程的优势在于，它们更多地针对初学者、入门者设计，但与此同时，在全面性、深入性上做了妥协。</p>
<p>比如，在当前这本书里，不会涉及 <a href="https://docs.python.org/3/library/stdtypes.html#bytes-objects" target="_blank" rel="noopener">Bytes Object</a> —— 并非只有我一个人这么做，著名的 Python 教程《<a href="http://greenteapress.com/thinkpython2/html/index.html" target="_blank" rel="noopener">Think Python: How to Think Like a Computer Scientist</a>》、《<a href="https://linux.die.net/diveintopython/html/toc/index.html" target="_blank" rel="noopener">Dive into Python</a>》等等都没有涉及 Bytes Object 这个话题。</p>
<p>由于官方文档实际上没办法对入门者、初学者过分友好 —— 毕竟，全面、权威、准确才是它更应该做到的事情 —— 所以，很多人在刚开始的时候求助于各类非官方的教材、教程。原本应该是入门以后就理应 “只读官方文档”，或者 “第一查询对象只能是官方文档”，但在很多人那里竟然变成了 “从一开始到最后都在回避官方文档（或者说 ‘最专业的说明文字’）”，这就不好了，真的很吃亏，且自己都无法知道自己究竟吃了多少亏 —— 总以为自己已经学完了，但实际上从一开始就一点都不全面。</p>
<p>请牢记且遵守这个原则：</p>
<blockquote>
<p><strong>第一查询对象只能是官方文档</strong>。</p>
</blockquote>
<p>所以，当我用 Google 查询的时候，经常使用这样的格式：</p>
<blockquote>
<p><code>&lt;queries&gt; site:python.org</code></p>
</blockquote>
<p>有时甚至会指定在哪个目录里搜索：</p>
<blockquote>
<p><code>bytes site:python.org/3/library</code>，你试试这个连接：<a href="https://www.google.com/search?q=byte+site%3Apython.org%2F3%2Flibrary" target="_blank" rel="noopener">bytes site:python.org/3/library</a></p>
</blockquote>
<p>这个原则对任何语言都适用。将来你在学习任何新软件包（库）、语言更新后的新特性、甚至另外一个新语言的时候，都要这么做。所谓的超强自学能力，基本上就是由一些类似这样的小习惯和另外一些特别基础的方法构成的强大能力。</p>
<h2 id="将官方文档拉回本地"><a href="#将官方文档拉回本地" class="headerlink" title="将官方文档拉回本地"></a>将官方文档拉回本地</h2><p>把 The Python Tutorial 拉回本地阅读，可能更为方便，尤其是可以用 Sphinx 重新制作之后，页面左侧可以总是显示完整的目录：</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/local-tutorial.png?raw=true" alt></p>
<p>也可以把这个教程转换成 epub 格式，以便在移动设备上阅读；甚至可以把这些个页面的 <code>.rst</code> 源文件转换成 <code>.ipynb</code> 文件，以便用 Jupyter Lab 浏览时可以直接执行其中的代码……</p>
<p><strong>注意</strong></p>
<blockquote>
<p>此页的 Code Cell 中都是可执行的 bash 命令……</p>
</blockquote>
<p>在此页执行它们对你来说是没意义的 —— 因为它们的执行结果在服务器上；这其中的命令，应该在你本地计算机上的 Terminal 中执行，你才能在本地计算机上获取结果。</p>
<h3 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%%bash</span><br><span class="line"><span class="built_in">which</span> git</span><br><span class="line">git --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有的话就执行以下命令安装 git</span></span><br><span class="line"><span class="comment"># conda install -c anaconda git</span></span><br></pre></td></tr></table></figure>
<h3 id="下载源文件"><a href="#下载源文件" class="headerlink" title="下载源文件"></a>下载源文件</h3><p>The Python Tutorial 的源文件位置在：</p>
<blockquote>
<p><a href="https://github.com/python/cpython/tree/master/Doc/tutorial" target="_blank" rel="noopener">https://github.com/python/cpython/tree/master/Doc/tutorial</a></p>
</blockquote>
<p>repo 地址是：</p>
<blockquote>
<p><a href="https://github.com/python/cpython.git" target="_blank" rel="noopener">https://github.com/python/cpython.git</a></p>
</blockquote>
<p>使用 git 将 repo 下载到 <code>~/Download/</code> 目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%%bash</span><br><span class="line"><span class="built_in">cd</span> ~/Downloads</span><br><span class="line"><span class="comment"># 总计 175M（文件大小随版本变动），所以需要一点时间</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/python/cpython.git</span><br><span class="line"><span class="built_in">cd</span> cpython/Doc/tutorial</span><br><span class="line">ls</span><br></pre></td></tr></table></figure>
<h3 id="安装-rst2ipynb"><a href="#安装-rst2ipynb" class="headerlink" title="安装 rst2ipynb"></a>安装 rst2ipynb</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">%%bash</span><br><span class="line"><span class="comment"># rst2ipynb needs pandoc and notedown...</span></span><br><span class="line"><span class="built_in">which</span> pandoc</span><br><span class="line"><span class="built_in">which</span> notedown</span><br><span class="line"><span class="comment"># 没有这两样东西的话，需要执行下面两行进行安装……</span></span><br><span class="line"><span class="comment"># conda install -c conda-forge pandoc</span></span><br><span class="line"><span class="comment"># conda install -c conda-forge notedown</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># install rst2ipynb</span></span><br><span class="line"><span class="built_in">cd</span> ~/Downloads</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/nthiery/rst-to-ipynb.git</span><br><span class="line"><span class="built_in">cd</span> rst-to-ipynb</span><br><span class="line">pip install .</span><br><span class="line"><span class="built_in">which</span> rst2ipynb</span><br></pre></td></tr></table></figure>
<h3 id="批量转换-rst-至-ipynb"><a href="#批量转换-rst-至-ipynb" class="headerlink" title="批量转换 rst 至 ipynb"></a>批量转换 rst 至 ipynb</h3><p>这个 rst2ipynb 的程序有点讨厌，一次只能处理一个文件…… 下面是一个 bash 程序，其实将来学起来也不难，看着跟 Python 差不多…… 下面的代码执行过后会出现很多 “警告” —— 没关系，文件会正常转换的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">%%bash</span><br><span class="line"><span class="built_in">cd</span> ~/Downloads/cpython/Doc/tutorial/</span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> *.rst</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        rst2ipynb <span class="variable">$f</span> -o <span class="string">"<span class="variable">$&#123;f/%.rst/.ipynb&#125;</span>"</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">mkdir ipynbs</span><br><span class="line">mv *.ipynb ipynbs/</span><br></pre></td></tr></table></figure>
<p>如此这般，你就把 rst 文件都转换成 ipynb 文件，保存在 <code>~/Downloads/cpython/Doc/tutorial/ipynbs/</code> 之中了。随便把它挪到你喜欢的什么地方。用本地的 Jupyterlab 浏览，或者用 <a href="https://nteract.io" target="_blank" rel="noopener">Nteract</a> App 浏览。</p>
<p>如果以后你经常需要批量转换某个目录内的 <code>rst</code> 文件，那就把 bash function 放在 <code>~/.bash_profile</code> 文件里，在最后面追加以下代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> rsti &#123;</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> *.rst</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    rst2ipynb <span class="variable">$f</span> -o <span class="string">"<span class="variable">$&#123;f/%.rst/.ipynb&#125;</span>"</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而后在 Terminal 里执行一遍：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure>
<p>而后，在有 <code>.rst</code> 文件的目录下输入 <code>rsti</code> 执行即可……</p>
<h3 id="用-Sphinx-生成-html-epub-版本"><a href="#用-Sphinx-生成-html-epub-版本" class="headerlink" title="用 Sphinx 生成 html/epub 版本"></a>用 Sphinx 生成 html/epub 版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%%bash</span><br><span class="line"><span class="built_in">which</span> sphinx-quickstart</span><br><span class="line"><span class="comment"># 没有的话就执行下一行：</span></span><br><span class="line"><span class="comment"># conda install -c anaconda sphinx</span></span><br><span class="line">sphinx-quickstart --version</span><br><span class="line">sphinx-quickstart --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<p>生成 html 版本和 epub 版本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">%%bash</span><br><span class="line"><span class="built_in">cd</span> ~/Downloads/cpython/Doc/tutorial/</span><br><span class="line">sphinx-quickstart -q output --sep -p <span class="string">'The Python Tutorial'</span> -a <span class="string">'Guido van Rossum'</span> -r <span class="string">'1.0'</span> -v <span class="string">'1.0'</span> -l <span class="string">'en'</span> --suffix <span class="string">'.rst'</span> --master <span class="string">'index'</span> --ext-autodoc --ext-doctest --ext-intersphinx --ext-todo --ext-coverage --ext-imgmath --ext-mathjax --ext-ifconfig --ext-viewcode --makefile --no-batchfile --no-use-make-mode</span><br><span class="line">cp -f *.rst output/<span class="built_in">source</span>/</span><br><span class="line"><span class="built_in">cd</span> output</span><br><span class="line">make html</span><br><span class="line">make epub</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成的 html 版本应该在 output/build/html 目录下；</span></span><br><span class="line"><span class="comment"># 生成的 epub 版本应该在 output/build/epub 目录下。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sphinx-quickstart -q output \</span></span><br><span class="line"><span class="comment"># --sep \</span></span><br><span class="line"><span class="comment"># -p 'The Python Tutorial' \</span></span><br><span class="line"><span class="comment"># -a 'Guido van Rossum' \</span></span><br><span class="line"><span class="comment"># -v '1.0'</span></span><br><span class="line"><span class="comment"># -r '1.0' \</span></span><br><span class="line"><span class="comment"># -l 'en' \</span></span><br><span class="line"><span class="comment"># --suffix '.rst' \</span></span><br><span class="line"><span class="comment"># --master 'index' \</span></span><br><span class="line"><span class="comment"># --ext-autodoc \</span></span><br><span class="line"><span class="comment"># --ext-doctest \</span></span><br><span class="line"><span class="comment"># --ext-intersphinx \</span></span><br><span class="line"><span class="comment"># --ext-todo \</span></span><br><span class="line"><span class="comment"># --ext-coverage \</span></span><br><span class="line"><span class="comment"># --ext-imgmath \</span></span><br><span class="line"><span class="comment"># --ext-mathjax \</span></span><br><span class="line"><span class="comment"># --ext-ifconfig \</span></span><br><span class="line"><span class="comment"># --ext-viewcode \</span></span><br><span class="line"><span class="comment"># --makefile \</span></span><br><span class="line"><span class="comment"># --no-batchfile \</span></span><br><span class="line"><span class="comment"># --no-use-make-mode</span></span><br></pre></td></tr></table></figure>
<p>用 Sphinx 这样生成的版本，支持本地目录内搜索，也确实比在网站上看更方便一点：</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/search-generated-by-sphinx.png?raw=true" alt></p>
<h3 id="下载已经转换好的版本"><a href="#下载已经转换好的版本" class="headerlink" title="下载已经转换好的版本"></a>下载已经转换好的版本</h3><p>万一有什么情况中间出错又搞不定的话，就直接下载已经转换好的版本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%%bash</span><br><span class="line"><span class="built_in">cd</span> ~/Downloads</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/xiaolai/the-python-tutorial-in-other-formats.git</span><br></pre></td></tr></table></figure>
<h3 id="完整的-Python-Doc-制作"><a href="#完整的-Python-Doc-制作" class="headerlink" title="完整的 Python Doc 制作"></a>完整的 Python Doc 制作</h3><p>其实，Python 的整个文档，已经是做好了制作文件的文档库：</p>
<blockquote>
<p><code>cpython/Doc/Makefile</code></p>
</blockquote>
<p>只不过，将所有文件编译到一个 epub 里，在 iPad 之类的移动设备上打开有点费劲 —— 在我的设备上显示有 7701 页，翻页都要顿一顿……</p>
<p>想要使用这个官方的 <code>Makefile</code> 的话，首先确认自己已经安装过 Sphinx，其次需要补充安装一个包：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install blurb</span><br></pre></td></tr></table></figure>
<p>而后在 Terminal 中转到 Doc 所在目录，执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make html</span><br><span class="line">make epub</span><br></pre></td></tr></table></figure>
<h1 id="笨拙与耐心"><a href="#笨拙与耐心" class="headerlink" title="笨拙与耐心"></a>笨拙与耐心</h1><p>自学的过程，实际上需要拆解为以下四个阶段，虽然它们之间常常有部分重叠：</p>
<blockquote>
<ul>
<li>学</li>
<li>练</li>
<li>用</li>
<li>造</li>
</ul>
</blockquote>
<p>只要识字，就会忍不住阅读；只要感觉上有 “值得学” 的，就会忍不住去学 —— 事实上每个人时时刻刻都在学习，只不过，学习的目标选择与学习的方式以及效率均不相同而已。</p>
<p>绝大多数人从未区分过这几个阶段，也从未研究过这几个阶段分别应该如何对待。这就解释了为什么那么多人虽然总是忍不住阅读，总是忍不住学习，但终其一生都没有真正掌握过像样的技能…… 因为他们在第一个阶段就出错，到了第二个阶段就放弃，第三个阶段是直接跳过去的，总是 “对付着用”，至于第四个阶段么，想都没想过……</p>
<p>第一部分的内容，基本用来展示 “学” 的过程。<strong>学，就需要重复</strong>，甚至很多次重复，尤其是在面对充满了 “过早引用” 现象的知识结构的时候。</p>
<p>反复学，最锻炼的是 “归纳整理” 的能力。而且，最有意思的，这在大多数情况下还是自动发生的 —— 只要你不断重复，你的大脑会在不自主之间把那些已经掌握的知识点与当前尚未掌握的知识点区分开来，前者处理起来轻松容易，甚至可以跳过；后者需要投入更多的注意力去仔细处理…… 在这个过程中，绝大多数的归纳整理工作自动完成了。最后再加上一点 “刻意的、收尾性的归纳总结整理工作” —— 大功告成。</p>
<p>绝大多数人总是希望自己一遍就能学会 —— 于是，注定了失败；而面对注定的失败，却并不知道那与天分、智商全无关系，因为谁都是那样的；于是，默默认定自己没有天分，甚至怀疑自己的智商；于是，默默地离开，希望换个地方验证自己的天分与智商；于是，再次面临注定的失败；于是，一而再再而三地被 “证明” 为天分不够智商不够…… 于是，就变成了那条狗：</p>
<blockquote>
<p>在一项心理学实验中，狗是被测试对象。把狗关进栅栏里；然而那栅栏并不算太高，原本狗一使劲就能跳过去。但狗带着电项圈，只要它被发现有要跳过栅栏的企图，它就会被电击…… 几次尝试之后，狗就放弃了跳出栅栏 —— 虽然它其实能跳过去。更为惊人的结果是，随后把这条狗关进很低的栅栏，甚至是它都不用跳直接就可以跨过去的栅栏，它也老老实实地呆在栅栏里。</p>
</blockquote>
<p>自学是门手艺，编程很大程度上也是一门手艺，掌握它在绝大多数情况下与天分智商全无关系 —— 很多人是在十来岁的时候学会编程的基本技能的。所有的手艺，最基本特征就是：</p>
<blockquote>
<p><strong>主要靠时间</strong></p>
</blockquote>
<p>这就跟你看人们的车技一样，二十年安全驾龄和刚上路的肯定不一样，但这事跟天分、智商真的没什么关系……</p>
<p>到了第二部分，我们终于进入 “用” 的阶段 —— 嗯？“练” 怎么跳过去了？没有，我们的策略是，<strong>以用带练</strong> —— 在不断应用的过程中带动刻意练习。</p>
<p>练和学，是多少有些重合部分的。比如，你可能反复 “学” 了第一部分两三遍，而后就进入了第二部分，开始接触 “用”，在 “用” 的过程中，只要有空，或者只要有需求，你就可能回去 “复习” 一遍第一部分的内容……</p>
<p>无论之前的 “学”，重复了多少遍，一旦开始练，就注定体会到各式各样的笨拙。一会儿漏写了一个引号或者一个括号，一会儿不小心使用了非英文字符的全角符号，要么就是发现自己犯的错误愚蠢且反复发生，比如，语句块起始语句末尾忘了写冒号……</p>
<p>这再正常不过了。</p>
<p>每次自学什么新东西的时候，你就把自己想象成 “再次出生的婴儿” —— 其实每次自学，的的确确都是重生。一旦掌握了一项新的技能，你就不再是从前的那个自己，你是另外一个人了。</p>
<p>看着婴儿蹒跚学步，的确笨拙，但谁会觉得它不可爱呢？</p>
<p>同样的道理，刚开始用一个技能的时候，笨拙其实就是可爱 —— 只不过这时候旁人不再这么觉得而已了，只不过因为你披着一张成年人的皮。然而，你的大脑中正在学习的那一部分，和新生婴儿的大脑没有任何区别。</p>
<p>在第一部分的时候，“练” 的必要其实并不大…… 甚至，因为这是 “<a href="Part.1.F.deal-with-forward-references.md">过早引用</a>” 太多的知识结构，所以，急于练习反倒会有副作用。由于对自己所面对的复杂知识结构（就是过早引用太多的知识结构）认识不够，没有提前的应对策略，所以，他们根据原本的习惯，边学边练，学不明白当然就练不明白，于是，走着走着就挫败感太强，于是，就自然而然地放弃了…… 而且，弄不好，越练越容易出现 “不必要的挫败感”。</p>
<p>一切 “主要靠时间” 的活动都一样，都需要在从事之前认真做 “心理建设”。通常情况下，读一本教程，上个学习班，就 “会” 了 —— 几乎肯定是错觉或者幻觉。</p>
<blockquote>
<ul>
<li>首先要明白，这肯定是个比 “天真的想象” 要长得多的过程。</li>
<li>其次要明白，并且要越来越自然地明白，哪儿哪儿都需要很多重复。读，要读很多遍；练，要练很多遍；做，要做很多遍……</li>
</ul>
</blockquote>
<p>有了这样的心理建设，就相对更容易保持耐心。</p>
<p>人们缺乏耐心的常见根源就是 “之前根本就没准备花那么多时间和精力”，所以当然很容易超出 “时间和精力的预算”，当然相对更容易焦虑 —— 就好像没多少本钱的人做生意常常更容易失败一样。</p>
<p>这也解释了为什么我在写这本书的过程中，心中锁定的目标群体是大一学生和高一学生（甚至也有初一学生）：</p>
<blockquote>
<p>他们最有自学的 “本钱”……</p>
</blockquote>
<p>离开学校之后，绝大多数人很难再有 “一看一下午”、“一练一整天”、“一玩一整夜” 的本钱。又由于生活的压力越来越大，对 “能够使用” 新技能的 “需求” 越来越紧迫，于是，对任何一次自学的 “时间精力投资” 都缩手缩脚，小里小气……</p>
<p><strong>预算观念</strong>非常重要 —— 这个观念的存在与否，成熟与否，基本上决定一个人未来的盈利能力。</p>
<p>大多数人对此不仅不成熟，甚至干脆没有预算观念！—— 这也是为什么绝大多数人不适合创业的最根本原因。</p>
<p>不夸张地讲，未来的你只需要恪守一个原则，就很可能会因此超越 99% 的人：</p>
<blockquote>
<p>绝对不做预算不够的事情。</p>
</blockquote>
<p>说来惭愧，我是四十多岁之后，在创业和投资中经历了大量的失败，付了不可想像的学费之后，才深刻理解这条看起来过分简单的原则 —— 亏得本科还是学会计毕业的呢！我的运气在于，在自学这件事上，从来给出的预算都很多……</p>
<p>大约 1984 年，我在远在边疆的延吉市的本地青少年宫参加了一个要交 10 元学费的暑期计算机兴趣班，老师姓金，教的是 BASIC 语言，用的机器是这样的：</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/Acorn-Electron.png?raw=true" alt></p>
<p>它要外接上一个九寸的单色显示器，那时候还没有磁盘，所以，只要一断电，就什么都没有了……</p>
<p>后来上了大学，买书自学 C++，结果在一个地方被卡住了：</p>
<p>我写的代码死活编译不过去…… 当时的编译器错误提醒还不像今天这么完善，当时也没有什么 Google 可以随时看看网上是否早就有人遇到过跟我一样的问题…… 当时我身边根本就没有什么别人在玩这些东西，当时的学校里的电脑还很少，需要提前申请所谓的 “上机时间”，后来呢？后来就放弃了。</p>
<p>当时是什么东西卡住我了呢？说来都能笑死，或者都能被气死：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (c = <span class="number">1</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>习惯于写 BASIC 的我，“被习惯蒙蔽了双眼”，反复检查那么多遍，完全没看到应该写的是 <code>c == 1</code>！</p>
<p>一晃就好几年过去，有一天在书店看到一本 C++ 教程，想起来多年前放弃的东西，就把书买回来，在家里的电脑上重新玩了起来…… 然后就想起来问题在哪儿了，然后这事就被我重新捡起来了……</p>
<p>学完了也就学完了，真没地儿用。没地儿用，当然就很少练。</p>
<p>又过了好几年，我去新东方教书。2003 年，在写词汇书的过程中，需要统计词频，C++ 倒是用不上，用之前学过它的经验，学了一点 Python，写程序统计词频 ——《TOEFL 核心词汇 21 天突破》到今天还在销售。一个当年 10 块钱学费开始学的技能，就因为这本书，这些年给我 “变现” 了很多钱。</p>
<p>我有很多东西都是这样，隔了好多年，才重新捡起来，而后继续前行的。</p>
<p>最搞笑的是弹吉他。</p>
<p>十五六岁的时候，父亲给我买了一把吉他，理由是：</p>
<blockquote>
<p>你连唱歌都跑调，将来咋学英语啊？</p>
</blockquote>
<p>然后我就开始玩。花 5 块钱上了个培训班，第一天学了一个曲子，第二天就因为打架把吉他砸坏了，害得父亲又去给我买了一把更便宜的……</p>
<p>那个年代学吉他的人，第一首肯定是 “<a href="https://www.youtube.com/results?search_query=Romance+d%27Amour+" target="_blank" rel="noopener">Romance d’Amour</a>”（爱的罗曼史），我当然不例外。那曲子好听啊，好听到弹得不好也好听的地步。</p>
<p>然后吧，有一天，在一姑娘面前显摆，竟然没有弹错！弹完之后很得意…… 结果那姑娘一脸迷茫，隔了两三秒钟说，“不还有第二段吗？” —— 我一脸懵蛋，“…… 啊？”</p>
<p>可是吧，那第二段我终究没有学…… 其实也练过，但后来因为指骨摔断了，所以再后来的许多年，弹吉他只用拨片。直到…… 直到四十五岁那年。有一天，忽然想起这事，于是找来琴谱试了一下，花了一会的时间顺了下来。</p>
<p>所以，我猜我的 “自学能力强” 这件事本身，其实只不过是我投入的预算很多造成的 —— 活到老学到老，在我这里不是空话，所以，相对于别人，我这里只不过是预算太多、太充裕了而已。</p>
<p>于是，我学的时候重复得比别人多；练的时候重复得比别人多；到最后用得也相对比别人多很多 —— 这跟是否有天分或者聪明与否全然没有关系。</p>
<p>当然，学到的东西多了，就变得更聪明了似的。有高中学历的人通常情况下比只有小学学历的人更聪明 —— 其实就是这个原因而已。而这个现象与天生的智商并不总是正相关。</p>
<p>有个现象，不自学的人不知道。</p>
<p>真正开始自学且不断自学之后，刚开始总是觉得时间不够用 —— 因为当时的自己和其他人没什么太大区别。</p>
<p>随着时间的推移，不仅差异会出现，自我认知差异也开始越来越明显：</p>
<blockquote>
<p>别人的时间都白过了，自己的时间都有产出……</p>
</blockquote>
<p>到了下一个阶段，在其他人不断焦虑的情况下，自己却开始越来越淡定：</p>
<blockquote>
<p>因为早已习惯了投入大量时间换取新技能……</p>
</blockquote>
<p>等后来真的开始用这些技能做事，不断地做其他人因为时间白过了或者因为投入的 “预算” 不够而学不会做不到的事情 —— 并且还能充分明白，这并不是自己聪明、有天分的结果；只不过是做了该做的事情，投入了该投入的 “成本” 和 “预算” 而已……</p>
<p>于是，就真的能够理解下面这句话背后的深意：</p>
<blockquote>
<p>人生很长，何必惊慌。</p>
</blockquote>
<p>反正，这事跟天分与智商几乎没有任何关系。</p>
<h1 id="刻意练习"><a href="#刻意练习" class="headerlink" title="刻意练习"></a>刻意练习</h1><p>在自学的过程中，总是有一些部分需要刻意练习。就好像小时候我们学习汉字，有些人总是把 “武” 这个字上加上一个撇 —— 对他们来说，不去写那个不该有的撇，就是需要刻意练习的。另外一些人倒是不在这个字上出错，但候和侯傻傻地分不清楚（类似的例子不计其数），那么，对他们来说就有了另外需要刻意练习的地方……</p>
<p>手艺这个东西，尤其需要刻意练习。我们说，手艺么，主要是靠时间…… 这里的 “时间”，准确地讲，就是 “刻意练习” 的时间，而不是任何时间。</p>
<p>我当过很长时间的英语老师。异常苦于一件事：最有用的道理最没人听。</p>
<p>学英语根本就不应该那么难，学了十六年也学不明白 —— 至于嘛！然而，最简单的道理，人们就是听不进去。他们之所以不行，就是因为从未刻意练习。学英语最简单的刻意练习就是朗读。每天朗读一小时，一百天下来就会超越绝大多数人，也会超越自己原本可能永远跨不过去的那个坎 —— 神奇的是，朗读什么无所谓，反正现在有声书那么多…… 更神奇的是，刚开始朗读得好不好听，甚至好不好都无所谓，反正没几天就能体会到大幅进步…… 最神奇的是，这么简单的事，99.99% 的人不做 —— 你身在中国，能理解这个比例真的没有夸张。</p>
<p>顺带推荐一下王渊源（John Gordan）的微信公众号：</p>
<blockquote>
<p>清晨朗读会</p>
</blockquote>
<p>到 2019 年 2 月 21 日，王渊源同学的清晨朗读会带着大伙朗读了第 1000 天……</p>
<p>许多年前，资质平庸的我，一直苦恼一件事：</p>
<blockquote>
<ul>
<li>为什么自己无论干什么都笨手笨脚、差这儿差那儿的……</li>
<li>为什么与此同时，总是能看到另外一些人，给人感觉 “一出手就是高手” 呢？！</li>
</ul>
</blockquote>
<p>这事折磨了我好多年…… 直到后来我当了老师，每年面前流过几万名学生之后，我才 “羞耻” 地反应过来：</p>
<blockquote>
<ul>
<li>我花在刻意练习上的时间<strong>太少</strong>了；</li>
<li>并且，也没有<strong>刻意思考</strong>哪些地方我应该去刻意练习。</li>
</ul>
</blockquote>
<p>而那些看起来 “一出手就是高手” 的人，则恰恰相反，他们不仅花很多时间刻意练习，还总是刻意思考在哪些地方尤其要刻意练习 —— 就是这一点差别造成了那么大的差距。</p>
<p>比如，小时候玩琴，因为手骨摔断了，于是就中断了很多刻意练习 —— 后来换成拨片之后，也习惯不好，不做很多基础练习，只是顺着感觉 “胡搞瞎搞”…… 于是，我的琴艺永远是自娱自乐也就刚刚够用的水准，永远上不了下一个台阶。我认识的人之中，许岑同学在这方面就是我这种情况的反向典范。</p>
<p>然而，我深刻地意识到，在另外一些地方，若是再 “混” 下去，那这辈子就别想有什么名堂了。所以，我就下决心在必要的地方一定要刻意地练习。印象中我第一个应用这种思考模式与决心的地方就是写书。我花了很长时间去准备第一本书，并且刻意地思考在哪些地方应该刻意地用力 —— 比如，在取书名这件在别人眼里可能并不是很重要的事上，我每天都琢磨，前后换了二十几个名字，最终选定…… 其后每一本出版的书籍，在书名选择上我都 “殚精竭虑” —— 最终的结果是，我的第一本书就是畅销书、长销书 —— 后面的每一本都是。</p>
<p>对，所谓的 “混”，解释很简单：</p>
<blockquote>
<p><strong>不做刻意练习的人就是在混时间</strong>。</p>
</blockquote>
<p>需要刻意练习的地方，因人而异。有的人就是不可能让 “武” 字带把刀，不需要刻意练习，但另外一些人不是。有些人就是朗读十分钟的效果跟别人朗读一小时的效果一样地好，但更多的人并不是……</p>
<p>然而，这并不是所谓的 “天分” 差异，这大抵上只相当于正态分布坐标略不相同而已。每个人都一样，都有各自必须刻意练习的地方，都有对别人来说无比容易可偏偏对自己来说就是很难的地方，而且，在这件事上，大家的点虽然各不相同，但总体上需要刻意练习的部分比例都差不多 —— 虽然说不清楚那个比例到底是多少。</p>
<p>比如，在学一门新的编程语言时，我常常做这样的刻意练习：</p>
<blockquote>
<p><strong>在纸上用笔写程序……</strong></p>
</blockquote>
<p>而后，看着纸上的程序，把自己的大脑当作解析器，去判断每一句执行后的结果……</p>
<p>反复确认之后，再在编辑器里输入这个程序 —— 用很慢的速度，确保自己的输入无误……</p>
<p>然后再一运行，十有八九出错 —— 要再反复检查修改很多次才能顺利执行到最后……</p>
<p>为什么要这么做呢？因为我发现自己一旦学另外一个语言的时候，自己的大脑就会经常把这个新的语言与之前学过的其他语言相混淆，这很痛苦。我必须想出一个办法，让之前的也好，之后的也罢，干脆刻在自己的脑子里，不可能相互混淆。</p>
<p>我相信不是所有人都有我这样的烦恼和痛苦，虽然他们在我不烦恼不痛苦的地方也可能烦恼痛苦……</p>
<p>然而，于我来讲，这就是<strong>我需要刻意练习</strong>的地方 —— 这也是我<strong>刻意思考</strong>之后才找到的需要刻意练习的地方。</p>
<p>你也一样。你需要刻意练习的地方，需要你自己去刻意思考 —— 你和别人不一样，没有人和你一样，就这样。</p>
<p>这种事情，过去还真的是所谓 “书本上学不到” 的东西 —— 因为没有哪个作者能做到 “遍历世上所有人的所有特殊情况”…… 不过，互联网这本大书貌似正在突破这种限制，因为有无数的作者在写书，每个人所关注的点也不一样，再加上搜索引擎，所以，你总是可以在互联网这本大书中找到 “竟然与我一样的人”！</p>
<p>于是，你可能感受到了，其实吧，所谓 “刻意练习”，其实是 “刻意思考哪里需要刻意练习” 之后最自然不过的事情 —— 所以，<strong>“刻意思考” 才是关键。</strong></p>
<p>应对策略很简单：</p>
<blockquote>
<p>准备个专门的地方记录</p>
</blockquote>
<p>我现在用的最多的就是 iPhone 上的 Notes，一旦遇到什么 “疑似需要刻意练习” 的点，就顺手记录在那里以防不小心忘记或者不小心遗漏。</p>
<p>而后有时间的时候就拿出来看看，排列一下优先级，琢磨一下刻意练习的方式，而后找时间刻意练习，如此这般，做到 “尽量不混日子”……</p>
<p>有时候，刻意练习是很容易的，比如，为了让自己记住当前正在学习的编程语言的语法规则，直至 “刻在脑子里一般”，需要做的无非是把编辑器中的 “Auto completion”（自动补全）先关掉三个月 —— 麻烦一点就麻烦一点，坚决不让 Tab 键帮自己哗啦哗啦写上一大片…… 那不叫麻烦，那叫刻意练习。</p>
<p>人们常说：</p>
<blockquote>
<p>凡事，就怕<strong>琢磨</strong>……</p>
</blockquote>
<p>那些高手，无一例外都是善于琢磨的人…… 可是，他们在琢磨什么呢？为什么他们会琢磨那些事呢？</p>
<p>你看，所谓的琢磨，其实真的不是很难，只不过，在此之前，你不知道该琢磨什么而已，一旦知道了，剩下的都再自然不过，都会自然而然地发生 —— 事实上，所谓的差别差距，只不过一线间而已。</p>
<h1 id="为什么从函数开始？"><a href="#为什么从函数开始？" class="headerlink" title="为什么从函数开始？"></a>为什么从函数开始？</h1><p>读完第一部分之后，你多多少少已经 “写” 了一些程序，虽然我们总是说，“这就是让你脱盲”；也就是说，从此之后，你多多少少能够读懂程序，这就已经很好了。</p>
<p>可是你无论如何都避免不了已经写了一些，虽然，那所谓的 “写”，不过是 “改” 而已 —— 但毕竟也是一大步。</p>
<p>绝大多数编程书籍并不区分学习者的 “读” 与 “写” 这两个实际上应该分离的阶段 —— 虽然现实中这两个阶段总是多多少少重叠一部分。</p>
<p>在一个比较自然的过程中，我们总是先学会阅读，而后才开始练习写作；并且，最终，阅读的量一定远远大于写作的量 —— 即，输入远远大于输出。当然，貌似也有例外。据说，香港作家倪匡，他自己后来很少读书，每天咣当咣当地像是打扫陈年旧物倒垃圾一样写作 —— 他几乎是全球最具产量的畅销小说作家，貌似地球另外一端的史蒂芬・金都不如他多。又当然，他的主要输入来自于他早年丰富的人生经历，人家读书，他阅世，所以，实际上并不是输入很少，恰恰相反，是输入太多……</p>
<p>所以，正常情况下，输入多于输出，或者，输入远远多于输出，不仅是自然现象，也是无法改变的规则。</p>
<p>于是，我在安排内容的时候，也刻意如此安排。</p>
<p>第一部分，主要在于启动读者在编程领域中的 “阅读能力”，到第二部分，才开始逐步启动读者在编程领域中的 “写作能力”。</p>
<p>在第二部分启动之前，有时间有耐心的读者可以多做一件事情。</p>
<p>Python 的代码是开源的，它的代码仓库在 Github 上：</p>
<blockquote>
<p><a href="https://github.com/python/" target="_blank" rel="noopener">https://github.com/python/</a></p>
</blockquote>
<p>在这个代码仓库中，有一个目录下，保存着若干 Python Demo 程序：</p>
<blockquote>
<p><a href="https://github.com/python/cpython/tree/master/Tools/demo" target="_blank" rel="noopener">https://github.com/python/cpython/tree/master/Tools/demo</a></p>
</blockquote>
<p>这个目录下的 README 中有说明：</p>
<blockquote>
<p>This directory contains a collection of demonstration scripts for<br>various aspects of Python programming.</p>
<ul>
<li><code>beer.py</code>        Well-known programming example: Bottles of beer.</li>
<li><code>eiffel.py</code>      Python advanced magic: A metaclass for Eiffel post/preconditions.</li>
<li><code>hanoi.py</code>       Well-known programming example: Towers of Hanoi.</li>
<li><code>life.py</code>        Curses programming: Simple game-of-life.</li>
<li><code>markov.py</code>      Algorithms: Markov chain simulation.</li>
<li><code>mcast.py</code>       Network programming: Send and receive UDP multicast packets.</li>
<li><code>queens.py</code>      Well-known programming example: N-Queens problem.</li>
<li><code>redemo.py</code>      Regular Expressions: GUI script to test regexes.</li>
<li><code>rpython.py</code>     Network programming: Small client for remote code execution.</li>
<li><code>rpythond.py</code>    Network programming: Small server for remote code execution.</li>
<li><code>sortvisu.py</code>    GUI programming: Visualization of different sort algorithms.</li>
<li><code>ss1.py</code>         GUI/Application programming: A simple spreadsheet application.</li>
<li><code>vector.py</code>      Python basics: A vector class with demonstrating special methods.</li>
</ul>
</blockquote>
<p>最起码把这其中的以下几个程序都精读一下，看看自己的理解能力：</p>
<blockquote>
<ul>
<li><a href="https://github.com/python/cpython/blob/master/Tools/demo/beer.py" target="_blank" rel="noopener">beer.py</a>        Well-known programming example: Bottles of beer.</li>
<li><a href="https://github.com/python/cpython/blob/master/Tools/demo/eiffel.py" target="_blank" rel="noopener">eiffel.py</a>      Python advanced magic: A metaclass for Eiffel post/preconditions.</li>
<li><a href="https://github.com/python/cpython/blob/master/Tools/demo/hanoi.py" target="_blank" rel="noopener">hanoi.py</a>       Well-known programming example: Towers of Hanoi.</li>
<li><a href="https://github.com/python/cpython/blob/master/Tools/demo/life.py" target="_blank" rel="noopener">life.py</a>        Curses programming: Simple game-of-life.</li>
<li><a href="https://github.com/python/cpython/blob/master/Tools/demo/markov.py" target="_blank" rel="noopener">markov.py</a>      Algorithms: Markov chain simulation.</li>
<li><a href="https://github.com/python/cpython/blob/master/Tools/demo/queens.py" target="_blank" rel="noopener">queens.py</a>      Well-known programming example: N-Queens problem.</li>
</ul>
</blockquote>
<p>就算读不懂也没关系，把读不懂的部分标记下来，接下来就可以 “带着问题学习”……</p>
<p>在未来的时间里，一个好的习惯就是，有空了去读读别人写的代码 —— 理解能力的提高，就靠这个了。你会发现这事跟其他领域的学习没什么区别。你学英语也一样，读多了，自然就读得快了，理解得快了，并且在那过程中自然而然地习得了很多 “句式”，甚至很多 “说理的方法”、“讲故事的策略”…… 然后就自然而然地会写了，从能写一点开始，慢慢到 “很能写”！</p>
<p>为了顺利启动第一部分的 “阅读”，特意找了个不一样的入口，“布尔运算”；第二部分，从 “阅读” 过渡到 “写作”，我也同样特意寻找了一个不一样的入口：<strong>从函数开始写起</strong>。</p>
<p>从小入手，从来都是自学的好方法。我们没有想着一上来就写程序，而是写 “子程序”、“小程序”、“短程序”。从结构化编程的角度来看，写函数的一个基本要求就是：</p>
<blockquote>
<ul>
<li>完成一个功能；</li>
<li>只完成一个功能；</li>
<li>没有任何错误地只完成一个功能……</li>
</ul>
</blockquote>
<p>然而，即便是从小入手，任务也没有变得过分简单。其中涉及的话题理解起来并不容易，尽管我们尽量用最简单的例子。涉及的话题有：</p>
<blockquote>
<ul>
<li>参数的传递</li>
<li>多参数的传递</li>
<li>匿名函数以及函数的别称</li>
<li>递归函数</li>
<li>函数文档</li>
<li>模块</li>
<li>测试驱动编程</li>
<li>可执行程序</li>
</ul>
</blockquote>
<p>这些都是你未来写自己的工程时所必须仰仗的基础，马虎不得，疏漏不得。</p>
<p>另外，这一部分与第一部分有一个刻意不同的编排，这一部分的每一章之后，<strong>没有写总结</strong> —— 那个总结需要读者自己动手完成。你需要做的不仅仅是每一个章节的总结，整个第二部分读完之后，还要做针对整个 “深入了解函数”（甚至应该包括第一部分已经读过的关于函数的内容）的总结…… 并且，关于函数，这一章并未完全讲完呢，第三部分还有生成器、迭代器、以及装饰器要补充 —— 因为它们多多少少都涉及到下一部分才能深入的内容，所以，在这一部分就暂时没有涉及。</p>
<p>你要习惯，归纳、总结、整理的工作，从来都不是一次就能完成的，都需要反复多次之后才能彻底完成。必须习惯这种流程 —— 而不是像那些从未自学过的人一样，对这种东西想当然地全不了解。</p>
<p>另外，从现代编程方法论来看，“写作” 部分一上来就从函数入手也的确是 “更正确” 的，因为结构化编程的核心就是拆分任务，把任务拆分到不能再拆分为止 —— 什么时候不能再拆分了呢？就是当一个函数只完成一个功能的时候……</p>
<h1 id="关于参数（上）"><a href="#关于参数（上）" class="headerlink" title="关于参数（上）"></a>关于参数（上）</h1><p>之前就提到过，从结构上来看，每个函数都是一个完整的程序，因为一个程序，核心构成部分就是输入、处理、输出：</p>
<blockquote>
<ul>
<li>它可以有<strong>输入</strong> —— 即，它能接收外部通过参数传递的值；</li>
<li>它可以有<strong>处理</strong> —— 即，内部有能够完成某一特定任务的代码；尤其是，它可以根据 “输入” 得到 “输出”；</li>
<li>它可以有<strong>输出</strong> —— 即，它能向外部输送返回值……</li>
</ul>
</blockquote>
<p>所以，在我看来，有了一点基础知识之后，最早应该学习的是 “如何写函数” —— 这个起点会更好一些。</p>
<p>这一章的内容，看起来会感觉与 <a href="Part.1.E.4.functions.md">Part1.E.4 函数那一章</a>部分重合。但这两章的出发点不一样：</p>
<blockquote>
<ul>
<li><a href="Part.1.E.4.functions.md">Part1.E.4 函数那一章</a>，只是为了让读者有 “阅读” 函数说明文档的能力；</li>
<li>这一章，是为了让读者能够开始动手写函数给自己或别人用……</li>
</ul>
</blockquote>
<h2 id="为函数取名"><a href="#为函数取名" class="headerlink" title="为函数取名"></a>为函数取名</h2><p>哪怕一个函数内部什么都不干，它也得有个名字，然后名字后面要加上圆括号 <code>()</code>，以明示它是个函数，而不是某个变量。</p>
<p>定义一个函数的关键字是 <code>def</code>，以下代码定义了一个什么都不干的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_nothing</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">do_nothing()</span><br></pre></td></tr></table></figure>
<p>为函数取名（为变量取名也一样）有些基本的注意事项：</p>
<blockquote>
<ul>
<li><p>首先，名称不能以数字开头。能用在名称开头的有，大小写字母和下划线 <code>_</code>；</p>
</li>
<li><p>其次，名称中不能有空格，要么使用下划线连接词汇，如，<code>do_nothing</code>，要么使用 <a href="https://en.wikipedia.org/wiki/Camel_case" target="_blank" rel="noopener">Camel Case</a>，如 <code>doNothing</code> —— 更推荐使用下划线；</p>
</li>
<li><p>再次，名称不能与关键字重合 —— 以下是 Python 的 Keyword List：</p>
</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>-</th>
<th>Python</th>
<th>Keyword</th>
<th>List</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>and</code></td>
<td><code>as</code></td>
<td><code>assert</code></td>
<td><code>async</code></td>
<td><code>await</code></td>
</tr>
<tr>
<td><code>break</code></td>
<td><code>class</code></td>
<td><code>continue</code></td>
<td><code>def</code></td>
<td><code>del</code></td>
</tr>
<tr>
<td><code>elif</code></td>
<td><code>else</code></td>
<td><code>except</code></td>
<td><code>False</code></td>
<td><code>finally</code></td>
</tr>
<tr>
<td><code>for</code></td>
<td><code>from</code></td>
<td><code>global</code></td>
<td><code>if</code></td>
<td><code>import</code></td>
</tr>
<tr>
<td><code>in</code></td>
<td><code>is</code></td>
<td><code>lambda</code></td>
<td><code>None</code></td>
<td><code>nonlocal</code></td>
</tr>
<tr>
<td><code>not</code></td>
<td><code>or</code></td>
<td><code>pass</code></td>
<td><code>raise</code></td>
<td><code>return</code></td>
</tr>
<tr>
<td><code>True</code></td>
<td><code>try</code></td>
<td><code>while</code></td>
<td><code>with</code></td>
<td><code>yield</code></td>
</tr>
</tbody>
</table>
<p>你随时可以用以下代码查询关键字列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> keyword</span><br><span class="line">keyword.kwlist               <span class="comment"># 列出所有关键字</span></span><br><span class="line">keyword.iskeyword(<span class="string">'if'</span>)      <span class="comment"># 查询某个词是不是关键字</span></span><br></pre></td></tr></table></figure>
<pre><code>[&apos;False&apos;,
 &apos;None&apos;,
 &apos;True&apos;,
 &apos;and&apos;,
 &apos;as&apos;,
 &apos;assert&apos;,
 &apos;async&apos;,
 &apos;await&apos;,
 &apos;break&apos;,
 &apos;class&apos;,
 &apos;continue&apos;,
 &apos;def&apos;,
 &apos;del&apos;,
 &apos;elif&apos;,
 &apos;else&apos;,
 &apos;except&apos;,
 &apos;finally&apos;,
 &apos;for&apos;,
 &apos;from&apos;,
 &apos;global&apos;,
 &apos;if&apos;,
 &apos;import&apos;,
 &apos;in&apos;,
 &apos;is&apos;,
 &apos;lambda&apos;,
 &apos;nonlocal&apos;,
 &apos;not&apos;,
 &apos;or&apos;,
 &apos;pass&apos;,
 &apos;raise&apos;,
 &apos;return&apos;,
 &apos;try&apos;,
 &apos;while&apos;,
 &apos;with&apos;,
 &apos;yield&apos;]

True
</code></pre><p>关于更多为函数、变量取名所需要的注意事项，请参阅：</p>
<blockquote>
<ul>
<li><a href="https://www.python.org/dev/peps/pep-0008/#naming-conventions" target="_blank" rel="noopener">PEP 8 – Style Guide for Python Code: Naming Conventions</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0526/" target="_blank" rel="noopener">PEP 526 – Syntax for Variable Annotations</a></li>
</ul>
<p>注：PEPs，是 Python Enhancement Proposals 的缩写：<a href="https://www.python.org/dev/peps/" target="_blank" rel="noopener">https://www.python.org/dev/peps/</a></p>
</blockquote>
<h2 id="不接收任何参数的函数"><a href="#不接收任何参数的函数" class="headerlink" title="不接收任何参数的函数"></a>不接收任何参数的函数</h2><p>在定义函数的时候，可以定义成不接收任何参数；但调用函数的时候，依然需要写上函数名后面的圆括号 <code>()</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_something</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'This is a hello message from do_something().'</span>)</span><br><span class="line"></span><br><span class="line">do_something()</span><br></pre></td></tr></table></figure>
<pre><code>This is a hello message from do_something().
</code></pre><h2 id="没有-return-语句的函数"><a href="#没有-return-语句的函数" class="headerlink" title="没有 return 语句的函数"></a>没有 return 语句的函数</h2><p>函数内部，不一定非要有 <code>return</code> 语句 —— 上面 <code>do_somthing()</code> 函数就没有 <code>return</code> 语句。但如果函数内部并未定义返回值，那么，该函数的返回值是 <code>None</code>，当 <code>None</code> 被当作布尔值对待的时候，相当于是 <code>False</code>。</p>
<p>这样的设定，使得函数调用总是可以在条件语句中被当作判断依据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_something</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'This is a hello message from do_something().'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> do_something():                <span class="comment"># 由于该函数名称的缘故，这一句代码的可读性很差……</span></span><br><span class="line">    print(<span class="string">"The return value of 'do_something()' is None."</span>)</span><br></pre></td></tr></table></figure>
<pre><code>This is a hello message from do_something().
The return value of &apos;do_something()&apos; is None.
</code></pre><p><code>if not do_something():</code> 翻译成自然语言，应该是，“如果 <code>do_something()</code> 的返回值是 ‘非真’，那么：……”</p>
<h2 id="接收外部传递进来的值"><a href="#接收外部传递进来的值" class="headerlink" title="接收外部传递进来的值"></a>接收外部传递进来的值</h2><p>让我们写个判断闰年年份的函数，取名为 <code>is_leap()</code>，它接收一个年份为参数，若是闰年，则返回 <code>True</code>，否则返回 <code>False</code>。</p>
<p>根据闰年的定义：</p>
<blockquote>
<ul>
<li>年份应该是 4 的倍数；</li>
<li>年份能被 100 整除但不能被 400 整除的，不是闰年。</li>
</ul>
</blockquote>
<p>所以，相当于要在能被 4 整除的年份中，排除那些能被 100 整除却不能被 400 整除的年份。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_leap</span><span class="params">(year)</span>:</span></span><br><span class="line">    leap = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> year % <span class="number">4</span> == <span class="number">0</span>:</span><br><span class="line">        leap = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> year % <span class="number">100</span> == <span class="number">0</span> <span class="keyword">and</span> year % <span class="number">400</span> != <span class="number">0</span>:</span><br><span class="line">            leap = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> leap</span><br><span class="line"></span><br><span class="line">is_leap(<span class="number">7</span>)</span><br><span class="line">is_leap(<span class="number">12</span>)</span><br><span class="line">is_leap(<span class="number">100</span>)</span><br><span class="line">is_leap(<span class="number">400</span>)</span><br></pre></td></tr></table></figure>
<pre><code>False
True
False
True
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 另外一个更为简洁的版本，理解它还挺练脑子的</span></span><br><span class="line"><span class="comment"># cpython/Lib/datetime.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_is_leap</span><span class="params">(year)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> year % <span class="number">4</span> == <span class="number">0</span> <span class="keyword">and</span> (year % <span class="number">100</span> != <span class="number">0</span> <span class="keyword">or</span> year % <span class="number">400</span> == <span class="number">0</span>)</span><br><span class="line">_is_leap(<span class="number">300</span>)</span><br></pre></td></tr></table></figure>
<pre><code>False
</code></pre><p>函数可以同时接收多个参数。比如，我们可以写个函数，让它输出从大于某个数字到小于另外一个数字的斐波那契数列；那就需要定义两个参数，调用它的时候也需要传递两个参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_between</span><span class="params">(start, end)</span>:</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> a &lt; end:</span><br><span class="line">        <span class="keyword">if</span> a &gt;= start:</span><br><span class="line">            print(a, end=<span class="string">' '</span>)</span><br><span class="line">        a, b = b, a + b</span><br><span class="line"></span><br><span class="line">fib_between(<span class="number">100</span>, <span class="number">10000</span>)</span><br></pre></td></tr></table></figure>
<pre><code>144 233 377 610 987 1597 2584 4181 6765
</code></pre><p>当然可以把这个函数写成返回值是一个列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_between</span><span class="params">(start, end)</span>:</span></span><br><span class="line">    r = []</span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> a &lt; end:</span><br><span class="line">        <span class="keyword">if</span> a &gt;= start:</span><br><span class="line">            r.append(a)</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line">fib_between(<span class="number">100</span>, <span class="number">10000</span>)</span><br></pre></td></tr></table></figure>
<pre><code>[144, 233, 377, 610, 987, 1597, 2584, 4181, 6765]
</code></pre><h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p>下面的代码，经常会让初学者迷惑：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">increase_one</span><span class="params">(n)</span>:</span></span><br><span class="line">    n += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">n = <span class="number">1</span></span><br><span class="line">print(increase_one(n))</span><br><span class="line"><span class="comment"># print(n)</span></span><br></pre></td></tr></table></figure>
<pre><code>2
</code></pre><p>当 <code>increase_one(n)</code> 被调用之后，<code>n</code> 的值究竟是多少呢？或者更准确点问，随后的 <code>print(n)</code> 的输出结果应该是什么呢？</p>
<p>输出结果是 <code>1</code>。</p>
<p>在程序执行过程中，变量有<strong>全局变量</strong>（Global Variables）和<strong>局域变量</strong>（Local Variables）之分。</p>
<blockquote>
<p>首先，每次某个函数被调用的时候，这个函数会开辟一个新的区域，这个函数内部所有的变量，都是局域变量。也就是说，即便那个函数内部某个变量的名称与它外部的某个全局变量名称相同，它们也不是同一个变量 —— 只是名称相同而已。</p>
<p>其次，更为重要的是，当外部调用一个函数的时候，准确地讲，传递的不是变量，而是那个变量的<em>值</em>。也就是说，当 <code>increase_one(n)</code> 被调用的时候，被传递给那个恰好名称也叫 <code>n</code> 的局域变量的，是全局变量 <code>n</code> 的值，<code>1</code>。</p>
<p>而后，<code>increase_one()</code> 函数的代码开始执行，局域变量 <code>n</code> 经过 <code>n += 1</code> 之后，其中存储的值是 <code>2</code>，而后这个值被 <code>return</code> 语句返回，所以，<code>print(increase(n))</code> 所输出的值是函数被调用之后的返回值，即，<code>2</code>。</p>
<p>然而，全局变量 <code>n</code> 的值并没有被改变，因为局部变量 <code>n</code>（它的值是 <code>2</code>）和全局变量 <code>n</code>（它的值还是 <code>1</code>）只不过是名字相同而已，但它们并不是同一个变量。</p>
</blockquote>
<p>以上的文字，可能需要反复阅读若干遍；几遍下来，消除了疑惑，以后就彻底没问题了；若是这个疑惑并未消除，或者关键点并未消化，以后则会反复被这个疑惑所坑害，浪费无数时间。</p>
<p>不过，有一种情况要格外注意 —— 在函数内部处理被传递进来的值是可变容器（比如，列表）的时候：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">be_careful</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">    b[<span class="number">0</span>] = <span class="string">'What?!'</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">be_careful(a, b)</span><br><span class="line">a, b</span><br></pre></td></tr></table></figure>
<pre><code>(1, [&apos;What?!&apos;, 2, 3])
</code></pre><p>所以，一个比较好的习惯是，如果传递进来的值是列表，那么在函数内部对其操作之前，先创建一个它的拷贝：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">be_careful</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">    b_copy = b.copy()</span><br><span class="line">    b_copy[<span class="number">0</span>] = <span class="string">'What?!'</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">be_careful(a, b)</span><br><span class="line">a, b</span><br></pre></td></tr></table></figure>
<pre><code>(1, [1, 2, 3])
</code></pre><h1 id="关于参数（下）"><a href="#关于参数（下）" class="headerlink" title="关于参数（下）"></a>关于参数（下）</h1><h2 id="可以接收一系列值的位置参数"><a href="#可以接收一系列值的位置参数" class="headerlink" title="可以接收一系列值的位置参数"></a>可以接收一系列值的位置参数</h2><p>如果你在定义参数的时候，在一个<em>位置参数</em>（Positional Arguments）前面标注了星号，<code>*</code>，那么，这个位置参数可以接收一系列值，在函数内部可以对这一系列值用 <code>for ... in ...</code> 循环进行逐一的处理。</p>
<p>带一个星号的参数，英文名称是 “Arbitrary Positional Arguments”，姑且翻译为 “随意的位置参数”。</p>
<p>还有带两个星号的参数，一会儿会讲到，英文名称是 “Arbitrary Keyword Arguments”，姑且翻译为 “随意的关键字参数”。</p>
<blockquote>
<p>有些中文书籍把 “Arbitrary Positional Arguments” 翻译成 “可变位置参数”。事实上，在这样的地方，无论怎样的中文翻译都是令人觉得非常吃力的。前面的这个翻译还好了，我还见过把 “Arbitrary Keyword Arguments” 翻译成 “武断的关键字参数” 的 —— 我觉得这样的翻译肯定会使读者产生说不明道不白的疑惑。</p>
<p>所以，<strong>入门之后就尽量只用英文</strong>是个好策略。虽然刚开始有点吃力，但后面会很省心，很长寿 —— 是呀，少浪费时间、少浪费生命，其实就相当于更长寿了呀！</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hi</span><span class="params">(*names)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">        print(<span class="string">f'Hi, <span class="subst">&#123;name&#125;</span>!'</span>)</span><br><span class="line">say_hi()</span><br><span class="line">say_hi(<span class="string">'ann'</span>)</span><br><span class="line">say_hi(<span class="string">'mike'</span>, <span class="string">'john'</span>, <span class="string">'zeo'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Hi, ann!
Hi, mike!
Hi, john!
Hi, zeo!
</code></pre><p><code>say_hi()</code> 这一行没有任何输出。因为你在调用函数的时候，没有给它传递任何值，于是，在函数内部代码执行的时候，<code>name in names</code> 的值是 <code>False</code>，所以，<code>for</code> 循环内部的代码没有被执行。</p>
<p>在函数内部，是把 <code>names</code> 这个参数当作容器处理的 —— 否则也没办法用 <code>for ... in ...</code> 来处理。而在调用函数的时候，我们是可以将一个容器传递给函数的 Arbitrary Positional Arguments 的 —— 做法是，在调用函数的时候，在参数前面加上星号 <code>*</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hi</span><span class="params">(*names)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">        print(<span class="string">f'Hi, <span class="subst">&#123;name&#125;</span>!'</span>)</span><br><span class="line"></span><br><span class="line">names = (<span class="string">'mike'</span>, <span class="string">'john'</span>, <span class="string">'zeo'</span>)</span><br><span class="line">say_hi(*names)</span><br></pre></td></tr></table></figure>
<pre><code>Hi, mike!
Hi, john!
Hi, zeo!
</code></pre><p>实际上，因为以上的 <code>say_hi(*names)</code> 函数内部就是把接收到的参数当作容器处理的，于是，在调用这个函数的时候，向它传递任何容器都会被同样处理：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hi</span><span class="params">(*names)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">        print(<span class="string">f'Hi, <span class="subst">&#123;name&#125;</span>!'</span>)</span><br><span class="line"></span><br><span class="line">a_string = <span class="string">'Python'</span></span><br><span class="line">say_hi(*a_string)</span><br><span class="line"></span><br><span class="line">a_range = range(<span class="number">10</span>)</span><br><span class="line">say_hi(*a_range)</span><br><span class="line"></span><br><span class="line">a_list = list(range(<span class="number">10</span>, <span class="number">0</span>, <span class="number">-1</span>))</span><br><span class="line">say_hi(*a_list)</span><br><span class="line"></span><br><span class="line">a_dictionary = &#123;<span class="string">'ann'</span>:<span class="number">2321</span>, <span class="string">'mike'</span>:<span class="number">8712</span>, <span class="string">'joe'</span>: <span class="number">7610</span>&#125;</span><br><span class="line">say_hi(*a_dictionary)</span><br></pre></td></tr></table></figure>
<pre><code>Hi, P!
Hi, y!
Hi, t!
Hi, h!
Hi, o!
Hi, n!
Hi, 0!
Hi, 1!
Hi, 2!
Hi, 3!
Hi, 4!
Hi, 5!
Hi, 6!
Hi, 7!
Hi, 8!
Hi, 9!
Hi, 10!
Hi, 9!
Hi, 8!
Hi, 7!
Hi, 6!
Hi, 5!
Hi, 4!
Hi, 3!
Hi, 2!
Hi, 1!
Hi, ann!
Hi, mike!
Hi, joe!
</code></pre><p><em>在定义可以接收一系列值的位置参数时，建议在函数内部为该变量命名时总是用<strong>复数</strong></em>，因为函数内部，总是需要 <code>for</code> 循环去迭代元组中的元素，这样的时候，名称的复数形式对代码的可读性很有帮助 —— 注意以上程序第二行。以中文为母语的人，在这个细节上常常感觉 “不堪重负” —— 因为中文的名词没有复数 —— 但必须习惯。（同样的道理，若是用拼音命名变量，就肯定是为将来挖坑……）</p>
<p><strong>注意</strong>：一个函数中，可以接收一系列值的位置参数只能有一个；并且若是还有其它位置参数存在，那就必须把这个可以接收一系列值的位置参数排在所有其它位置参数之后。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hi</span><span class="params">(greeting, *names)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;greeting&#125;</span>, <span class="subst">&#123;name.capitalize()&#125;</span>!'</span>)</span><br><span class="line"></span><br><span class="line">say_hi(<span class="string">'Hello'</span>, <span class="string">'mike'</span>, <span class="string">'john'</span>, <span class="string">'zeo'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Hello, Mike!
Hello, John!
Hello, Zeo!
</code></pre><h2 id="为函数的某些参数设定默认值"><a href="#为函数的某些参数设定默认值" class="headerlink" title="为函数的某些参数设定默认值"></a>为函数的某些参数设定默认值</h2><p>可以在定义函数的时候，为某些参数设定默认值，这些有默认值的参数，又被称作关键字参数（Keyword Arguments）。从这个函数的 “用户” 角度来看，这些设定了默认值的参数，就成了 “可选参数”。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hi</span><span class="params">(greeting, *names, capitalized=False)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">        <span class="keyword">if</span> capitalized:</span><br><span class="line">            name = name.capitalize()</span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;greeting&#125;</span>, <span class="subst">&#123;name&#125;</span>!'</span>)</span><br><span class="line"></span><br><span class="line">say_hi(<span class="string">'Hello'</span>, <span class="string">'mike'</span>, <span class="string">'john'</span>, <span class="string">'zeo'</span>)</span><br><span class="line">say_hi(<span class="string">'Hello'</span>, <span class="string">'mike'</span>, <span class="string">'john'</span>, <span class="string">'zeo'</span>, capitalized=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Hello, mike!
Hello, john!
Hello, zeo!
Hello, Mike!
Hello, John!
Hello, Zeo!
</code></pre><h2 id="可以接收一系列值的关键字参数"><a href="#可以接收一系列值的关键字参数" class="headerlink" title="可以接收一系列值的关键字参数"></a>可以接收一系列值的关键字参数</h2><p>之前我们看到，可以设定一个位置参数（Positional Argument），接收一系列的值，被称作 “Arbitrary Positional Argument”；</p>
<p>同样地，我们也可以设定一个可以接收很多值的关键字参数（Arbitrary Keyword Argument）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hi</span><span class="params">(**names_greetings)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> name, greeting <span class="keyword">in</span> names_greetings.items():</span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;greeting&#125;</span>, <span class="subst">&#123;name&#125;</span>!'</span>)</span><br><span class="line"></span><br><span class="line">say_hi(mike=<span class="string">'Hello'</span>, ann=<span class="string">'Oh, my darling'</span>, john=<span class="string">'Hi'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Hello, mike!
Oh, my darling, ann!
Hi, john!
</code></pre><p>既然在函数内部，我们在处理接收到的 Arbitrary Keyword Argument 时，用的是对字典的迭代方式，那么，在调用函数的时候，也可以直接使用字典的形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hi</span><span class="params">(**names_greetings)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> name, greeting <span class="keyword">in</span> names_greetings.items():</span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;greeting&#125;</span>, <span class="subst">&#123;name&#125;</span>!'</span>)</span><br><span class="line"></span><br><span class="line">a_dictionary = &#123;<span class="string">'mike'</span>:<span class="string">'Hello'</span>, <span class="string">'ann'</span>:<span class="string">'Oh, my darling'</span>, <span class="string">'john'</span>:<span class="string">'Hi'</span>&#125;</span><br><span class="line">say_hi(**a_dictionary)</span><br><span class="line"></span><br><span class="line">say_hi(**&#123;<span class="string">'mike'</span>:<span class="string">'Hello'</span>, <span class="string">'ann'</span>:<span class="string">'Oh, my darling'</span>, <span class="string">'john'</span>:<span class="string">'Hi'</span>&#125;)</span><br></pre></td></tr></table></figure>
<pre><code>Hello, mike!
Oh, my darling, ann!
Hi, john!
Hello, mike!
Oh, my darling, ann!
Hi, john!
</code></pre><p>至于在函数内部，你用什么样的迭代方式去处理这个字典，是你自己的选择：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hi_2</span><span class="params">(**names_greetings)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names_greetings:</span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;names_greetings[name]&#125;</span>, <span class="subst">&#123;name&#125;</span>!'</span>)</span><br><span class="line">say_hi_2(mike=<span class="string">'Hello'</span>, ann=<span class="string">'Oh, my darling'</span>, john=<span class="string">'Hi'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Hello, mike!
Oh, my darling, ann!
Hi, john!
</code></pre><h2 id="函数定义时各种参数的排列顺序"><a href="#函数定义时各种参数的排列顺序" class="headerlink" title="函数定义时各种参数的排列顺序"></a>函数定义时各种参数的排列顺序</h2><p>在定义函数的时候，各种不同类型的参数应该按什么顺序摆放呢？对于之前写过的 <code>say_hi()</code> 这个函数，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hi</span><span class="params">(greeting, *names, capitalized=False)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">        <span class="keyword">if</span> capitalized:</span><br><span class="line">            name = name.capitalize()</span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;greeting&#125;</span>, <span class="subst">&#123;name&#125;</span>!'</span>)</span><br><span class="line"></span><br><span class="line">say_hi(<span class="string">'Hi'</span>, <span class="string">'mike'</span>, <span class="string">'john'</span>, <span class="string">'zeo'</span>)</span><br><span class="line">say_hi(<span class="string">'Welcome'</span>, <span class="string">'mike'</span>, <span class="string">'john'</span>, <span class="string">'zeo'</span>, capitalized=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Hi, mike!
Hi, john!
Hi, zeo!
Welcome, Mike!
Welcome, John!
Welcome, Zeo!
</code></pre><p>如果，你想给其中的 <code>greeting</code> 参数也设定个默认值怎么办？写成这样好像可以：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hi</span><span class="params">(greeting=<span class="string">'Hello'</span>, *names, capitalized=False)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">        <span class="keyword">if</span> capitalized:</span><br><span class="line">            name = name.capitalize()</span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;greeting&#125;</span>, <span class="subst">&#123;name&#125;</span>!'</span>)</span><br><span class="line"></span><br><span class="line">say_hi(<span class="string">'Hi'</span>, <span class="string">'mike'</span>, <span class="string">'john'</span>, <span class="string">'zeo'</span>)</span><br><span class="line">say_hi(<span class="string">'Welcome'</span>, <span class="string">'mike'</span>, <span class="string">'john'</span>, <span class="string">'zeo'</span>, capitalized=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Hi, mike!
Hi, john!
Hi, zeo!

Welcome, Mike!
Welcome, John!
Welcome, Zeo!
</code></pre><p>但 <code>greeting</code> 这个参数虽然有默认值，可这个函数在被调用的时候，还是必须要给出这个参数，否则输出结果出乎你的想象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hi</span><span class="params">(greeting=<span class="string">'Hello'</span>, *names, capitalized=False)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">        <span class="keyword">if</span> capitalized:</span><br><span class="line">            name = name.capitalize()</span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;greeting&#125;</span>, <span class="subst">&#123;name&#125;</span>!'</span>)</span><br><span class="line"></span><br><span class="line">say_hi(<span class="string">'mike'</span>, <span class="string">'john'</span>, <span class="string">'zeo'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>mike, john!
mike, zeo!
</code></pre><p>设定了默认值的 <code>greeting</code>，竟然不像你想象的那样是 “可选参数”！所以，你得这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hi</span><span class="params">(*names, greeting=<span class="string">'Hello'</span>, capitalized=False)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">        <span class="keyword">if</span> capitalized:</span><br><span class="line">            name = name.capitalize()</span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;greeting&#125;</span>, <span class="subst">&#123;name&#125;</span>!'</span>)</span><br><span class="line"></span><br><span class="line">say_hi(<span class="string">'mike'</span>, <span class="string">'john'</span>, <span class="string">'zeo'</span>)</span><br><span class="line">say_hi(<span class="string">'mike'</span>, <span class="string">'john'</span>, <span class="string">'zeo'</span>, greeting=<span class="string">'Hi'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Hello, mike!
Hello, john!
Hello, zeo!
Hi, mike!
Hi, john!
Hi, zeo!
</code></pre><p>这是因为函数被调用时，面对许多参数，Python 需要按照既定的规则（即，顺序）判定每个参数究竟是哪一类型的参数：</p>
<blockquote>
<p><strong>Order of Arguments</strong></p>
<ol>
<li>Positional</li>
<li>Arbitrary Positional</li>
<li>Keyword</li>
<li>Arbitrary Keyword</li>
</ol>
</blockquote>
<p>所以，即便你在定义里写成</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hi</span><span class="params">(greeting=<span class="string">'Hello'</span>, *names, capitalized=False)</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>在调用该函数的时候，无论你写的是<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">say_hi(<span class="string">'Hi'</span>, <span class="string">'mike'</span>, <span class="string">'john'</span>, <span class="string">'zeo'</span>)</span><br></pre></td></tr></table></figure></p>
<p>还是<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">say_hi(<span class="string">'mike'</span>, <span class="string">'john'</span>, <span class="string">'zeo'</span>)</span><br></pre></td></tr></table></figure></p>
<p>Python 都会认为接收到的第一个值是 Positional Argument —— 因为在定义中，<code>greeting</code> 被放到了 Arbitrary Positional Arguments 之前。</p>
<h1 id="化名与匿名"><a href="#化名与匿名" class="headerlink" title="化名与匿名"></a>化名与匿名</h1><h2 id="化名"><a href="#化名" class="headerlink" title="化名"></a>化名</h2><p>在 Python 中，我们可以给一个函数取个<strong>化名</strong>（alias）。</p>
<p>以下的代码，我们先是定义了一个名为 <code>_is_leap</code> 的函数，而后为它另取了一个化名：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_is_leap</span><span class="params">(year)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> year % <span class="number">4</span> == <span class="number">0</span> <span class="keyword">and</span> (year % <span class="number">100</span> != <span class="number">0</span> <span class="keyword">or</span> year % <span class="number">400</span> == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">year_leap_bool = _is_leap</span><br><span class="line">year_leap_bool              <span class="comment">#&lt;function __main__._is_leap(year)&gt;</span></span><br><span class="line">year_leap_bool(<span class="number">800</span>)         <span class="comment"># _is_leap(800) -&gt; True</span></span><br><span class="line"></span><br><span class="line">id(year_leap_bool)          <span class="comment"># id() 这个函数可以查询某对象的内存地址</span></span><br><span class="line">id(_is_leap)                <span class="comment"># year_leap_bool 和 _is_leap 其实保存在同一个地址中，也就是说，它们是同一个对象。</span></span><br><span class="line"></span><br><span class="line">type(year_leap_bool)</span><br><span class="line">type(_is_leap)              <span class="comment"># 它们都是 function</span></span><br></pre></td></tr></table></figure>
<pre><code>&lt;function __main__._is_leap(year)&gt;

True

4547071648

4547071648

function

function
</code></pre><p>我们可以看到的是，<code>id(year_leap_bool)</code> 和 <code>id(_is_leap)</code> 的内存地址是一样的 —— 它们是同一个对象，它们都是函数。所以，当你写 <code>year_leap_bool = _is_leap</code> 的时候，相当于给 <code>_is_leap()</code> 这个函数取了个化名。</p>
<p>在什么样的情况下，要给一个函数取一个化名呢？</p>
<p>在任何一个工程里，为函数或者变量取名都是很简单却不容易的事情 —— 因为可能会重名（虽然已经尽量用变量的作用域隔离了），可能会因取名含混而令后来者费解……</p>
<p>所以，仅仅为了少敲几下键盘而给一个函数取个更短的化名，实际上并不是好主意，更不是好习惯。尤其现在的编辑器都支持自动补全和多光标编辑的功能，变量名再长都不构成负担。</p>
<p>更多的时候，为函数取一个化名，应该是为了提高代码可读性 —— 对自己或其他人都很重要。</p>
<h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><p>写一个很短的函数可以用 <code>lambda</code> 关键字。</p>
<p>下面是用 <code>def</code> 关键字写函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">add(<span class="number">3</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<pre><code>8
</code></pre><p>下面是用 <code>lambda</code> 关键字写函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add = <span class="keyword">lambda</span> x, y: x + y</span><br><span class="line">add(<span class="number">3</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<pre><code>8
</code></pre><p>lambda 的语法结构如下：</p>
<blockquote>
<p><code>lambda_expr ::= &quot;lambda&quot; [parameter_list] &quot;:&quot; expression</code></p>
</blockquote>
<p>以上使用的是 BNF 标注。当然，BNF 是你目前并不熟悉的，所以，有疑惑别当回事。</p>
<p>反正你已经见到示例了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> x, y: x + y</span><br></pre></td></tr></table></figure>
<p>先写上 <code>lambda</code> 这个关键字，其后分为两个部分，<code>:</code> 之前是参数，之后是表达式；这个表达式的值，就是这个函数的返回值。</p>
<blockquote>
<p><strong>注意</strong>：<code>lambda</code> 语句中，<code>:</code> 之后有且只能有一个表达式。</p>
</blockquote>
<p>而这个函数呢，没有名字，所以被称为 “匿名函数”。</p>
<p><code>add = lambda x, y: x + y</code></p>
<p>就相当于是给一个没有名字的函数取了个名字。</p>
<h2 id="lambda-的使用场景"><a href="#lambda-的使用场景" class="headerlink" title="lambda 的使用场景"></a>lambda 的使用场景</h2><p>那 lambda 这种匿名函数的用处在哪里呢？</p>
<h3 id="作为某函数的返回值"><a href="#作为某函数的返回值" class="headerlink" title="作为某函数的返回值"></a>作为某函数的返回值</h3><p>第一个常见的用处是<em>作为另外一个函数的返回值</em>。</p>
<p>让我们看看 <a href="https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions" target="_blank" rel="noopener">The Python Tutorial</a> 中的一个例子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_incrementor</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x: x + n</span><br><span class="line"></span><br><span class="line">f = make_incrementor(<span class="number">42</span>)</span><br><span class="line">f(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<pre><code>42

43
</code></pre><p>这个例子乍看起来很令人迷惑。我们先看看 <code>f = make_incrementor(42)</code> 之后，<code>f</code> 究竟是什么东西：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_incrementor</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x: x + n</span><br><span class="line"></span><br><span class="line">f = make_incrementor(<span class="number">42</span>)</span><br><span class="line">f</span><br><span class="line"></span><br><span class="line">id(make_incrementor)</span><br><span class="line">id(f)</span><br></pre></td></tr></table></figure>
<pre><code>&lt;function __main__.make_incrementor.&lt;locals&gt;.&lt;lambda&gt;(x)&gt;

4428443296

4428726888
</code></pre><p>首先，要注意，<code>f</code> 并不是 <code>make_incrementor()</code> 这个函数的化名，如果是给这个函数取个化名，写法应该是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = make_incrementor</span><br></pre></td></tr></table></figure>
<p>那 <code>f</code> 是什么呢？它是 <code>&lt;function __main__.make_incrementor.&lt;locals&gt;.&lt;lambda&gt;(x)&gt;</code>：</p>
<blockquote>
<ul>
<li><code>f = make_incrementor(42)</code> 是将 <code>make_incrementor(42)</code> 的返回值保存到 <code>f</code> 这个变量之中；</li>
<li>而 <code>make_incrementor()</code> 这个函数接收到 <code>42</code> 这个参数之后，返回了一个函数：<code>lambda x: x + 42</code>；</li>
<li>于是，<code>f</code> 中保存的函数是 <code>lambda x: x + 42</code>；</li>
<li>所以，<code>f(0)</code> 是向这个匿名函数传递了 <code>0</code>，而后，它返回的是 <code>0 + 42</code>。</li>
</ul>
</blockquote>
<h3 id="作为某函数的参数"><a href="#作为某函数的参数" class="headerlink" title="作为某函数的参数"></a>作为某函数的参数</h3><p>可以拿一些可以接收函数为参数的内建函数做例子。比如，<a href="https://docs.python.org/3/library/functions.html#map" target="_blank" rel="noopener"><code>map()</code></a>。</p>
<blockquote>
<p><code>map</code>(<em>function</em>, <em>iterable</em>, <em>…</em>)</p>
<p>Return an iterator that applies <em>function</em> to every item of <em>iterable</em>, yielding the results. If additional <em>iterable</em> arguments are passed, <em>function</em> must take that many arguments and is applied to the items from all iterables in parallel. With multiple iterables, the iterator stops when the shortest iterable is exhausted. For cases where the function inputs are already arranged into argument tuples, see <a href="https://docs.python.org/3/library/itertools.html#itertools.starmap" target="_blank" rel="noopener"><code>itertools.starmap()</code></a>.</p>
</blockquote>
<p><code>map()</code> 这个函数的第一个参数，就是用来接收函数的。随后的参数，是 <code>iterable</code> —— 就是可被迭代的对象，比如，各种容器，例如：列表、元组、字典什么的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double_it</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> n * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">a_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">b_list = list(map(double_it, a_list))</span><br><span class="line">b_list</span><br><span class="line"></span><br><span class="line">c_list = list(map(<span class="keyword">lambda</span> x: x * <span class="number">2</span>, a_list))</span><br><span class="line">c_list</span><br></pre></td></tr></table></figure>
<pre><code>[2, 4, 6, 8, 10, 12]

[2, 4, 6, 8, 10, 12]
</code></pre><p>显然用 <code>lambda</code> 更为简洁。另外，类似完成 <code>double_it(n)</code> 这种简单功能的函数，常常有 “用过即弃” 的必要。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">phonebook = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'name'</span>: <span class="string">'john'</span>,</span><br><span class="line">        <span class="string">'phone'</span>: <span class="number">9876</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'name'</span>: <span class="string">'mike'</span>,</span><br><span class="line">        <span class="string">'phone'</span>: <span class="number">5603</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'name'</span>: <span class="string">'stan'</span>,</span><br><span class="line">        <span class="string">'phone'</span>: <span class="number">6898</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'name'</span>: <span class="string">'eric'</span>,</span><br><span class="line">        <span class="string">'phone'</span>: <span class="number">7898</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">phonebook</span><br><span class="line">list(map(<span class="keyword">lambda</span> x: x[<span class="string">'name'</span>], phonebook))</span><br><span class="line">list(map(<span class="keyword">lambda</span> x: x[<span class="string">'phone'</span>], phonebook))</span><br></pre></td></tr></table></figure>
<pre><code>[{&apos;name&apos;: &apos;john&apos;, &apos;phone&apos;: 9876},
 {&apos;name&apos;: &apos;mike&apos;, &apos;phone&apos;: 5603},
 {&apos;name&apos;: &apos;stan&apos;, &apos;phone&apos;: 6898},
 {&apos;name&apos;: &apos;eric&apos;, &apos;phone&apos;: 7898}]

[&apos;john&apos;, &apos;mike&apos;, &apos;stan&apos;, &apos;eric&apos;]

[9876, 5603, 6898, 7898]
</code></pre><p>可以给 map() 传递若干个可被迭代对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a_list = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">b_list = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">list(map(<span class="keyword">lambda</span> x, y: x * y, a_list, b_list))</span><br></pre></td></tr></table></figure>
<pre><code>[2, 12, 30]
</code></pre><p>以上的例子都弄明白了，再去看 <a href="https://docs.python.org/3/tutorial/controlflow.html#lambda-expressions" target="_blank" rel="noopener">The Python Tutorial</a> 中的例子，就不会有任何疑惑了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pairs = [(<span class="number">1</span>, <span class="string">'one'</span>), (<span class="number">2</span>, <span class="string">'two'</span>), (<span class="number">3</span>, <span class="string">'three'</span>), (<span class="number">4</span>, <span class="string">'four'</span>)]</span><br><span class="line">pairs.sort(key=<span class="keyword">lambda</span> p: p[<span class="number">1</span>])</span><br><span class="line">pairs</span><br></pre></td></tr></table></figure>
<pre><code>[(4, &apos;four&apos;), (1, &apos;one&apos;), (3, &apos;three&apos;), (2, &apos;two&apos;)]
</code></pre><h1 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h1><h2 id="递归（Recursion）"><a href="#递归（Recursion）" class="headerlink" title="递归（Recursion）"></a>递归（Recursion）</h2><p>在函数中有个理解门槛比较高的概念：<strong>递归函数</strong>（Recursive Functions）—— 那些<strong>在自身内部调用自身的函数</strong>。说起来都比较拗口。</p>
<p>先看一个例子，我们想要有个能够计算 <code>n</code> 的<em>阶乘</em>（factorial）<code>n!</code> 的函数，<code>f()</code>，规则如下：</p>
<blockquote>
<ul>
<li><code>n! = n × (n-1) × (n-2)... × 1</code></li>
<li>即，<code>n! = n × (n-1)!</code></li>
<li>且，<code>n &gt;= 1</code></li>
</ul>
<p><strong>注意</strong>：以上是数学表达，不是程序，所以，<code>=</code> 在这一小段中是 “<em>等于</em>” 的意思，<strong>不是程序语言中的赋值符号</strong>。</p>
</blockquote>
<p>于是，计算 <code>f(n)</code> 的 Python 程序如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> n * f(n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">print(f(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<pre><code>120
</code></pre><h2 id="递归函数的执行过程"><a href="#递归函数的执行过程" class="headerlink" title="递归函数的执行过程"></a>递归函数的执行过程</h2><p>以 factorial(5) 为例，让我们看看程序的流程：</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/recursive-function-call.png?raw=true" alt></p>
<p>当 f(5) 被调用之后，函数开始运行……</p>
<ul>
<li>因为 <code>5 &gt; 1</code>，所以，在计算 <code>n * f(n-1)</code> 的时候要再次调用自己 <code>f(4)</code>；所以必须等待 <code>f(4)</code> 的值返回；</li>
<li>因为 <code>4 &gt; 1</code>，所以，在计算 <code>n * f(n-1)</code> 的时候要再次调用自己 <code>f(3)</code>；所以必须等待 <code>f(3)</code> 的值返回；</li>
<li>因为 <code>3 &gt; 1</code>，所以，在计算 <code>n * f(n-1)</code> 的时候要再次调用自己 <code>f(2)</code>；所以必须等待 <code>f(2)</code> 的值返回；</li>
<li>因为 <code>2 &gt; 1</code>，所以，在计算 <code>n * f(n-1)</code> 的时候要再次调用自己 <code>f(1)</code>；所以必须等待 <code>f(1)</code> 的值返回；</li>
<li>因为 <code>1 == 1</code>，所以，这时候不会再次调用 <code>f()</code> 了，于是递归结束，开始返回，这次返回的是 <code>1</code>；</li>
<li>下一步返回的是 <code>2 * 1</code>；</li>
<li>下一步返回的是 <code>3 * 2</code>；</li>
<li>下一步返回的是 <code>4 * 6</code>；</li>
<li>下一步返回的是 <code>5 * 24</code> —— 至此，外部调用 <code>f(5)</code> 的最终返回值是 <code>120</code>……</li>
</ul>
<p>加上一些输出语句之后，能更清楚地看到大概的执行流程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">'\tn ='</span>, n)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        print(<span class="string">'Returning...'</span>)</span><br><span class="line">        print(<span class="string">'\tn ='</span>, n, <span class="string">'return:'</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r = n * f(n<span class="number">-1</span>)</span><br><span class="line">        print(<span class="string">'\tn ='</span>, n, <span class="string">'return:'</span>, r)</span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Call f(5)...'</span>)</span><br><span class="line">print(<span class="string">'Get out of f(n), and f(5) ='</span>, f(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<pre><code>Call f(5)...
    n = 5
    n = 4
    n = 3
    n = 2
    n = 1
Returning...
    n = 1 return: 1
    n = 2 return: 2
    n = 3 return: 6
    n = 4 return: 24
    n = 5 return: 120
Get out of f(n), and f(5) = 120
</code></pre><p>有点烧脑…… 不过，分为几个层面去逐个突破，你会发现它真的很好玩。</p>
<h2 id="递归的终点"><a href="#递归的终点" class="headerlink" title="递归的终点"></a>递归的终点</h2><p>递归函数在内部必须有一个能够让自己停止调用自己的方式，否则永远循环下去了……</p>
<p>其实，我们所有人很小就见过递归应用，只不过，那时候不知道那就是递归而已。听过那个无聊的故事罢？</p>
<blockquote>
<p>山上有座庙，庙里有个和尚，和尚讲故事，说……</p>
<blockquote>
<p>山上有座庙，庙里有个和尚，和尚讲故事，说……</p>
<blockquote>
<p>山上有座庙，庙里有个和尚，和尚讲故事，说……</p>
</blockquote>
</blockquote>
</blockquote>
<p>写成 Python 程序大概是这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_monk_telling_story</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'山上有座庙，庙里有个和尚，和尚讲故事，他说…… '</span>)</span><br><span class="line">    <span class="keyword">return</span> a_monk_telling_story()</span><br><span class="line"></span><br><span class="line">a_monk_telling_story()</span><br></pre></td></tr></table></figure>
<p>这是个<em>无限循环</em>的递归，因为这个函数里<em>没有设置中止自我调用的条件</em>。无限循环还有个不好听的名字，叫做 “死循环”。</p>
<p>在著名的电影<strong>盗梦空间</strong>（<em>2010</em>）里，从整体结构上来看，“入梦” 也是个 “递归函数”。只不过，这个函数和 <code>a_monk_telling_story()</code> 不一样，它并不是死循环 —— 因为它设定了<em>中止自我调用的条件</em>：</p>
<blockquote>
<p>在电影里，醒过来的条件有两个</p>
<blockquote>
<ul>
<li>一个是在梦里死掉；</li>
<li>一个是在梦里被 kicked 到……</li>
</ul>
</blockquote>
<p>如果这两个条件一直不被满足，那就进入 limbo 状态 —— 其实就跟死循环一样，出不来了……</p>
</blockquote>
<p>为了演示，我把故事情节改变成这样：</p>
<blockquote>
<ul>
<li>入梦，<code>in_dream()</code>，是个递归函数；</li>
<li>入梦之后醒过来的条件有两个：<blockquote>
<ul>
<li>一个是在梦里死掉，<code>dead is True</code>；</li>
<li>一个是在梦里被 kicked，<code>kicked is True</code>……</li>
</ul>
<p>以上两个条件中任意一个被满足，就苏醒……</p>
</blockquote>
</li>
</ul>
</blockquote>
<p>至于为什么会死掉，如何被 kick，我偷懒了一下：管它怎样，管它如何，反正，每个条件被满足的概率是 1/10……（也只有这样，我才能写出一个简短的，能够运行的 “<em>盗梦空间程序</em>”。）</p>
<p>把这个很抽象的故事写成 Python 程序，看看一次入梦之后能睡多少天，大概是这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">in_dream</span><span class="params">(day=<span class="number">0</span>, dead=False, kicked=False)</span>:</span></span><br><span class="line">    dead = <span class="keyword">not</span> random.randrange(<span class="number">0</span>,<span class="number">10</span>) <span class="comment"># 1/10 probability to be dead</span></span><br><span class="line">    kicked = <span class="keyword">not</span> random.randrange(<span class="number">0</span>,<span class="number">10</span>) <span class="comment"># 1/10 probability to be kicked</span></span><br><span class="line">    day += <span class="number">1</span></span><br><span class="line">    print(<span class="string">'dead:'</span>, dead, <span class="string">'kicked:'</span>, kicked)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> dead:</span><br><span class="line">        print((<span class="string">f"I slept <span class="subst">&#123;day&#125;</span> days, and was dead to wake up..."</span>))</span><br><span class="line">        <span class="keyword">return</span> day</span><br><span class="line">    <span class="keyword">elif</span> kicked:</span><br><span class="line">        print(<span class="string">f"I slept <span class="subst">&#123;day&#125;</span> days, and was kicked to wake up..."</span>)</span><br><span class="line">        <span class="keyword">return</span> day</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> in_dream(day)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'The in_dream() function returns:'</span>, in_dream())</span><br></pre></td></tr></table></figure>
<pre><code>dead: False kicked: False
dead: False kicked: False
dead: False kicked: False
dead: False kicked: False
dead: False kicked: False
dead: False kicked: False
dead: False kicked: False
dead: True kicked: True
I slept 8 days, and was dead to wake up...
The in_dream() function returns: 8
</code></pre><p>如果疑惑为什么 <code>random.randrange(0,10)</code> 能表示 1/10 的概率，请返回去重新阅读<a href="Part.1.E.2.values-and-their-operators.md">第一部分中关于布尔值的内容</a>。</p>
<p>另外，在 Python 中，若是需要将某个值与 True 或者 False 进行比较，尤其是在条件语句中，推荐写法是（参见 <a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">PEP8</a>）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>就好像上面代码中的 <code>if dead:</code> 一样。</p>
<p>而不是（虽然这么写通常也并不妨碍程序正常运行<a href="#fn1" name="fn1b"><sup>[1]</sup></a>）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>抑或：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition == <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>让我们再返回来接着讲递归函数。正常的<strong>递归函数一定有个退出条件</strong>。否则的话，就<em>无限循环</em>下去了…… 下面的程序在执行一会儿之后就会告诉你：<code>RecursionError: maximum recursion depth exceeded</code>（上面那个 “山上庙里讲故事的和尚说” 的程序，真要跑起来，也是这样）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> n * x(n<span class="number">-1</span>)</span><br><span class="line">x(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<pre><code>---------------------------------------------------------------------------

RecursionError                            Traceback (most recent call last)

&lt;ipython-input-3-daa4d33fb39b&gt; in &lt;module&gt;
      1 def x(n):
      2     return n * x(n-1)
----&gt; 3 x(5)

&lt;ipython-input-3-daa4d33fb39b&gt; in x(n)
      1 def x(n):
----&gt; 2     return n * x(n-1)
      3 x(5)

... last 1 frames repeated, from the frame below ...

&lt;ipython-input-3-daa4d33fb39b&gt; in x(n)
      1 def x(n):
----&gt; 2     return n * x(n-1)
      3 x(5)

RecursionError: maximum recursion depth exceeded
</code></pre><p>不用深究上面盗梦空间这个程序的其它细节，不过，通过以上三个递归程序 —— 两个很扯淡的例子，一个正经例子 —— 你已经看到了递归函数的共同特征：</p>
<blockquote>
<ol>
<li>在 <code>return</code> 语句中返回的是<em>自身的调用</em>（或者是<em>含有自身的表达式</em>）</li>
<li>为了避免死循环，<em>一定要有至少一个条件</em>下返回的不再是自身调用……</li>
</ol>
</blockquote>
<h2 id="变量的作用域-1"><a href="#变量的作用域-1" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><p>再回来看计算阶乘的程序 —— 这是正经程序。这次我们把程序名写完整，<code>factorial()</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> n * factorial(n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">print(factorial(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<pre><code>120
</code></pre><p>最初的时候，这个函数的执行流程之所以令人迷惑，是因为初学者对<em>变量</em>的<strong>作用域</strong>把握得不够充分。</p>
<p>变量根据作用域，可以分为两种：全局变量（Global Variables）和局部变量（Local Variables）。</p>
<p>可以这样简化理解：</p>
<blockquote>
<ul>
<li>在函数内部被赋值而后使用的，都是<em>局部变量</em>，它们的作用域是<em>局部</em>，无法被函数外的代码调用；</li>
<li>在所有函数之外被赋值而后开始使用的，是<em>全局变量</em>，它们的作用域是<em>全局</em>，在函数内外都可以被调用。</li>
</ul>
</blockquote>
<p>定义如此，但通常程序员们会严格地遵守一条原则：</p>
<blockquote>
<p>在函数内部绝对不调用全局变量。即便是必须改变全局变量，也只能通过函数的返回值在函数外改变全局变量。</p>
</blockquote>
<p>你也必须遵守同样的原则。而这个原则同样可以在日常的工作生活中 “调用”：</p>
<blockquote>
<p>做事的原则：自己的事自己做，别人的事，最多通过自己的产出让他们自己去搞……</p>
</blockquote>
<p>再仔细观察一下以下代码。当一个变量被当做参数传递给一个函数的时候，这个变量本身并不会被函数所改变。比如，<code>a = 5</code>，而后，再把 <code>a</code> 当作参数传递给 <code>f(a)</code> 的时候，这个函数当然应该返回它内部任务完成之后应该传递回来的值，但 <code>a</code> 本身不会被改变。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> n * factorial(n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">a = <span class="number">5</span></span><br><span class="line">b = factorial(a)   <span class="comment"># a 并不会因此改变；</span></span><br><span class="line">print(a, b)</span><br><span class="line">a = factorial(a)   <span class="comment"># 这是你主动为 a 再一次赋值……</span></span><br><span class="line">print(a, b)</span><br></pre></td></tr></table></figure>
<pre><code>5 120
120 120
</code></pre><p>理解了这一点之后，再看 <code>factorial()</code> 这个递归函数的递归执行过程，你就能明白这个事实：</p>
<blockquote>
<p>在每一次 factorial(n) 被调用的时候，它都会形成一个作用域，<code>n</code> 这个变量作为参数把它的值传递给了函数，<em>但是</em>，<code>n</code> 这个变量本身并不会被改变。</p>
</blockquote>
<p>我们再修改一下上面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> n * factorial(n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">n = <span class="number">5</span>              <span class="comment"># 这一次，这个变量名称是 n</span></span><br><span class="line">m = factorial(n)   <span class="comment"># n 并不会因此改变；</span></span><br><span class="line">print(n, m)</span><br></pre></td></tr></table></figure>
<pre><code>5 120
</code></pre><p>在 <code>m = factorial(n)</code> 这一句中，<code>n</code> 被 <code>factorial()</code> 当做参数调用了，但无论函数内部如何操作，并不会改变变量 <code>n</code> 的值。</p>
<p>关键的地方在这里：在函数内部出现的变量 <code>n</code>，和函数外部的变量 <code>n</code> 不是一回事 —— <strong>它们只是名称恰好相同而已</strong>，函数参数定义的时候，用别的名称也没什么区别：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(x)</span>:</span> <span class="comment"># 在这个语句块中出现的变量，都是局部变量</span></span><br><span class="line">    <span class="keyword">if</span> x == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> x * factorial(x<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">n = <span class="number">5</span>           <span class="comment"># 这一次，这个变量名称是 n</span></span><br><span class="line">m = factorial(n)   <span class="comment"># n 并不会因此改变；</span></span><br><span class="line">print(n, m)</span><br><span class="line"><span class="comment"># 这个例子和之前再之前的示例代码有什么区别吗？</span></span><br><span class="line"><span class="comment"># 本质上没区别，就是变量名称换了而已……</span></span><br></pre></td></tr></table></figure>
<pre><code>5 120
</code></pre><p>函数开始执行的时候，<code>x</code> 的值，是由外部代码（即，函数被调用的那一句）传递进来的。即便函数内部的变量名称与外部的变量名称相同，它们也不是同一个变量。</p>
<h2 id="递归函数三原则"><a href="#递归函数三原则" class="headerlink" title="递归函数三原则"></a>递归函数三原则</h2><p>现在可以小小总结一下了。</p>
<p>一个递归函数，之所以是一个有用、有效的递归函数，是因为它要遵守递归三原则。正如，一个机器人之所以是个合格的机器人，是因为它遵循<a href="https://zh.wikipedia.org/wiki/%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%B8%89%E5%AE%9A%E5%BE%8B" target="_blank" rel="noopener">阿西莫夫三铁律</a>（Three Laws of Robotics）一样<a href="#fn2" name="fn2b"><sup>[2]</sup></a>。</p>
<blockquote>
<ol>
<li>根据定义，递归函数必须在内部调用自己；</li>
<li>必须设定一个退出条件；</li>
<li>递归过程中必须能够逐步达到退出条件……</li>
</ol>
</blockquote>
<p>从这个三原则望过去，<code>factorial()</code> 是个合格有效的递归函数，满足第一条，满足第二条，尤其还满足第三条中的 “<em>逐步达到</em>”！</p>
<p>而那个扯淡的盗梦空间递归程序，说实话，不太合格，虽然它满足第一条，也满足第二条，第三条差点蒙混过关：它不是<em>逐步达到</em>，而是<em>不管怎样肯定能达到</em> —— 这明显是两回事…… 原谅它罢，它的作用就是当例子，一次正面的，一次负面的，作为例子算是功成圆满了！</p>
<p>刚开始的时候，初学者好不容易搞明白递归函数究竟是怎么回事之后，就不由自主地想 “我如何才能学会递归式思考呢？” —— 其实吧，这种想法本身可能并不是太正确或者准确。</p>
<p>准确地讲，递归是一种解决问题的方式。当我们需要解决的问题，可以被逐步拆分成很多越来越小的模块，然后每个小模块还都能用同一种算法处理的时候，用递归函数最简洁有效。所以，只不过是在遇到可以用递归函数解决问题的时候，才需要去写递归函数。</p>
<p>从这个意义上来看，递归函数是程序员为了自己方便而使用的，并不是为了计算机方便而使用 —— 计算机么，你给它的任务多一点或者少一点，对它来讲无所谓，反正有电就能运转，它自己又不付电费……</p>
<p>理论上来讲，所有用递归函数能完成的任务，不用递归函数也能完成，只不过代码多一点，啰嗦一点，看起来没有那么优美而已。</p>
<p>还有，递归，不像 “序列类型” 那样，是某个编程语言的特有属性。它其实是一种特殊算法，也是一种编程技巧，任何编程语言，都可以使用递归算法，都可以通过编写递归函数巧妙地解决问题。</p>
<p>但是，学习递归函数本身就很烧脑啊！这才是最大的好事。从迷惑，到不太迷惑，到清楚，到很清楚，再到特别清楚 —— 这是个非常有趣，非常有成就感的过程。</p>
<p>这种过程锻炼的是脑力 —— 在此之后，再遇到大多数人难以理解的东西，你就可以使用这一次积累的经验，应用你已经磨炼过的脑力。有意思。</p>
<p>至此，封面上的那个 “伪代码” 应该很好理解了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">teach_yourself</span><span class="params">(anything)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> create():</span><br><span class="line">        learn()</span><br><span class="line">        practice()</span><br><span class="line">    <span class="keyword">return</span> teach_yourself(another)</span><br><span class="line"></span><br><span class="line">teach_yourself(coding)</span><br></pre></td></tr></table></figure>
<p>自学还真的就是递归函数呢……</p>
<h2 id="思考与练习"><a href="#思考与练习" class="headerlink" title="思考与练习"></a>思考与练习</h2><p>普林斯顿大学的一个网页，有很多递归的例子</p>
<p><a href="https://introcs.cs.princeton.edu/java/23recursion/" target="_blank" rel="noopener">https://introcs.cs.princeton.edu/java/23recursion/</a></p>
<hr>
<p><strong>脚注</strong></p>
<p><a name="fn1">[1]</a>：参见 Stackoverflow 上的讨论：<a href="https://stackoverflow.com/questions/27276610/boolean-identity-true-vs-is-true" target="_blank" rel="noopener">Boolean identity == True vs is True</a></p>
<p><a href="#fn1b"><small>↑Back to Content↑</small></a></p>
<p><a name="fn2">[2]</a>：关于<a href="https://zh.wikipedia.org/wiki/%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%B8%89%E5%AE%9A%E5%BE%8B" target="_blank" rel="noopener">阿西莫夫三铁律</a>（Three Laws of Robotics）的类比，来自著名的 Python 教程，<a href="http://greenteapress.com/thinkpython2/html/index.html" target="_blank" rel="noopener">Think Python: How to Think Like a Computer Scientist</a></p>
<p><a href="#fn2b"><small>↑Back to Content↑</small></a></p>
<h1 id="函数的文档"><a href="#函数的文档" class="headerlink" title="函数的文档"></a>函数的文档</h1><p>你在调用函数的时候，你像是函数这个产品的用户。</p>
<p>而你写一个函数，像是做一个产品，这个产品将来可能会被很多用户使用 —— 包括你自己。</p>
<p>产品，就应该有产品说明书，别人用得着，你自己也用得着 —— 很久之后的你，很可能把当初的各种来龙去脉忘得一干二净，所以也同样需要产品说明书，别看那产品曾经是你自己设计的。</p>
<p>Python 在这方面很用功，把函数的 “产品说明书” 当作语言内部的功能，这也是为什么 Python 有 <a href="http://www.sphinx-doc.org" target="_blank" rel="noopener">Sphinx</a> 这种工具，而绝大多数其他语言没有的原因之一罢。</p>
<h2 id="Docstring"><a href="#Docstring" class="headerlink" title="Docstring"></a>Docstring</h2><p>在函数定义内部，我们可以加上 <strong>Docstring</strong>；将来函数的 “用户” 就可以通过 <code>help()</code> 这个内建函数，或者 <code>.__doc__</code> 这个 Method 去查看这个 Docstring，即，该函数的 “产品说明书”。</p>
<p>先看一个 Docstring 以及如何查看某个函数的 Docstring 的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_prime</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Return a boolean value based upon</span></span><br><span class="line"><span class="string">    whether the argument n is a prime number.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">2</span>, int(n**<span class="number">0.5</span>)+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> (n % m) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">help(is_prime)</span><br><span class="line">print(is_prime.__doc__)</span><br><span class="line">is_prime.__doc__</span><br></pre></td></tr></table></figure>
<pre><code>Help on function is_prime in module __main__:

is_prime(n)
    Return a boolean value based upon
    whether the argument n is a prime number.

    Return a boolean value based upon
    whether the argument n is a prime number.

&apos;\n    Return a boolean value based upon\n    whether the argument n is a prime number.\n    &apos;
</code></pre><p>Docstring 可以是多行字符串，也可以是单行字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_prime</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">"""Return a boolean value based upon whether the argument n is a prime number."""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">2</span>, int(n**<span class="number">0.5</span>)+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> (n % m) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">help(is_prime)</span><br><span class="line">print(is_prime.__doc__)</span><br><span class="line">is_prime.__doc__</span><br></pre></td></tr></table></figure>
<pre><code>Help on function is_prime in module __main__:

is_prime(n)
    Return a boolean value based upon whether the argument n is a prime number.

Return a boolean value based upon whether the argument n is a prime number.

&apos;Return a boolean value based upon whether the argument n is a prime number.&apos;
</code></pre><p>Docstring 如若存在，必须在函数定义的内部语句块的开头，也必须与其它语句一样保持相应的缩进（Indention）。Docstring 放在其它地方不起作用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_prime</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">2</span>, int(n**<span class="number">0.5</span>)+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> (n % m) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Return a boolean value based upon</span></span><br><span class="line"><span class="string">    whether the argument n is a prime number.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">help(is_prime)</span><br><span class="line">print(is_prime.__doc__)</span><br><span class="line">is_prime.__doc__</span><br></pre></td></tr></table></figure>
<pre><code>Help on function is_prime in module __main__:

is_prime(n)

None
</code></pre><h2 id="书写-Docstring-的规范"><a href="#书写-Docstring-的规范" class="headerlink" title="书写 Docstring 的规范"></a>书写 Docstring 的规范</h2><p>规范，虽然是人们最好遵守的，但其实通常是很多人并不遵守的东西。</p>
<p>既然学，就要<strong>像样</strong> —— 这真的很重要。所以，非常有必要认真阅读 Python <a href="https://www.python.org/dev/peps/pep-0257/" target="_blank" rel="noopener">PEP 257</a> 关于 Docstring 的规范。</p>
<p>简要总结一下 PEP 257 中必须掌握的规范：</p>
<blockquote>
<ol>
<li>无论是单行还是多行的 Docstring，一概使用三个双引号扩起；</li>
<li>在 Docstring 内部，文字开始之前，以及文字结束之后，都不要有空行；</li>
<li>多行 Docstring，第一行是概要，随后空一行，再写其它部分；</li>
<li>完善的 Docstring，应该概括清楚以下内容：参数、返回值、可能触发的错误类型、可能的副作用，以及函数的使用限制等等；</li>
<li>每个参数的说明都使用单独的一行……</li>
</ol>
</blockquote>
<p>由于我们还没有开始研究 Class，所以，关于 Class 的 Docstring 应该遵守什么样的规范就暂时略过了。然而，这种规范你总是要反复去阅读参照的。关于 Docstring，有两个规范文件：</p>
<blockquote>
<ul>
<li><a href="https://www.python.org/dev/peps/pep-0257/" target="_blank" rel="noopener">PEP 257: Docstring Convensions</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0258/" target="_blank" rel="noopener">PEP 258: Docutils Design Specification</a></li>
</ul>
</blockquote>
<p>需要<strong>格外注意</strong>的是：</p>
<blockquote>
<p>Docstring 是<strong>写给人看的</strong>，所以，在复杂代码的 Docstring 中，写 <strong>Why</strong> 要远比写 <em>What</em> 更重要 —— 你先记住这点，以后的体会自然会不断加深。</p>
</blockquote>
<h2 id="Sphinx-版本的-Docstring-规范"><a href="#Sphinx-版本的-Docstring-规范" class="headerlink" title="Sphinx 版本的 Docstring 规范"></a>Sphinx 版本的 Docstring 规范</h2><p>Sphinx 可以从 <code>.py</code> 文件里提取所有 Docstring，而后生成完整的 Documentation。将来若是你写大型的项目，需要生成完善的文档的时候，你就会发现 Sphinx 是个 “救命” 的家伙，省时、省力、省心、省命……</p>
<p>在这里，没办法一下子讲清楚 Sphinx 的使用，尤其是它还用它自己的一种标记语言，reStructureText，文件尾缀使用 <code>.rst</code>……</p>
<p>但是，可以看一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    The Vehicle object contains lots of vehicles</span></span><br><span class="line"><span class="string">    :param arg: The arg is used for ...</span></span><br><span class="line"><span class="string">    :type arg: str</span></span><br><span class="line"><span class="string">    :param `*args`: The variable arguments are used for ...</span></span><br><span class="line"><span class="string">    :param `**kwargs`: The keyword arguments are used for ...</span></span><br><span class="line"><span class="string">    :ivar arg: This is where we store arg</span></span><br><span class="line"><span class="string">    :vartype arg: str</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arg, *args, **kwargs)</span>:</span></span><br><span class="line">        self.arg = arg</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cars</span><span class="params">(self, distance, destination)</span>:</span></span><br><span class="line">        <span class="string">'''We can't travel a certain distance in vehicles without fuels, so here's the fuels</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param distance: The amount of distance traveled</span></span><br><span class="line"><span class="string">        :type amount: int</span></span><br><span class="line"><span class="string">        :param bool destinationReached: Should the fuels be refilled to cover required distance?</span></span><br><span class="line"><span class="string">        :raises: :class:`RuntimeError`: Out of fuel</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :returns: A Car mileage</span></span><br><span class="line"><span class="string">        :rtype: Cars</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">help(Vehicle)</span><br></pre></td></tr></table></figure>
<pre><code>Help on class Vehicle in module __main__:

class Vehicle(builtins.object)
 |  Vehicle(arg, *args, **kwargs)
 |
 |  The Vehicle object contains lots of vehicles
 |  :param arg: The arg is used for ...
 |  :type arg: str
 |  :param `*args`: The variable arguments are used for ...
 |  :param `**kwargs`: The keyword arguments are used for ...
 |  :ivar arg: This is where we store arg
 |  :vartype arg: str
 |
 |  Methods defined here:
 |
 |  __init__(self, arg, *args, **kwargs)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |
 |  cars(self, distance, destination)
 |      We can&apos;t travel a certain distance in vehicles without fuels, so here&apos;s the fuels
 |
 |      :param distance: The amount of distance traveled
 |      :type amount: int
 |      :param bool destinationReached: Should the fuels be refilled to cover required distance?
 |      :raises: :class:`RuntimeError`: Out of fuel
 |
 |      :returns: A Car mileage
 |      :rtype: Cars
 |
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |
 |  __dict__
 |      dictionary for instance variables (if defined)
 |
 |  __weakref__
 |      list of weak references to the object (if defined)
</code></pre><p>通过插件，Sphinx 也能支持 Google Style Docstring 和 Numpy Style Docstring。</p>
<p>以下两个链接，放在这里，以便你将来查询：</p>
<blockquote>
<ul>
<li><a href="http://www.sphinx-doc.org/en/master/usage/extensions/napoleon.html" target="_blank" rel="noopener">sphinx.ext.napoleon – Support for NumPy and Google style docstrings</a></li>
<li><a href="https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html" target="_blank" rel="noopener">sphinx.ext.autodoc – Include documentation from docstrings</a></li>
</ul>
</blockquote>
<h1 id="保存到文件的函数"><a href="#保存到文件的函数" class="headerlink" title="保存到文件的函数"></a>保存到文件的函数</h1><p>写好的函数，当然最好保存起来，以便将来随时调用。</p>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>我们可以将以下内容保存到一个名为 <code>mycode.py</code> 的文件中 —— 这样可以被外部调用的 <code>.py</code> 文件，有个专门的称呼，<strong>模块</strong>（Module）—— 于是，它（任何一个 <code>.py</code> 文件）也可以被称为<em>模块</em>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># %load mycode.py</span></span><br><span class="line"><span class="comment"># 当前这个 Code Cell 中的代码，保存在当前文件夹中的 mycode.py 文件中</span></span><br><span class="line"><span class="comment"># 以下的代码，是使用 Jupyter 命令 %load mycode.py 导入到当前 Code Cell 中的：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_prime</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Return a boolean value based upon</span></span><br><span class="line"><span class="string">    whether the argument n is a prime number.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">2</span>, int(n**<span class="number">0.5</span>)+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> (n % m) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hi</span><span class="params">(*names, greeting=<span class="string">'Hello'</span>, capitalized=False)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Print a string, with a greeting to everyone.</span></span><br><span class="line"><span class="string">    :param *names: tuple of names to be greeted.</span></span><br><span class="line"><span class="string">    :param greeting: 'Hello' as default.</span></span><br><span class="line"><span class="string">    :param capitalized: Whether name should be converted to capitalized before print. False as default.</span></span><br><span class="line"><span class="string">    :returns: None</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">        <span class="keyword">if</span> capitalized:</span><br><span class="line">            name = name.capitalize()</span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;greeting&#125;</span>, <span class="subst">&#123;name&#125;</span>!'</span>)</span><br></pre></td></tr></table></figure>
<p>而后，我们就可以在其它地方这样使用（以上代码现在已经保存在当前工作目录中的 <code>mycode.py</code>）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> mycode</span><br><span class="line"></span><br><span class="line">help(mycode.is_prime)</span><br><span class="line">help(mycode.say_hi)</span><br><span class="line"></span><br><span class="line">mycode.__name__</span><br><span class="line">mycode.is_prime(<span class="number">3</span>)</span><br><span class="line">mycode.say_hi(<span class="string">'mike'</span>, <span class="string">'zoe'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Help on function is_prime in module mycode:

is_prime(n)
    Return a boolean value based upon
    whether the argument n is a prime number.

Help on function say_hi in module mycode:

say_hi(*names, greeting=&apos;Hello&apos;, capitalized=False)
    Print a string, with a greeting to everyone.
    :param *names: tuple of names to be greeted.
    :param greeting: &apos;Hello&apos; as default.
    :param capitalized: Whether name should be converted to capitalzed before print. False as default.
    :returns: None

&apos;mycode&apos;

True

Hello, mike!
Hello, zoe!
</code></pre><p>以上这个<strong>模块</strong>（<a href="https://docs.python.org/3/tutorial/modules.html" target="_blank" rel="noopener">Module</a>）的名称，就是 <code>mycode</code>。</p>
<h2 id="模块文件系统目录检索顺序"><a href="#模块文件系统目录检索顺序" class="headerlink" title="模块文件系统目录检索顺序"></a>模块文件系统目录检索顺序</h2><p>当你向 Python 说 <code>import ...</code> 的时候，它要去寻找你所指定的文件，那个文件应该是 <code>import</code> 语句后面引用的名称，再加上 <code>.py</code> 构成的名字的文件。Python 会按照以下顺序去寻找：</p>
<blockquote>
<ul>
<li>先去看看内建模块里有没有你所指定的名称；</li>
<li>如果没有，那么就按照 <code>sys.path</code> 所返回的目录列表顺序去找。</li>
</ul>
</blockquote>
<p>你可以通过以下代码查看你自己当前机器的 <code>sys.path</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path</span><br></pre></td></tr></table></figure>
<p>在 <code>sys.path</code> 所返回的目录列表中，你当前的工作目录排在第一位。</p>
<p>有时，你需要指定检索目录，因为你知道你要用的模块文件在什么位置，那么可以用 <code>sys.path.append()</code> 添加一个搜索位置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">"/My/Path/To/Module/Directory"</span>)</span><br><span class="line"><span class="keyword">import</span> my_module</span><br></pre></td></tr></table></figure>
<h2 id="系统内建的模块"><a href="#系统内建的模块" class="headerlink" title="系统内建的模块"></a>系统内建的模块</h2><p>你可以用以下代码获取系统内建模块的列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.builtin_module_names</span><br><span class="line"><span class="string">"_sre"</span> <span class="keyword">in</span> sys.builtin_module_names <span class="comment"># True</span></span><br><span class="line"><span class="string">"math"</span> <span class="keyword">in</span> sys.builtin_module_names <span class="comment"># False （根据自己电脑库的安装情况，结果会有不同）</span></span><br></pre></td></tr></table></figure>
<pre><code>(&apos;_abc&apos;,
 &apos;_ast&apos;,
 &apos;_codecs&apos;,
 &apos;_collections&apos;,
 &apos;_functools&apos;,
 &apos;_imp&apos;,
 &apos;_io&apos;,
 &apos;_locale&apos;,
 &apos;_operator&apos;,
 &apos;_signal&apos;,
 &apos;_sre&apos;,
 &apos;_stat&apos;,
 &apos;_string&apos;,
 &apos;_symtable&apos;,
 &apos;_thread&apos;,
 &apos;_tracemalloc&apos;,
 &apos;_warnings&apos;,
 &apos;_weakref&apos;,
 &apos;atexit&apos;,
 &apos;builtins&apos;,
 &apos;errno&apos;,
 &apos;faulthandler&apos;,
 &apos;gc&apos;,
 &apos;itertools&apos;,
 &apos;marshal&apos;,
 &apos;posix&apos;,
 &apos;pwd&apos;,
 &apos;sys&apos;,
 &apos;time&apos;,
 &apos;xxsubtype&apos;,
 &apos;zipimport&apos;)
True
False
</code></pre><p>跟变量名、函数名，不能与关键字重名一样，你的模块名称也最好别与系统内建模块名称重合。</p>
<h2 id="引入指定模块中的特定函数"><a href="#引入指定模块中的特定函数" class="headerlink" title="引入指定模块中的特定函数"></a>引入指定模块中的特定函数</h2><p>当你使用 <code>import mycode</code> 的时候，你向当前工作空间引入了 <code>mycode</code> 文件中定义的所有函数，相当于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mycode <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>
<p>你其实可以只引入当前需要的函数，比如，只引入 <code>is_prime()</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mycode <span class="keyword">import</span> is_prime</span><br></pre></td></tr></table></figure>
<p>这种情况下，你就不必使用 <code>mycode.is_prime()</code> 了；而是就好像这个函数就写在当前工作空间一样，直接写 <code>is_prime()</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mycode <span class="keyword">import</span> is_prime</span><br><span class="line">is_prime(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<pre><code>True
</code></pre><p>注意，如果当前目录中并没有 <code>mycode.py</code> 这个文件，那么，<code>mycode</code> 会被当作目录名再被尝试一次 —— 如果当前目录内，有个叫做 <code>mycode</code> 的目录（或称文件夹）且该目录下同时要存在一个 <a href="https://docs.python.org/3/reference/import.html#regular-packages" target="_blank" rel="noopener"><code>__init__.py</code></a> 文件（通常为空文件，用于标识本目录形成一个包含多个模块的 <strong>包</strong>（<a href="https://docs.python.org/3/reference/import.html#regular-packages" target="_blank" rel="noopener">packages</a>），它们处在一个独立的 <strong>命名空间</strong>（<a href="https://docs.python.org/3/glossary.html#term-namespace-package" target="_blank" rel="noopener">namespace</a>）），那么，<code>from mycode import *</code> 的作用就是把 <code>mycode</code> 这个文件夹中的所有 <code>.py</code> 文件全部导入……</p>
<p>如果我们想要导入 <code>foo</code> 这个目录中的 <code>bar.py</code> 这个模块文件，那么，可以这么写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> foo.bar</span><br></pre></td></tr></table></figure>
<p>或者<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> bar</span><br></pre></td></tr></table></figure></p>
<h2 id="引入并使用化名"><a href="#引入并使用化名" class="headerlink" title="引入并使用化名"></a>引入并使用化名</h2><p>有的时候，或者为了避免混淆，或者为了避免输入太多字符，我们可以为引入的函数设定 <strong>化名</strong>（alias），而后使用化名调用函数。比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mycode <span class="keyword">import</span> is_prime <span class="keyword">as</span> isp</span><br><span class="line">isp(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<pre><code>True
</code></pre><p>甚至干脆给整个模块取个化名：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> mycode <span class="keyword">as</span> m</span><br><span class="line"></span><br><span class="line">m.is_prime(<span class="number">3</span>)</span><br><span class="line">m.say_hi(<span class="string">'mike'</span>, <span class="string">'zoe'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>True
Hello, mike!
Hello, zoe!
</code></pre><h2 id="模块中不一定只有函数"><a href="#模块中不一定只有函数" class="headerlink" title="模块中不一定只有函数"></a>模块中不一定只有函数</h2><p>一个模块文件中，不一定只包含函数；它也可以包含函数之外的可执行代码。只不过，在 <code>import</code> 语句执行的时候，模块中的非函数部分的可执行代码，只执行一次。</p>
<p>有一个 Python 的彩蛋，恰好是可以用在此处的最佳例子 —— 这个模块是 <code>this</code>，它的文件名是 <a href="https://github.com/python/cpython/blob/master/Lib/this.py" target="_blank" rel="noopener"><code>this.py</code></a>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> this</span><br></pre></td></tr></table></figure>
<pre><code>The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren&apos;t special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you&apos;re Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it&apos;s a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let&apos;s do more of those!
</code></pre><p>这个 <code>this</code> 模块中的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"""Gur Mra bs Clguba, ol Gvz Crgref</span></span><br><span class="line"><span class="string">Ornhgvshy vf orggre guna htyl.</span></span><br><span class="line"><span class="string">Rkcyvpvg vf orggre guna vzcyvpvg.</span></span><br><span class="line"><span class="string">Fvzcyr vf orggre guna pbzcyrk.</span></span><br><span class="line"><span class="string">Pbzcyrk vf orggre guna pbzcyvpngrq.</span></span><br><span class="line"><span class="string">Syng vf orggre guna arfgrq.</span></span><br><span class="line"><span class="string">Fcnefr vf orggre guna qrafr.</span></span><br><span class="line"><span class="string">Ernqnovyvgl pbhagf.</span></span><br><span class="line"><span class="string">Fcrpvny pnfrf nera'g fcrpvny rabhtu gb oernx gur ehyrf.</span></span><br><span class="line"><span class="string">Nygubhtu cenpgvpnyvgl orngf chevgl.</span></span><br><span class="line"><span class="string">Reebef fubhyq arire cnff fvyragyl.</span></span><br><span class="line"><span class="string">Hayrff rkcyvpvgyl fvyraprq.</span></span><br><span class="line"><span class="string">Va gur snpr bs nzovthvgl, ershfr gur grzcgngvba gb thrff.</span></span><br><span class="line"><span class="string">Gurer fubhyq or bar-- naq cersrenoyl bayl bar --boivbhf jnl gb qb vg.</span></span><br><span class="line"><span class="string">Nygubhtu gung jnl znl abg or boivbhf ng svefg hayrff lbh'er Qhgpu.</span></span><br><span class="line"><span class="string">Abj vf orggre guna arire.</span></span><br><span class="line"><span class="string">Nygubhtu arire vf bsgra orggre guna *evtug* abj.</span></span><br><span class="line"><span class="string">Vs gur vzcyrzragngvba vf uneq gb rkcynva, vg'f n onq vqrn.</span></span><br><span class="line"><span class="string">Vs gur vzcyrzragngvba vf rnfl gb rkcynva, vg znl or n tbbq vqrn.</span></span><br><span class="line"><span class="string">Anzrfcnprf ner bar ubaxvat terng vqrn -- yrg'f qb zber bs gubfr!"""</span></span><br><span class="line"></span><br><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> (<span class="number">65</span>, <span class="number">97</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line">        d[chr(i+c)] = chr((i+<span class="number">13</span>) % <span class="number">26</span> + c)</span><br><span class="line"></span><br><span class="line">print(<span class="string">""</span>.join([d.get(c, c) <span class="keyword">for</span> c <span class="keyword">in</span> s]))</span><br></pre></td></tr></table></figure>
<p>这个 <code>this.py</code> 文件中也没有什么函数，但这个文件里所定义的变量，我们都可以在 <code>import this</code> 之后触达：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> this</span><br><span class="line">this.d</span><br><span class="line">this.s</span><br></pre></td></tr></table></figure>
<pre><code>{&apos;A&apos;: &apos;N&apos;,
 &apos;B&apos;: &apos;O&apos;,
 &apos;C&apos;: &apos;P&apos;,
 &apos;D&apos;: &apos;Q&apos;,
 &apos;E&apos;: &apos;R&apos;,
 &apos;F&apos;: &apos;S&apos;,
 &apos;G&apos;: &apos;T&apos;,
 &apos;H&apos;: &apos;U&apos;,
 &apos;I&apos;: &apos;V&apos;,
 &apos;J&apos;: &apos;W&apos;,
 &apos;K&apos;: &apos;X&apos;,
 &apos;L&apos;: &apos;Y&apos;,
 &apos;M&apos;: &apos;Z&apos;,
 &apos;N&apos;: &apos;A&apos;,
 &apos;O&apos;: &apos;B&apos;,
 &apos;P&apos;: &apos;C&apos;,
 &apos;Q&apos;: &apos;D&apos;,
 &apos;R&apos;: &apos;E&apos;,
 &apos;S&apos;: &apos;F&apos;,
 &apos;T&apos;: &apos;G&apos;,
 &apos;U&apos;: &apos;H&apos;,
 &apos;V&apos;: &apos;I&apos;,
 &apos;W&apos;: &apos;J&apos;,
 &apos;X&apos;: &apos;K&apos;,
 &apos;Y&apos;: &apos;L&apos;,
 &apos;Z&apos;: &apos;M&apos;,
 &apos;a&apos;: &apos;n&apos;,
 &apos;b&apos;: &apos;o&apos;,
 &apos;c&apos;: &apos;p&apos;,
 &apos;d&apos;: &apos;q&apos;,
 &apos;e&apos;: &apos;r&apos;,
 &apos;f&apos;: &apos;s&apos;,
 &apos;g&apos;: &apos;t&apos;,
 &apos;h&apos;: &apos;u&apos;,
 &apos;i&apos;: &apos;v&apos;,
 &apos;j&apos;: &apos;w&apos;,
 &apos;k&apos;: &apos;x&apos;,
 &apos;l&apos;: &apos;y&apos;,
 &apos;m&apos;: &apos;z&apos;,
 &apos;n&apos;: &apos;a&apos;,
 &apos;o&apos;: &apos;b&apos;,
 &apos;p&apos;: &apos;c&apos;,
 &apos;q&apos;: &apos;d&apos;,
 &apos;r&apos;: &apos;e&apos;,
 &apos;s&apos;: &apos;f&apos;,
 &apos;t&apos;: &apos;g&apos;,
 &apos;u&apos;: &apos;h&apos;,
 &apos;v&apos;: &apos;i&apos;,
 &apos;w&apos;: &apos;j&apos;,
 &apos;x&apos;: &apos;k&apos;,
 &apos;y&apos;: &apos;l&apos;,
 &apos;z&apos;: &apos;m&apos;}

&quot;Gur Mra bs Clguba, ol Gvz Crgref\n\nOrnhgvshy vf orggre guna htyl.\nRkcyvpvg vf orggre guna vzcyvpvg.\nFvzcyr vf orggre guna pbzcyrk.\nPbzcyrk vf orggre guna pbzcyvpngrq.\nSyng vf orggre guna arfgrq.\nFcnefr vf orggre guna qrafr.\nErnqnovyvgl pbhagf.\nFcrpvny pnfrf nera&apos;g fcrpvny rabhtu gb oernx gur ehyrf.\nNygubhtu cenpgvpnyvgl orngf chevgl.\nReebef fubhyq arire cnff fvyragyl.\nHayrff rkcyvpvgyl fvyraprq.\nVa gur snpr bs nzovthvgl, ershfr gur grzcgngvba gb thrff.\nGurer fubhyq or bar-- naq cersrenoyl bayl bar --boivbhf jnl gb qb vg.\nNygubhtu gung jnl znl abg or boivbhf ng svefg hayrff lbh&apos;er Qhgpu.\nAbj vf orggre guna arire.\nNygubhtu arire vf bsgra orggre guna *evtug* abj.\nVs gur vzcyrzragngvba vf uneq gb rkcynva, vg&apos;f n onq vqrn.\nVs gur vzcyrzragngvba vf rnfl gb rkcynva, vg znl or n tbbq vqrn.\nAnzrfcnprf ner bar ubaxvat terng vqrn -- yrg&apos;f qb zber bs gubfr!&quot;
</code></pre><p>试试吧，试试能否独立读懂这个文件里的代码 —— 对初学者来说，还是挺练脑子的呢！</p>
<p>它先是通过一个规则生成了一个密码表，保存在 <code>d</code> 这个字典中；而后，将 <code>s</code> 这个变量中保存的 “密文” 翻译成了英文……</p>
<p>或许，你可以试试，看看怎样能写个函数出来，给你一段英文，你可以把它加密成跟它一样的 “密文”？</p>
<h2 id="dir-函数"><a href="#dir-函数" class="headerlink" title="dir() 函数"></a>dir() 函数</h2><p>你的函数，保存在模块里之后，这个函数的用户（当然也包括你），可以用 <code>dir()</code> 函数查看模块中可触达的变量名称和函数名称：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mycode</span><br><span class="line">dir(mycode)</span><br></pre></td></tr></table></figure>
<pre><code>[&apos;__builtins__&apos;,
 &apos;__cached__&apos;,
 &apos;__doc__&apos;,
 &apos;__file__&apos;,
 &apos;__loader__&apos;,
 &apos;__name__&apos;,
 &apos;__package__&apos;,
 &apos;__spec__&apos;,
 &apos;is_prime&apos;,
 &apos;say_hi&apos;]
</code></pre><h1 id="测试驱动的开发"><a href="#测试驱动的开发" class="headerlink" title="测试驱动的开发"></a>测试驱动的开发</h1><p>写一个函数，或者写一个程序，换一种说法，其实就是 “实现一个算法” —— 而所谓的 “算法”，Wikipedia 上的定义是这样的：</p>
<blockquote>
<p>In mathematics and computer science, an <strong>algorithm</strong> is an unambiguous specification of how to solve a class of problems. Algorithms can perform <em>calculation</em>, <em>data processing</em>, and <em>automated reasoning tasks</em>.</p>
</blockquote>
<p>“算法”，其实没多神秘，就是 “解决问题的步骤” 而已。</p>
<p>在第二部分的第一章里，我们看过一个判断是否为闰年的函数：</p>
<blockquote>
<p>让我们写个判断闰年年份的函数，取名为 is_leap()，它接收一个年份为参数，若是闰年，则返回 True，否则返回 False。</p>
<p>根据闰年的定义：</p>
<blockquote>
<ul>
<li>年份应该是 4 的倍数；</li>
<li>年份能被 100 整除但不能被 400 整除的，不是闰年。</li>
<li>所以，相当于要在能被 4 整除的年份中，排除那些能被 100 整除却不能被 400 整除的年份。</li>
</ul>
</blockquote>
</blockquote>
<p>不要往回翻！现在自己动手尝试着写出这个函数？你会发现其实并不容易的……</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_leap</span><span class="params">(year)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>第一步，跟很多人想象得不一样，第一步不是上来就开始写……</p>
<p>第一步是先假定这个函数写完了，我们需要验证它返回的结果对不对……</p>
<p>这种 “通过先想办法验证结果而后从结果倒推” 的开发方式，是一种很有效的方法论，叫做 “Test Driven Development”，以测试为驱动的开发。</p>
<p>如果我写的 <code>is_leap(year)</code> 是正确的，那么：</p>
<blockquote>
<ul>
<li><code>is_leap(4)</code> 的返回值应该是 <code>True</code></li>
<li><code>is_leap(200)</code> 的返回值应该是 <code>False</code></li>
<li><code>is_leap(220)</code> 的返回值应该是 <code>True</code></li>
<li><code>is_leap(400)</code> 的返回值应该是 <code>True</code></li>
</ul>
</blockquote>
<p>能够罗列出以上四种情况，其实只不过是根据算法 “考虑全面” 之后的结果 —— 但你自己试试就知道了，无论多简单的事，想要 “考虑全面” 好像并不容易……</p>
<p>所以，在写 <code>def is_leap(year)</code> 中的内容之前，我只是用 <code>pass</code> 先把位置占上，而后在后面添加了四个用来测试结果的语句 —— 它们的值，现在当然都是 <code>False</code>…… 等我把整个函数写完了，写正确了，那么它们的值就都应该变成 <code>True</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_leap</span><span class="params">(year)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">is_leap(<span class="number">4</span>) <span class="keyword">is</span> <span class="literal">True</span></span><br><span class="line">is_leap(<span class="number">200</span>) <span class="keyword">is</span> <span class="literal">False</span></span><br><span class="line">is_leap(<span class="number">220</span>) <span class="keyword">is</span> <span class="literal">True</span></span><br><span class="line">is_leap(<span class="number">400</span>) <span class="keyword">is</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<pre><code>False

False

False

False
</code></pre><p>考虑到更多的年份不是闰年，所以，排除顺序大抵上应该是这样：</p>
<blockquote>
<ul>
<li>先假定都不是闰年；</li>
<li>再看看是否能被 <code>4</code> 整除；</li>
<li>再剔除那些能被 <code>100</code> 整除但不能被 <code>400</code> 整除的年份……</li>
</ul>
</blockquote>
<p>于是，先实现第一句：“先假定都不是闰年”：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_leap</span><span class="params">(year)</span>:</span></span><br><span class="line">    r = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line">is_leap(<span class="number">4</span>) <span class="keyword">is</span> <span class="literal">True</span></span><br><span class="line">is_leap(<span class="number">200</span>) <span class="keyword">is</span> <span class="literal">False</span></span><br><span class="line">is_leap(<span class="number">220</span>) <span class="keyword">is</span> <span class="literal">True</span></span><br><span class="line">is_leap(<span class="number">400</span>) <span class="keyword">is</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<pre><code>False
True
False
False
</code></pre><p>然后再实现这部分：“年份应该是 4 的倍数”：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_leap</span><span class="params">(year)</span>:</span></span><br><span class="line">    r = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> year % <span class="number">4</span> == <span class="number">0</span>:</span><br><span class="line">        r = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line">is_leap(<span class="number">4</span>) <span class="keyword">is</span> <span class="literal">True</span></span><br><span class="line">is_leap(<span class="number">200</span>) <span class="keyword">is</span> <span class="literal">False</span></span><br><span class="line">is_leap(<span class="number">220</span>) <span class="keyword">is</span> <span class="literal">True</span></span><br><span class="line">is_leap(<span class="number">400</span>) <span class="keyword">is</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<pre><code>True
False
True
True
</code></pre><p>现在剩下最后一条了：“剔除那些能被 <code>100</code> 整除但不能被 <code>400</code> 整除的年份”…… 拿一个参数值，比如，<code>200</code> 为例：</p>
<blockquote>
<ul>
<li>因为它能被 <code>4</code> 整除，所以，使 <code>r = True</code>，</li>
<li>然后再看它是否能被 <code>100</code> 整除 —— 能 —— 既然如此再看它能不能被 <code>400</code> 整除，<ul>
<li>如果不能，那就让 <code>r = False</code>；</li>
<li>如果能，就保留 <code>r</code> 的值……<br>如此这般，<code>200</code> 肯定使得 <code>r = False</code>。</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_leap</span><span class="params">(year)</span>:</span></span><br><span class="line">    r = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> year % <span class="number">4</span> == <span class="number">0</span>:</span><br><span class="line">        r = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> year % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> year % <span class="number">400</span> !=<span class="number">0</span>:</span><br><span class="line">                r = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line"></span><br><span class="line">is_leap(<span class="number">4</span>) <span class="keyword">is</span> <span class="literal">True</span></span><br><span class="line">is_leap(<span class="number">200</span>) <span class="keyword">is</span> <span class="literal">False</span></span><br><span class="line">is_leap(<span class="number">220</span>) <span class="keyword">is</span> <span class="literal">True</span></span><br><span class="line">is_leap(<span class="number">400</span>) <span class="keyword">is</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<pre><code>True
True
True
True
</code></pre><p>尽管整个过程读起来很直观，但真的要自己从头到尾操作，就可能四处出错，不信你就试试 —— 这一页最下面添加一个单元格，自己动手从头写到尾试试……</p>
<p>当然，Python 内建库中的 <code>datetime.py</code> 模块里的代码更简洁，之前给你看过：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cpython/Lib/datetime.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_is_leap</span><span class="params">(year)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> year % <span class="number">4</span> == <span class="number">0</span> <span class="keyword">and</span> (year % <span class="number">100</span> != <span class="number">0</span> <span class="keyword">or</span> year % <span class="number">400</span> == <span class="number">0</span>)</span><br><span class="line">_is_leap(<span class="number">300</span>)</span><br></pre></td></tr></table></figure>
<pre><code>False
</code></pre><p>你自己动手，从写测试开始，逐步把它实现出来试试？—— 肯定不能允许你拷贝粘贴，哈哈。</p>
<p>在 Python 语言中，有专门用来 “试错” 的流程控制 —— 今天的绝大多数编程语言都有这种 “试错语句”。</p>
<p>当一个程序开始执行的时候，有两种错误可能会导致程序执行失败：</p>
<blockquote>
<ul>
<li>语法错误（Syntax Errors）</li>
<li>意外（Exceptions）</li>
</ul>
</blockquote>
<p>比如，在 Python3 中，你写 <code>print i</code>，而没有写 <code>print(i)</code>，那么你犯的是语法错误，于是，解析器会直接提醒你，你在第几行犯了什么样的语法错误。语法错误存在的时候，程序无法启动执行。</p>
<p>但是，有时会出现这种情况：语法上完全正确，但出现了<strong>意外</strong>。这种错误，都是程序已经执行之后才发生的（Runtime Errors）—— 因为只要没有语法错误，程序就可以启动。比如，你写的是 <code>print(11/0)</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="number">11</span>/<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<pre><code>---------------------------------------------------------------------------

ZeroDivisionError                         Traceback (most recent call last)

&lt;ipython-input-2-5544d98276be&gt; in &lt;module&gt;
----&gt; 1 print(11/0)

ZeroDivisionError: division by zero
</code></pre><p>虽然这个语句本身没有语法错误，但这个表达式是不能被处理的。于是，它触发了 <code>ZeroDivisionError</code>，这个 “意外” 使得程序不可能继续执行下去。</p>
<p>在 Python 中，定义了大量的常见 “意外”，并且按层级分类：</p>
<blockquote>
<p>在第三部分阅读完毕之后，可以回来重新查看以下官方文档：<br><br><a href="https://docs.python.org/3/library/exceptions.html" target="_blank" rel="noopener">https://docs.python.org/3/library/exceptions.html</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">BaseException</span><br><span class="line"> +-- SystemExit</span><br><span class="line"> +-- KeyboardInterrupt</span><br><span class="line"> +-- GeneratorExit</span><br><span class="line"> +-- Exception</span><br><span class="line">      +-- StopIteration</span><br><span class="line">      +-- StopAsyncIteration</span><br><span class="line">      +-- ArithmeticError</span><br><span class="line">      |    +-- FloatingPointError</span><br><span class="line">      |    +-- OverflowError</span><br><span class="line">      |    +-- ZeroDivisionError</span><br><span class="line">      +-- AssertionError</span><br><span class="line">      +-- AttributeError</span><br><span class="line">      +-- BufferError</span><br><span class="line">      +-- EOFError</span><br><span class="line">      +-- ImportError</span><br><span class="line">      |    +-- ModuleNotFoundError</span><br><span class="line">      +-- LookupError</span><br><span class="line">      |    +-- IndexError</span><br><span class="line">      |    +-- KeyError</span><br><span class="line">      +-- MemoryError</span><br><span class="line">      +-- NameError</span><br><span class="line">      |    +-- UnboundLocalError</span><br><span class="line">      +-- OSError</span><br><span class="line">      |    +-- BlockingIOError</span><br><span class="line">      |    +-- ChildProcessError</span><br><span class="line">      |    +-- ConnectionError</span><br><span class="line">      |    |    +-- BrokenPipeError</span><br><span class="line">      |    |    +-- ConnectionAbortedError</span><br><span class="line">      |    |    +-- ConnectionRefusedError</span><br><span class="line">      |    |    +-- ConnectionResetError</span><br><span class="line">      |    +-- FileExistsError</span><br><span class="line">      |    +-- FileNotFoundError</span><br><span class="line">      |    +-- InterruptedError</span><br><span class="line">      |    +-- IsADirectoryError</span><br><span class="line">      |    +-- NotADirectoryError</span><br><span class="line">      |    +-- PermissionError</span><br><span class="line">      |    +-- ProcessLookupError</span><br><span class="line">      |    +-- TimeoutError</span><br><span class="line">      +-- ReferenceError</span><br><span class="line">      +-- RuntimeError</span><br><span class="line">      |    +-- NotImplementedError</span><br><span class="line">      |    +-- RecursionError</span><br><span class="line">      +-- SyntaxError</span><br><span class="line">      |    +-- IndentationError</span><br><span class="line">      |         +-- TabError</span><br><span class="line">      +-- SystemError</span><br><span class="line">      +-- TypeError</span><br><span class="line">      +-- ValueError</span><br><span class="line">      |    +-- UnicodeError</span><br><span class="line">      |         +-- UnicodeDecodeError</span><br><span class="line">      |         +-- UnicodeEncodeError</span><br><span class="line">      |         +-- UnicodeTranslateError</span><br><span class="line">      +-- Warning</span><br><span class="line">           +-- DeprecationWarning</span><br><span class="line">           +-- PendingDeprecationWarning</span><br><span class="line">           +-- RuntimeWarning</span><br><span class="line">           +-- SyntaxWarning</span><br><span class="line">           +-- UserWarning</span><br><span class="line">           +-- FutureWarning</span><br><span class="line">           +-- ImportWarning</span><br><span class="line">           +-- UnicodeWarning</span><br><span class="line">           +-- BytesWarning</span><br><span class="line">           +-- ResourceWarning</span><br></pre></td></tr></table></figure>
<p>拿 <code>FileNotFoundError</code> 为例 —— 当我们想要打开一个文件之前，其实应该有个办法提前验证一下那个文件是否存在。如果那个文件并不存在，就会引发 “意外”。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'test_file.txt'</span>, <span class="string">'r'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>---------------------------------------------------------------------------

FileNotFoundError                         Traceback (most recent call last)

&lt;ipython-input-3-5fac19176fe6&gt; in &lt;module&gt;
----&gt; 1 f = open(&apos;test_file.txt&apos;, &apos;r&apos;)

FileNotFoundError: [Errno 2] No such file or directory: &apos;test_file.txt&apos;
</code></pre><p>在 Python 中，我们可以用 <code>try</code> 语句块去执行那些可能出现 “意外” 的语句，<code>try</code> 也可以配合 <code>except</code>、<code>else</code>、<code>finally</code> 使用。从另外一个角度看，<code>try</code> 语句块也是一种特殊的流程控制，专注于 “当意外发生时应该怎么办？”</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = open(<span class="string">'test_file.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError <span class="keyword">as</span> fnf_error:</span><br><span class="line">    print(fnf_error)</span><br></pre></td></tr></table></figure>
<pre><code>[Errno 2] No such file or directory: &apos;test_file.txt&apos;
</code></pre><p>如此这般的结果是：</p>
<blockquote>
<p>当程序中的语句 <code>f = open(&#39;test_file.txt&#39;, &#39;r&#39;)</code> 因为 <code>test_file.txt</code> 不存在而引发意外之时，<code>except</code> 语句块会接管流程；而后，又因为在 <code>except</code> 语句块中我们指定了 <code>FileNotFoundError</code>，所以，若是 <code>FileNotFoundError</code> 真的发生了，那么，<code>except</code> 语句块中的代码，即，<code>print(fnf_error)</code> 会被执行……</p>
</blockquote>
<p>你可以用的试错流程还有以下变种：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    do_something()</span><br><span class="line"><span class="keyword">except</span> built_in_error <span class="keyword">as</span> name_of_error:</span><br><span class="line">    do_something()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    do_something()</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    do_something()</span><br><span class="line"><span class="keyword">except</span> built_in_error <span class="keyword">as</span> name_of_error:</span><br><span class="line">    do_something()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    do_something()</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    do_something()</span><br></pre></td></tr></table></figure>
<p>甚至可以嵌套：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    do_something()</span><br><span class="line"><span class="keyword">except</span> built_in_error <span class="keyword">as</span> name_of_error:</span><br><span class="line">    do_something()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        do_something()</span><br><span class="line">    <span class="keyword">except</span> built_in_error <span class="keyword">as</span> name_of_error:</span><br><span class="line">        do_something()</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>更多关于错误处理的内容，请在阅读完第三部分中与 Class 相关的内容之后，再去详细阅读以下官方文档：</p>
<blockquote>
<ul>
<li><a href="docs.python.org/3/tutorial/errors.html">Errors and Exceptions</a></li>
<li><a href="https://docs.python.org/3/library/exceptions.html" target="_blank" rel="noopener">Built-in Exceptions</a></li>
<li><a href="https://wiki.python.org/moin/HandlingExceptions" target="_blank" rel="noopener">Handling Exceptions</a></li>
</ul>
</blockquote>
<p>理论上，这一章不应该套上这么大的标题：《测试驱动开发》，因为在实际开发过程中，所谓测试驱动开发要使用更为强大更为复杂的模块、框架和工具，比如，起码使用 Python 内建库中的 <a href="https://docs.python.org/3/library/unittest.html" target="_blank" rel="noopener">unittest</a> 模块。</p>
<p>在写程序的过程中，为别人（和将来的自己）写注释、写 Docstring；在写程序的过程中，为了保障程序的结果全面正确而写测试；或者干脆在最初写的时候就考虑到各种意外所以使用试错语句块 —— 这些明明是天经地义的事情，却是绝大多数人不做的…… 因为感觉有点麻烦。</p>
<p>这里是 “聪明反被聪明误” 的最好示例长期堆积的地方。很多人真的是因为自己很聪明，所以才觉得 “没必要麻烦” —— 这就好像当年苏格拉底仗着自己记忆力无比强大甚至干脆过目不忘于是鄙视一切记笔记的人一样。</p>
<p>但是，随着时间的推移，随着工程量的放大，到最后，那些 “聪明人” 都被自己坑死了 —— 聪明本身搞不定工程，能搞定工程的是智慧。苏格拉底自己并没完成任何工程，是他的学生柏拉图不顾他的嘲笑用纸笔记录了一切；而后柏拉图的学生亚里士多德才有机会受到苏格拉底的启发，写了《前分析篇》，提出对人类影响至今的 “三段论”……</p>
<p>千万不要因为这第二部分中所举的例子太容易而把自己迷惑了。刻意选择简单的例子放在这里，是为了让读者更容易集中精力去理解关于自己动手写函数的方方面面 —— 可将来你自己真的动手去做，哪怕真的去阅读真实的工程代码，你就会发现，难度还是很高的。现在的轻敌，会造成以后的溃败。</p>
<p>现在还不是时候，等你把整本书都完成之后，记得回来再看这个链接：</p>
<blockquote>
<ul>
<li><a href="https://docs.python.org/3/library/doctest.html" target="_blank" rel="noopener">doctest —— Test interactive Python examples</a></li>
<li><a href="https://docs.python.org/3/library/unittest.html" target="_blank" rel="noopener">unittest —— Unit testing framework</a></li>
</ul>
</blockquote>
<h1 id="可执行的-Python-文件"><a href="#可执行的-Python-文件" class="headerlink" title="可执行的 Python 文件"></a>可执行的 Python 文件</h1><p>理论上来讲，你最终可以把任何一个程序，无论大小，都封装（或者囊括）到仅仅一个函数之中。按照惯例（Convention），这个函数的名称叫做 <code>main()</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">routine_1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Routine 1 done.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">routine_2</span><span class="params">()</span>:</span></span><br><span class="line">    sub_routine_1()</span><br><span class="line">    sub_routine_2()</span><br><span class="line">    print(<span class="string">'Routine 2 done.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub_routine_1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Sub-routine 1 done.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub_routine_2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Sub-routine 2 done.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    routine_1()</span><br><span class="line">    routine_2()</span><br><span class="line">    print(<span class="string">'This is the end of the program.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<pre><code>Routine 1 done.
Sub-routine 1 done.
Sub-routine 2 done.
Routine 2 done.
This is the end of the program.
</code></pre><p>当一个模块（其实就是存有 Python 代码的 <code>.py</code> 文件，例如：<code>mycode.py</code>）被 <code>import</code> 语句导入的时候，这个模块的 <code>__name__</code> 就是模块名（例如：<code>&#39;mycode&#39;</code>）。</p>
<p>而当一个模块被命令行运行的时候，这个模块的 <code>__name__</code> 就被 Python 解释器设定为 <code>&#39;__main__&#39;</code>。</p>
<p>把一个程序整个封装到 <code>main()</code> 之中，而后在模块代码里加上：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>这么做的结果是：</p>
<blockquote>
<ol>
<li>当 Python 文件被当作模块，被 <code>import</code> 语句导入时，<code>if</code> 判断失败，<code>main()</code> 函数不被执行；</li>
<li>当 Python 文件被 <code>python -m</code> 运行的时候，<code>if</code> 判断成功，<code>main()</code> 函数才被执行。</li>
</ol>
</blockquote>
<p>还记得那个 Python 的彩蛋吧？<code>this.py</code> 的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"""Gur Mra bs Clguba, ol Gvz Crgref</span></span><br><span class="line"><span class="string">Ornhgvshy vf orggre guna htyl.</span></span><br><span class="line"><span class="string">Rkcyvpvg vf orggre guna vzcyvpvg.</span></span><br><span class="line"><span class="string">Fvzcyr vf orggre guna pbzcyrk.</span></span><br><span class="line"><span class="string">Pbzcyrk vf orggre guna pbzcyvpngrq.</span></span><br><span class="line"><span class="string">Syng vf orggre guna arfgrq.</span></span><br><span class="line"><span class="string">Fcnefr vf orggre guna qrafr.</span></span><br><span class="line"><span class="string">Ernqnovyvgl pbhagf.</span></span><br><span class="line"><span class="string">Fcrpvny pnfrf nera'g fcrpvny rabhtu gb oernx gur ehyrf.</span></span><br><span class="line"><span class="string">Nygubhtu cenpgvpnyvgl orngf chevgl.</span></span><br><span class="line"><span class="string">Reebef fubhyq arire cnff fvyragyl.</span></span><br><span class="line"><span class="string">Hayrff rkcyvpvgyl fvyraprq.</span></span><br><span class="line"><span class="string">Va gur snpr bs nzovthvgl, ershfr gur grzcgngvba gb thrff.</span></span><br><span class="line"><span class="string">Gurer fubhyq or bar-- naq cersrenoyl bayl bar --boivbhf jnl gb qb vg.</span></span><br><span class="line"><span class="string">Nygubhtu gung jnl znl abg or boivbhf ng svefg hayrff lbh'er Qhgpu.</span></span><br><span class="line"><span class="string">Abj vf orggre guna arire.</span></span><br><span class="line"><span class="string">Nygubhtu arire vf bsgra orggre guna *evtug* abj.</span></span><br><span class="line"><span class="string">Vs gur vzcyrzragngvba vf uneq gb rkcynva, vg'f n onq vqrn.</span></span><br><span class="line"><span class="string">Vs gur vzcyrzragngvba vf rnfl gb rkcynva, vg znl or n tbbq vqrn.</span></span><br><span class="line"><span class="string">Anzrfcnprf ner bar ubaxvat terng vqrn -- yrg'f qb zber bs gubfr!"""</span></span><br><span class="line"></span><br><span class="line">d = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> (<span class="number">65</span>, <span class="number">97</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line">        d[chr(i+c)] = chr((i+<span class="number">13</span>) % <span class="number">26</span> + c)</span><br><span class="line"></span><br><span class="line">print(<span class="string">""</span>.join([d.get(c, c) <span class="keyword">for</span> c <span class="keyword">in</span> s]))</span><br></pre></td></tr></table></figure>
<p>所以，只要 <code>import this</code>，<code>this.py</code> 中的代码就被执行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> this</span><br></pre></td></tr></table></figure>
<p>我在当前目录下，保存了一个文件 <code>that.py</code>，它的内容如下 —— 其实就是把 <code>this.py</code> 之中的代码封装到 <code>main()</code> 函数中了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># %load that.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    s = <span class="string">"""Gur Mra bs Clguba, ol Gvz Crgref</span></span><br><span class="line"><span class="string">    Ornhgvshy vf orggre guna htyl.</span></span><br><span class="line"><span class="string">    Rkcyvpvg vf orggre guna vzcyvpvg.</span></span><br><span class="line"><span class="string">    Fvzcyr vf orggre guna pbzcyrk.</span></span><br><span class="line"><span class="string">    Pbzcyrk vf orggre guna pbzcyvpngrq.</span></span><br><span class="line"><span class="string">    Syng vf orggre guna arfgrq.</span></span><br><span class="line"><span class="string">    Fcnefr vf orggre guna qrafr.</span></span><br><span class="line"><span class="string">    Ernqnovyvgl pbhagf.</span></span><br><span class="line"><span class="string">    Fcrpvny pnfrf nera'g fcrpvny rabhtu gb oernx gur ehyrf.</span></span><br><span class="line"><span class="string">    Nygubhtu cenpgvpnyvgl orngf chevgl.</span></span><br><span class="line"><span class="string">    Reebef fubhyq arire cnff fvyragyl.</span></span><br><span class="line"><span class="string">    Hayrff rkcyvpvgyl fvyraprq.</span></span><br><span class="line"><span class="string">    Va gur snpr bs nzovthvgl, ershfr gur grzcgngvba gb thrff.</span></span><br><span class="line"><span class="string">    Gurer fubhyq or bar-- naq cersrenoyl bayl bar --boivbhf jnl gb qb vg.</span></span><br><span class="line"><span class="string">    Nygubhtu gung jnl znl abg or boivbhf ng svefg hayrff lbh'er Qhgpu.</span></span><br><span class="line"><span class="string">    Abj vf orggre guna arire.</span></span><br><span class="line"><span class="string">    Nygubhtu arire vf bsgra orggre guna *evtug* abj.</span></span><br><span class="line"><span class="string">    Vs gur vzcyrzragngvba vf uneq gb rkcynva, vg'f n onq vqrn.</span></span><br><span class="line"><span class="string">    Vs gur vzcyrzragngvba vf rnfl gb rkcynva, vg znl or n tbbq vqrn.</span></span><br><span class="line"><span class="string">    Anzrfcnprf ner bar ubaxvat terng vqrn -- yrg'f qb zber bs gubfr!"""</span></span><br><span class="line"></span><br><span class="line">    d = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> (<span class="number">65</span>, <span class="number">97</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">26</span>):</span><br><span class="line">            d[chr(i+c)] = chr((i+<span class="number">13</span>) % <span class="number">26</span> + c)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">""</span>.join([d.get(c, c) <span class="keyword">for</span> c <span class="keyword">in</span> s]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>于是，当你在其它地方导入它的时候，<code>import that</code>，<code>main()</code> 函数的内容不会被执行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> that</span><br></pre></td></tr></table></figure>
<p>但是，你在命令行中，用 <code>python that.py</code>，或者 <code>python -m that</code> 将 <code>that.py</code> 当作可执行模块运行的时候，<code>main()</code> 就会被执行 —— 注意，不要写错，<code>python -m that.py</code> 会报错的 —— 有 <code>-m</code> 参数，就不要写文件尾缀 <code>.py</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%%bash</span><br><span class="line">python that.py</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%%bash</span><br><span class="line">python -m that</span><br></pre></td></tr></table></figure>
<p>像 <code>that.py</code> 那样把整个程序放进 <code>main()</code> 函数之后，<code>import that</code> 不会自动执行 main 函数里的代码。不过，你可以调用 that.main()：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> that</span><br><span class="line">that.main()</span><br></pre></td></tr></table></figure>
<p>当然，<code>that.py</code> 之中没有任何 Docstring，所以 <code>help(that)</code> 的结果是这样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> that</span><br><span class="line">help(that)</span><br></pre></td></tr></table></figure>
<p>所以，之前那个从 37 万多个词汇中挑出 3700 多个字母加起来等于 100 的词汇的程序，也可以写成以下形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_of_word</span><span class="params">(word)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">        sum += ord(char) - <span class="number">96</span></span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(wordlist, result)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(result, <span class="string">'w'</span>) <span class="keyword">as</span> result:</span><br><span class="line">        <span class="keyword">with</span> open(wordlist, <span class="string">'r'</span>) <span class="keyword">as</span> file:</span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> file.readlines():</span><br><span class="line">                <span class="keyword">if</span> sum_of_word(word.strip()) == <span class="number">100</span>:</span><br><span class="line">                    result.write(word)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main(<span class="string">'words_alpha.txt'</span>, <span class="string">'results.txt'</span>)</span><br></pre></td></tr></table></figure>
<p>至于以上代码中的第一行，<code>#!/usr/bin/env python</code> 是怎么回事，建议你自己动手解决一下，去 Google：</p>
<blockquote>
<p><a href="https://www.google.com/search?q=python3+script+executable" target="_blank" rel="noopener"><code>python3 script executable</code></a></p>
</blockquote>
<p>你会很快弄明白的……</p>
<p>另外，再搜索一下：</p>
<blockquote>
<p><a href="https://www.google.com/search?q=python3+script+executable+parameters+retrieving" target="_blank" rel="noopener"><code>python3 script executable parameters retrieving</code></a></p>
</blockquote>
<p>你就可以把以上程序改成在命令行下能够接收指定参数的 Python 可执行文件……</p>
<p>顺带说，<code>import this</code> 的彩蛋有更好玩的玩法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> this</span><br><span class="line">love = this</span><br><span class="line">this <span class="keyword">is</span> love                            <span class="comment"># True</span></span><br><span class="line">love <span class="keyword">is</span> <span class="literal">True</span>                            <span class="comment"># False</span></span><br><span class="line">love <span class="keyword">is</span> <span class="literal">False</span>                           <span class="comment"># False</span></span><br><span class="line">love <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">True</span> <span class="keyword">or</span> <span class="literal">False</span>               <span class="comment"># True</span></span><br><span class="line">love <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">True</span> <span class="keyword">or</span> <span class="literal">False</span>; love <span class="keyword">is</span> love <span class="comment"># True True</span></span><br></pre></td></tr></table></figure>
<pre><code>True
False
False
True
True
True
</code></pre><p>在 Terminal 里输入 <code>python ⏎</code> 而后在 Interactive Shell 里逐句输入试试。<code>love = this</code> 后面的每一句，都是布尔运算，想想看为什么是那样的结果？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> this</span><br><span class="line">love = this</span><br><span class="line"></span><br><span class="line">this <span class="keyword">is</span> love</span><br><span class="line"><span class="comment"># True, 试试看，id(this) 和 id(love) 是同一个值</span></span><br><span class="line"><span class="comment"># 即，它们的内存地址相同</span></span><br><span class="line"></span><br><span class="line">love <span class="keyword">is</span> <span class="literal">True</span></span><br><span class="line"><span class="comment"># False, id(love) 和 id(True) 不是同一个值</span></span><br><span class="line">love <span class="keyword">is</span> <span class="literal">False</span></span><br><span class="line"><span class="comment"># 同上</span></span><br><span class="line"></span><br><span class="line">love <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">True</span> <span class="keyword">or</span> <span class="literal">False</span></span><br><span class="line"><span class="comment"># is not 的优先级比 or 高；所以相当于是：</span></span><br><span class="line"><span class="comment"># (love is not True) or False，于是返回 True</span></span><br><span class="line"></span><br><span class="line">love <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">True</span> <span class="keyword">or</span> <span class="literal">False</span>; love <span class="keyword">is</span> love</span><br><span class="line"><span class="comment"># 重复一次上一句 —— `;` 是语句分隔符</span></span><br><span class="line"><span class="comment"># 而后 love is love 当然是 True</span></span><br></pre></td></tr></table></figure>
<p>注意以下代码中，<code>id()</code> 函数的输出结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> this</span><br><span class="line">love = this</span><br><span class="line">this <span class="keyword">is</span> love</span><br><span class="line">love <span class="keyword">is</span> <span class="literal">True</span></span><br><span class="line">love <span class="keyword">is</span> <span class="literal">False</span></span><br><span class="line">love <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">True</span> <span class="keyword">or</span> <span class="literal">False</span></span><br><span class="line">love <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">True</span> <span class="keyword">or</span> <span class="literal">False</span>; love <span class="keyword">is</span> love</span><br><span class="line">id(love)</span><br><span class="line">id(this)</span><br><span class="line">id(<span class="literal">True</span>)</span><br><span class="line">id(<span class="literal">False</span>)</span><br><span class="line">love <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<pre><code>True
False
False
True
True
True
4345330968
4345330968
4308348176
4308349120
True
</code></pre><p>Python 的操作符优先级，完整表格在这里：</p>
<blockquote>
<p><a href="https://docs.python.org/3/reference/expressions.html#operator-precedence" target="_blank" rel="noopener">Operator precedence</a></p>
</blockquote>
<p>Python 的更多彩蛋：</p>
<blockquote>
<p><a href="https://github.com/OrkoHunter/python-easter-eggs" target="_blank" rel="noopener">Python Easter Eggs</a></p>
</blockquote>
<h1 id="刻意思考"><a href="#刻意思考" class="headerlink" title="刻意思考"></a>刻意思考</h1><p>随着时间的推移，你会体会到它的威力：</p>
<blockquote>
<p>刻意思考哪儿需要刻意练习</p>
</blockquote>
<p>只不过是一句话而已，却因知道或不知道，竟然会逐渐形成天壤之别的差异，也是神奇。</p>
<p>刻意思考，就是所谓的琢磨。琢磨这事，一旦开始就简单得要死，可无从下手的时候就神秘无比。让我们再看一个 “刻意思考” —— 即，琢磨 —— 的应用领域：</p>
<blockquote>
<p><strong>这东西能用在哪儿呢？</strong></p>
</blockquote>
<p>很多人学了却没怎么练，有一个很现实的原因 —— 没什么地方用得上。</p>
<p>这也怪我们的应试教育，大学前上 12 年学，“学”（更多是被逼的）的绝大多数东西，只有一个能够切实体会到的用处，考试 —— 中考、高考，以及以它们为目标的无数 “模考”…… 于是，反过来，不管学什么东西，除了考试之外，几乎无法想象其他的用处。</p>
<p>一旦我们启动了对某项技能的自学之后，在那过程中，最具价值的刻意思考就是，时时刻刻琢磨 “这东西能用在哪儿呢？”</p>
<p>比如，当你看到字符串的 Methods 中有一个 <code>str.zfill()</code> 的时候，马上就能想到，“嗯！这可以用来批量更名文件……”</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/rename-macos.png?raw=true" alt></p>
<p>虽然现在的 Mac OS 操作系统里已经有相当不错的批量更名工具内建在 Finder 之中（选中多个文件之后，在右键菜单中能看到 <code>rename</code> 命令），但这是近期才加进去的功能，几年前却没有 —— 也就是说，几年前的时候，有人可以用 <code>str.zfill()</code> 写个简单的程序完成自己的工作，而另外一些人仅因为操作系统没有提供类似的功能就要么手工做，要么干脆忍着忘了算了……</p>
<p>但更多的时候，需要你花时间去琢磨，才能找到用处。</p>
<p>找到用处，有时候还真挺难的 —— 因为人都一样，容易被自己的眼界所限，放眼望过去，没有用处，自然也就不用了，甚至不用学了，更不用提那就肯定是感觉不用练了……</p>
<p>所以，仔细想想罢 —— 那些在学校里帮老师干活的小朋友们，更多情况下还真不是很多人以为的 “拍马屁”（不排除肯定有哈），只不过是在 “主动找活干”……</p>
<p><strong>找活干</strong>，是应用所学的最有效方式，有活干，所以就有问题需要解决，所以就有机会反复攻关，在这个过程中，<strong>以用带练</strong>……</p>
<p>所以，很多人在很多事上都想反了。</p>
<p>人们常常取笑那些呼哧呼哧干活的人，笑着说，“能者多劳”，觉得他们有点傻。</p>
<p>这话真的没错。但这么说更准：<strong>劳者多能</strong> —— 你看，都想反了吧？</p>
<p>到最后，一切自学能力差的人，外部的表现都差不多，都起码包括这么一条：眼里没活。他们也不喜欢干活，甚至也没想过，玩乐也是干活（每次逢年过节玩得累死那种）—— 从消耗或者成本的角度来看根本没啥区别 —— 只不过那些通常都是没有产出的活而已。</p>
<p>在最初想不出有什么用处的时候，还可以退而求其次，看看 “别人想出什么用处没有？” —— 比如，我去 Google <code>best applications of python skill</code>，在第一个页面我就发现了这么篇文章：“<a href="https://medium.freecodecamp.org/what-can-you-do-with-python-the-3-main-applications-518db9a68a78" target="_blank" rel="noopener">What exactly can you do with Python? </a>”，翻了一会儿觉得颇有意思……</p>
<p>再高阶一点的刻意思考（琢磨），无非是在 “这东西能用在哪儿呢？” 这句话里加上一个字而已：</p>
<blockquote>
<p>这东西<strong>还</strong>能用在哪儿呢？</p>
</blockquote>
<p>我觉得这个问题对思维训练的帮助非常深刻 —— 别看只是多了一个字而已。</p>
<p>当我读到在编程的过程中有很多的 “约定” 的时候，就琢磨着：</p>
<blockquote>
<ul>
<li>哦，原来约定如此重要……</li>
<li>哦，原来竟然有那么多人不重视约定……</li>
<li>哦，原来就应该直接过滤掉那些不遵守约定的人……<br>—— 那这个原理（东西）还能用在哪儿呢？<br>—— 哦，在生活中也一样，遇到不遵守约定的人或事，直接过滤，不要浪费自己的生命……</li>
</ul>
</blockquote>
<p>学编程真的很有意思，因为这个领域是世界上最聪明的人群之一开辟出来并不断共同努力着发展的，所以，在这个世界里有很多思考方式，琢磨方式，甚至可以干脆称为 “做事哲学” 的东西，可以普遍应用在其它领域，甚至其它任何领域。</p>
<p>比如，在开发方法论中，有一个叫做 <a href="https://en.wikipedia.org/wiki/MoSCoW_method" target="_blank" rel="noopener">MoSCoW Method</a> 的东西，1994 年由 Clegg Dai 在《Case Method Fast-Track: A RAD Approach》一书中提出的 —— 两个 <code>o</code> 字母放在那里，是为了能够把这个缩写读出来，发音跟莫斯科一样。</p>
<p>简单说，就是，凡事都可以分为：</p>
<blockquote>
<ul>
<li>Must have</li>
<li>Should have</li>
<li>Could have</li>
<li>Won’t have</li>
</ul>
</blockquote>
<p>于是，在开发的时候，把所谓的需求打上这 4 个标签中的某一个，以此分类，就很容易剔除掉那些实际上做了还不如不做的功能……</p>
<p>琢磨一下罢，这个东西还可以用在什么地方？</p>
<p>显然，除了编程之外，其他应用领域挺多的，这个原则相当地有启发性……</p>
<p>我写书就是这样的。在准备的过程中 —— 这个过程比绝大多数人想象得长很多 —— 我会罗列所有我能想到的相关话题…… 等我觉得已经再也没有什么可补充的时候，再为这些话题写上几句话构成大纲…… 这时候就会发现很多话题其实应该是同一个话题。如此这般，一次扩张，一次收缩之后，就会进行下一步，应用 MoSCoW 原则，给这些话题打上标签 —— 在这过程中，总是发现很多之前感觉必要的话题，其实可以打上 <code>Won&#39;t have</code> 的标签，于是，把它们剔除，然后从 <code>Must have</code> 开始写起，直到 <code>Should have</code>，至于 <code>Could have</code> 看时间是否允许，看情况，比如，看有没有最后期限限制……</p>
<p>在写书这事上，我总是给人感觉很快，事实上也是，因为有方法论 —— 但显然，那方法论不是从某一本 “如何写书” 的书里获得的，而是从另外一个看起来完全不相关的领域里习得后琢磨到的……</p>
<p>所谓的 “活学活用”，所谓的 “触类旁通”，也不过如此。</p>
<h1 id="战胜难点"><a href="#战胜难点" class="headerlink" title="战胜难点"></a>战胜难点</h1><p>无论学什么，都有难点。所谓的 “学习曲线陡峭”，无非就是难点靠前、难点很多、难点貌似很难而已。</p>
<p>然而，相信我，所有的难点，事实上都可以被拆解成更小的单元，而后在逐一突破的时候，就没那么难了。逐一突破全部完成之后，再拼起来重新审视的时候就会发现那所谓的难常常只不过是错觉、幻觉而已 —— 我把它称为<strong>困难幻觉</strong>。</p>
<p>把一切都当作手艺看的好处之一就是心态平和，因为你知道那不靠天分和智商，它靠的是另外几件事：不混时间，刻意思考，以及刻意练习 —— 其实吧，老祖宗早就有总结：</p>
<blockquote>
<p>天下无难事，只怕<strong>有心人</strong>……</p>
</blockquote>
<p>大家都是人，咋可能没 “心” 呢？</p>
<p>想成为有心人，其实无非就是学会拆解之后逐一突破，就这么简单。</p>
<p>第三部分所用的例子依然非常简单 —— 这当然是作者的刻意；但是，所涉及的话题都是被认为 “很难很难”、“很不容易理解”、“初学者就没必要学那些了” 之类的话题：</p>
<blockquote>
<ul>
<li>类，以及面向对象编程（Class，OOP）</li>
<li>迭代器、生成器、装饰器（Iterators、Generators、Decorators）</li>
<li>正则表达式（Regular Expressions）</li>
<li>巴科斯-诺尔范式（Backus Normal Form）</li>
</ul>
</blockquote>
<p>尤其是最后一个，巴科斯-诺尔范式，几乎所有的编程入门书籍都不会提到……</p>
<p>然而，这些内容，在我设计《自学是门手艺》内容的过程中，是被当作 <code>Must have</code>，而不是 <code>Should have</code>，当然更不是 <code>Could have</code> 或者 <code>Won&#39;t have</code> 的。</p>
<p>它们属于 <code>Must have</code> 的原因也很简单：</p>
<blockquote>
<p>无论学什么都一样，难的部分不学会，就等于整个没学。</p>
</blockquote>
<p>—— 仅因为不够全面。</p>
<p>有什么必要干前功尽弃的事情呢？要么干脆别学算了，何必把自己搞成一个半吊子？—— 可惜，这偏偏是绝大多数人的习惯，学什么都一样，容易的部分糊弄糊弄，困难的部分直接回避…… 其实，所有焦虑，都是这样在许多年前被埋下，在许多年后生根发芽、茂盛发达的 —— 你想想看是不是如此？</p>
<p>虽然别人认为难，你刚开始也会有这样的错觉，但只要你开始施展 “读不懂也要读完，读完之后再读很多遍” 的手段，并且还 “不断自己动手归纳总结整理”，你就会 “发现”，其实没什么大不了的，甚至你会有错觉：</p>
<blockquote>
<p>“突然” 之间一切都明了了！</p>
</blockquote>
<p>那个 “突然”，其实就是阿基米德的 <a href="https://en.wikipedia.org/wiki/Eureka_effect" target="_blank" rel="noopener">Eureka</a>，那个他从澡堂里冲出来大喊大叫的词汇。</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/archimedes-eureka.png?raw=true" alt></p>
<p>其实吧，泡澡和冥想，还真是最容易产生 Eureka 状态的两种活动。原理在于，泡澡和打坐的时候，大脑都极其放松，乃至于原本相互之间并无联系的脑神经突触之间突然产生相互关联；而那结果就是日常生活中所描述的 “融会贯通”，于是，突然之间，Eureka！</p>
<p>自学者总是感觉幸福度很高，就是这个原因。日常中因为自学，所以总是遇到更多的困难。又因为这些东西不过是手艺，没什么可能终其一生也解决不了，恰恰相反，都是假以时日必然解决的 “困难”…… 于是，自学者恰恰因为遇到的 “困难” 多，所以才有更多遇到 “Eureka” 的可能性，那种幸福，还真的难以表述，即便表述清楚了，身边的人也难以理解，因为自学者就是很少很少。</p>
<p>对很多人来说，阅读的难点在于起初的时候它总是显得异常枯燥。</p>
<p>刚识字、刚上学的时候，由于理解能力有限，又由于年龄的关系于是耐心有限，所以，那时需要老师耐心陪伴、悉心引导。这就好像小朋友刚出生的时候，没有牙齿，所以只能喝奶差不多…… 然而，到了一定程度之后一定要断奶，是不是？可绝大多数人的实际情况却是，小学的时候爱上了 “奶嘴”（有人带着阅读），而后一生没有奶嘴就吃不下任何东西。</p>
<p>他们必须去 “上课”，需要有人给他们讲书。不仅如此，讲得 “不生动”、“不幽默” 还不行；就算那职业提供奶嘴的人（这是非常令人遗憾的真相：很多的时候，所谓的 “老师” 本质上只不过就是奶妈而已）帅气漂亮、生动幽默、尽职尽力…… 最终还是一样的结果 —— 绝大多数人依然没有完整掌握所有应该掌握的细节。</p>
<p>开始 “自学” 的活动，本质上来看，和<strong>断奶</strong>其实是一回事。</p>
<blockquote>
<ul>
<li>知识就是知识，它没有任何义务去具备幽默生动的属性；</li>
<li>手艺就是手艺，它没有任何义务去具备有趣欢乐的属性。</li>
</ul>
</blockquote>
<p>幽默与生动，是要自己去扮演的角色；有趣与欢乐，是要自己去挖掘的幸福 —— 它们从来都并不自动包含在知识和手艺之中。只有当它们被 “有心人” 掌握、被 “有心人” 应用、甚至被 “有心人” 拿去创造的时候，也只有 “有心人” 才能体会到那幽默与生动、那有趣与欢乐。</p>
<p>所以，有自学能力的人，不怕枯燥 —— 因为那本来就理应是枯燥的。这就好像人生本无意义，有意义的人生都是自己活出来的一样，有意义的知识都是自己用出来的 —— 对不用它的人，用不上它的人来说，只能也只剩下无法容忍的枯燥。</p>
<p>能够<strong>耐心</strong>读完那么多在别人看来 “极度枯燥” 的资料，是自学者的擅长。可那在别人看来 “无以伦比” 的耐心，究竟是哪儿来的呢？如何造就的呢？没断奶的人想象不出来。其实也很简单，首先，平静地接受了它枯燥的本质；其次，就是经过多次实践已然明白，无论多枯燥，总能读完；无论多难，多读几遍总能读懂…… 于是，到最后，<strong>只不过是习惯了而已。</strong></p>
<p>第三部分关于编程的内容过后，还有若干关于自学的内容。</p>
<p>在反复阅读编程部分突破难点的过程之中、过程之后，你会对那些关于自学的内容有更深更生动的认识。很多道理过去你都知道是对的，只不过因为没有遇到过生动的例子 —— 主要是没遇到过能让自己感到生动的例子 —— 于是你就一直没有重视起来，于是，就还是那句话，那一点点的差异，造成了后来那么大的差距。</p>
<p>然而，既然知道了真相的你，以后就再也没办法蒙蔽自己了 —— 这就是收获，这就是进步。</p>
<h1 id="类-——-面向对象编程"><a href="#类-——-面向对象编程" class="headerlink" title="类 —— 面向对象编程"></a>类 —— 面向对象编程</h1><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>注意：当前这一小节所论述的内容，不是专属于哪个编程语言（比如 Python、JavaScript 或者 Golang）。</p>
<p>面向对象编程（<a href="https://en.wikipedia.org/wiki/Object-oriented_programming" target="_blank" rel="noopener">Object Oriented Programming, OOP</a>）是一种编程的范式（Paradigm），或者说，是一种方法论（Methodology）—— 可以说这是个很伟大的方法论，在我看来，现代软件工程能做那么复杂的宏伟项目，基本上都得益于这个方法论的普及。</p>
<h2 id="争议"><a href="#争议" class="headerlink" title="争议"></a>争议</h2><p>现在，OOP 的支持者与反对者在数量上肯定不是一个等级，绝大多数人支持 OOP 这种编程范式。</p>
<p>但是，从另外一个角度，反对 OOP 的人群中，牛人比例更高 —— 这也是个看起来颇为吊诡的事实。</p>
<p>比如，Erlang 的发明者，<a href="https://en.wikipedia.org/wiki/Joe_Armstrong_(programmer" target="_blank" rel="noopener">Joe Armstrong</a>) 就很讨厌 OOP，觉得它效率低下。他用的类比也确实令人忍俊不禁，说得也挺准的：</p>
<blockquote>
<p>支持 OOP 的语言的问题在于，它们总是随身携带着一堆并不明确的环境 —— 你明明只不过想要个香蕉，可你所获得的是一个大猩猩手里拿着香蕉…… 以及那大猩猩身后的整个丛林！<br> —— <a href="http://www.codersatwork.com" target="_blank" rel="noopener">Coders at Work</a></p>
</blockquote>
<p>创作 UTF-8 和 Golang 的程序员 <a href="https://en.wikipedia.org/wiki/Rob_Pike" target="_blank" rel="noopener">Rob Pike</a>，更看不上 OOP，在 2004 年的一个讨论帖里直接把 OOP 比作 “<a href="https://groups.google.com/forum/#!topic/comp.os.plan9/VUUznNK2t4Q%5B151-175%5D" target="_blank" rel="noopener">Roman numerals of computing</a>” —— 讽刺它就是很土很低效的东西。八年后又<a href="https://plus.google.com/+RobPikeTheHuman/posts/hoJdanihKwb" target="_blank" rel="noopener">挖坟把一个 Java 教授写的 OOP 文章嘲弄了一番</a>：“也不知道是什么脑子，认为写 6 个新的 Class 比直接用 1 行表格搜索更好？”</p>
<p><a href="https://en.wikipedia.org/wiki/Paul_Graham_(programmer" target="_blank" rel="noopener">Paul Graham</a> —— 就是那个著名的 Y-Combinator 的创始人 —— 也一样对 OOP 不以为然，在 <a href="http://www.paulgraham.com/noop.html" target="_blank" rel="noopener">Why Arc isn’t Especially Object-Oriented</a> 中，说他认为 OOP 之所以流行，就是因为平庸程序员（Mediocre programers）太多，大公司用这种编程范式去阻止那帮家伙，让他们捅不出太大的娄子……</p>
<p>然而，争议归争议，应用归应用 —— 就好像英语的弊端不见得比其他语言少，可就是最流行，那怎么办呢？用呗 —— 虽然该抱怨的时候也得抱怨抱怨。</p>
<p>从另外一个角度望过去，大牛们如此评价 OOP 也是很容易理解的 —— 因为他们太聪明，又因为他们太懒得花时间去理解或容忍笨蛋…… 我们不一样，最不一样的地方在于，我们不仅更多容忍他人，而且更能够容忍自己的愚笨，所以，视角就不同了，仅此而已。</p>
<p>并且，上面两位大牛写的编程语言，现在也挺流行，Joe Armstrong 的 Erlang 和 Rob Pike 的 Golang，弄不好早晚你也得去学学，去用用……</p>
<h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><p>面向对象编程（OOP），是使用<strong>对象</strong>（Objects）作为核心的编程方式。进而就可以把对象（Objects）的数据和运算过程<strong>封装</strong>（Encapsulate）在内部，而外部仅能根据事先设计好的<strong>界面</strong>（Interface）与之沟通。</p>
<p>比如，你可以把灯泡想象成一个对象，使用<em>灯泡</em>的人，只需要与<em>开关</em>这个界面（Interface）打交道，而不必关心灯泡内部的设计和原理 —— 说实话，这是个很伟大的设计思想。</p>
<p>生活中，我们会遇到无数有意无意应用了这种设计思想的产品 —— 并不仅限于编程领域。你去买个车回来，它也一样是各种封装之后的对象。当你转动方向盘（操作界面）的时候，你并不需要关心汽车设计者是如何做到把那个方向盘和车轮车轴联系在一起并如你所愿去转向的；你只需要知道的是，逆时针转动方向盘是左转，而顺时针转动方向盘是右转 —— 这就可以了！</p>
<p>在程序设计过程中，我们常常需要对标现实世界创造对象。这时候我们用的最直接手段就是<strong>抽象</strong>（Abstract）。抽象这个手段，在现实中漫画家们最常用。为什么你看到下面的图片觉得它们俩看起来像是人？尤其是在你明明知道那肯定不是人的情况下，却已然接受那是两个漫画小人的形象？</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/a-cartoon.png?raw=true" alt></p>
<p>这种描绘方式，就是抽象，很多 “没必要” 的细节都被去掉了（或者反过来说，没有被采用），留下的两个特征，一个是头，一个是双眼 —— 连那双 “眼睛” 都抽象到只剩下一个黑点了……</p>
<p>这种被保留下来的 “必要的特征”，叫做对象的<strong>属性</strong>（Attributes），进而，这些抽象的对象，既然是 “人” 的映射，它们实际上也能做一些抽象过后被保留下来的 “必要的行为”，比如，说话，哭笑，这些叫做对象的<strong>方法</strong>（Methods）。</p>
<p>从用编程语言创造对象的角度去看，所谓的界面，就由这两样东西构成：</p>
<blockquote>
<ul>
<li><em>属性</em> —— 用自然语言描述，通常是名词（Nouns）</li>
<li><em>方法</em> —— 用自然语言描述，通常是动词（Verbs）</li>
</ul>
</blockquote>
<p>从另外一个方面来看，在设计复杂对象的时候，抽象到极致是一种必要。</p>
<p>我们为生物分类，就是一层又一层地抽象的过程。当我们使用 “生物” 这个词的时候，它并不是某一个特定的我们能够指称的东西…… 然后我们开始给它分类……</p>
<p><a href="https://crucialconsiderations.org/wp-content/uploads/2016/08/Tree-of-Life.jpg" target="_blank" rel="noopener"><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/Tree-of-Life.gif?raw=true" alt></a></p>
<p>所以，当我们在程序里创建对象的时候，做法常常是</p>
<blockquote>
<ul>
<li>先创建最抽象的<strong>类</strong>（Class）</li>
<li>然后再创建<strong>子类</strong>（Subclass）……</li>
</ul>
</blockquote>
<p>它们之间是从属关系是：</p>
<blockquote>
<p>Class ⊃ Subclass</p>
</blockquote>
<p>在 OOP 中，这叫<strong>继承</strong>（Inheritance）关系。比如，狗这个<em>对象</em>，就可以是从哺乳动物这个对象<em>继承</em>过来的。如果哺乳动物有 “头” 这个<em>属性</em>（Attributes），那么在狗这个对象中就没必要再重新定义这个属性了，因为既然狗是从哺乳动物继承过来的，那么它就拥有哺乳动物的所有属性……</p>
<p>每当我们创建好一个类之后，我们就可以根据它创建它的许多个<strong>实例</strong>（Instances）。比如，创建好了 “狗” 这个类之后，我们就可以根据这个类创建很多条狗…… 这好多条狗，就是狗这个类的<em>实例</em>。</p>
<p>现在能把这些术语全部关联起来了吗？</p>
<blockquote>
<ul>
<li>对象，封装，抽象</li>
<li>界面，属性，方法</li>
<li>继承，类，子类，实例</li>
</ul>
</blockquote>
<p>这些就是关于 “面向对象编程” 方法论的最基本的术语 —— 无论在哪种编程语言里，你都会频繁地遇到它们。</p>
<p><strong>对象</strong>、<strong>类</strong>，这两个词，给人的感觉是经常被通用 —— 习惯了还好，但对有些初学者来说，就感觉那是生命不能承受之重。—— 这次不是英文翻译中文时出现的问题，在英文世界里，这些词的互通使用和滥用也使相当一部分人（我怀疑是大部分人）最终掌握不了 OOP 这个方法论。</p>
<p>细微的差异在于 “视角” 的不同。</p>
<p>之前提到函数的时候，我用的说辞是，</p>
<blockquote>
<ul>
<li>你写了一个函数，而后你要为这个产品的使用者写说明书……</li>
<li>—— 当然，产品使用者之中也包括未来的你……</li>
</ul>
</blockquote>
<p>类（Class）这个东西也一样，它也有创作者和使用者。</p>
<p>你可以这样分步理解：</p>
<blockquote>
<ul>
<li>你创造了一个类（Class），这时候你是创作者，从你眼里望过去，那就是个类（Class）；</li>
<li>而后你根据这个类的定义，创建了很多实例（Instances）；</li>
<li>接下来一旦你开始使用这些实例的时候，你就成了使用者，从使用者角度望过去，手里正在操作的，就是各种对象（Objects）……</li>
</ul>
</blockquote>
<p>最后，补充一下，不要误以为所有的 Classes 都是对事物（即，名词）的映射 —— 虽然大多数情况下确实如此。</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/code-review.png?raw=true" alt></p>
<p>对基本概念有了一定的了解之后，再去看 Python 语言是如何实现的，就感觉没那么难了。</p>
<h1 id="类-——-Python-的实现"><a href="#类-——-Python-的实现" class="headerlink" title="类 —— Python 的实现"></a>类 —— Python 的实现</h1><p>既然已经在不碰代码的情况下，把 OOP 中的主要概念梳理清楚了，以下的行文中，那些概念就直接用英文罢，省得理解上还得再绕个弯……</p>
<h2 id="Defining-Class"><a href="#Defining-Class" class="headerlink" title="Defining Class"></a>Defining Class</h2><p>Class 使用 <code>class</code> 关键字进行定义。</p>
<p>与函数定义不同的地方在于，Class 接收参数不是在 <code>class Classname():</code> 的括号里完成 —— 那个圆括号有另外的用处。</p>
<p>让我们先看看代码，而后再逐一解释：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Golem</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name=None)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.built_year = datetime.date.today().year</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say_hi</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Hi!'</span>)</span><br><span class="line"></span><br><span class="line">g = Golem(<span class="string">'Clay'</span>)</span><br><span class="line">g.name</span><br><span class="line">g.built_year</span><br><span class="line">g.say_hi</span><br><span class="line">g.say_hi()</span><br><span class="line">type(g)</span><br><span class="line">type(g.name)</span><br><span class="line">type(g.built_year)</span><br><span class="line">type(g.__init__)</span><br><span class="line">type(g.say_hi)</span><br></pre></td></tr></table></figure>
<pre><code>&apos;Clay&apos;
2019
&lt;bound method Golem.say_hi of &lt;__main__.Golem object at 0x10430e7b8&gt;&gt;
Hi!
__main__.Golem
str
int
method
method
</code></pre><p>以上，我们创建了一个 Class:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Golem</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name=None)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.built_year = datetime.date.today().year</span><br></pre></td></tr></table></figure>
<p>其中定义了当我们根据这个 Class 创建一个实例的时候，那个 Object 的初始化过程，即 <code>__init__()</code> 函数 —— 又由于这个函数是在 Class 中定义的，我们称它为 Class 的一个 Method。</p>
<p>这里的 <code>self</code> 就是个变量，跟程序中其它变量的区别在于，它是一个系统默认可以识别的变量，用来指代将来用这个 Class 创建的 Instance。</p>
<p>比如，我们创建了 Golem 这个 Class 的一个 Instance，<code>g = Golem(&#39;Clay&#39;)</code> 之后，我们写 <code>g.name</code>，那么解析器就去找 <code>g</code> 这个实例所在的 Scope 里有没有 <code>self.name</code>……</p>
<p>注意：<code>self</code> 这个变量的定义，是在 <code>def __init__(self, ...)</code> 这一句里完成的。对于这个变量的名称取名没有强制要求，你实际上可以随便用什么名字，很多 C 程序员会习惯于将这个变量命名为 <code>this</code> —— 但根据惯例，你最好还是只用 <code>self</code> 这个变量名，省得给别人造成误会。</p>
<p>在 Class 的代码中，如果定义了 <code>__init__()</code> 函数，那么系统就会将它当作 Instance 在创建后被初始化的函数。这个函数名称是强制指定的，初始化函数必须使用这个名称；注意 <code>init</code> 两端各有两个下划线 <code>_</code>。</p>
<p>当我们用 <code>g = Golem(&#39;Clay&#39;)</code> 这一句创建了一个 Golem 的 Instance 的时候，以下一连串的事情发生了：</p>
<blockquote>
<ul>
<li><code>g</code> 从此之后就是一个根据 Golem 这个 Class 创建的 Instance，对使用者来说，它就是个 Object；</li>
<li>因为 Golem 这个 Class 的代码中有 <code>__init__()</code>，所以，当 <code>g</code> 被创建的时候，<code>g</code> 就需要被初始化……</li>
<li>在 <code>g</code> 所在的变量目录中，出现了一个叫做 <code>self</code> 的用来指代 <code>g</code> 本身的变量；</li>
<li>self.name 接收了一个参数，<code>&#39;Clay&#39;</code>，并将其保存了下来；</li>
<li>生成了一个叫做 <code>self.built_year</code> 的变量，其中保存的是 <code>g</code> 这个 Object 被创建时的年份……</li>
</ul>
</blockquote>
<p>对了，Golem 和 Robot 一样，都是机器人的意思；Golem 的本义来自于犹太神话，一个被赋予了生命的泥人……</p>
<h2 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h2><p>我们刚刚创建了一个 Golem Class，如果我们想用它 Inherite 一个新的 Class，比如，<code>Running_Golem</code>，一个能跑的机器人，那就像以下的代码那样做 —— 注意 <code>class Running_Golem</code> 之后的圆括号：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Golem</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name=None)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.built_year = datetime.date.today().year</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say_hi</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Hi!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Running_Golem</span><span class="params">(Golem)</span>:</span>      <span class="comment"># 刚刚就说，这个圆括号另有用途……</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Can't you see? I'm running..."</span>)</span><br><span class="line"></span><br><span class="line">rg = Running_Golem(<span class="string">'Clay'</span>)</span><br><span class="line"></span><br><span class="line">rg.run</span><br><span class="line">rg.run()</span><br><span class="line">rg.name</span><br><span class="line">rg.built_year</span><br><span class="line">rg.say_hi()</span><br></pre></td></tr></table></figure>
<pre><code>&lt;bound method Running_Golem.run of &lt;__main__.Running_Golem object at 0x1068b37b8&gt;&gt;
Can&apos;t you see? I&apos;m running...
&apos;Clay&apos;
2019
Hi!
</code></pre><p>如此这般，我们根据 Golem 这个 Class 创造了一个 Subclass —— <code>Running_Golem</code>，既然它是 Golem 的 Inheritance，那么 Golem 有的 Attributes 和 Methods 它都有，并且还多了一个 Method —— <code>self.run</code>。</p>
<h2 id="Overrides"><a href="#Overrides" class="headerlink" title="Overrides"></a>Overrides</h2><p>当我们创建一个 Inherited Class 的时候，可以重写（Overriding）Parent Class 中的 Methods。比如这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Golem</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name=None)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.built_year = datetime.date.today().year</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say_hi</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Hi!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">runningGolem</span><span class="params">(Golem)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Can't you see? I'm running..."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say_hi</span><span class="params">(self)</span>:</span>                            <span class="comment"># 不再使用 Parent Class 中的定义，而是新的……</span></span><br><span class="line">        print(<span class="string">'Hey! Nice day, Huh?'</span>)</span><br><span class="line"></span><br><span class="line">rg = runningGolem(<span class="string">'Clay'</span>)</span><br><span class="line">rg.run</span><br><span class="line">rg.run()</span><br><span class="line">rg.name</span><br><span class="line">rg.built_year</span><br><span class="line">rg.say_hi()</span><br></pre></td></tr></table></figure>
<pre><code>&lt;bound method runningGolem.run of &lt;__main__.runningGolem object at 0x1068c8128&gt;&gt;
Can&apos;t you see? I&apos;m running...
&apos;Clay&apos;
2019
Hey! Nice day, Huh?
</code></pre><h2 id="Inspecting-A-Class"><a href="#Inspecting-A-Class" class="headerlink" title="Inspecting A Class"></a>Inspecting A Class</h2><p>当我们作为用户想了解一个 Class 的 Interface，即，它的 Attributes 和 Methods 的时候，常用的有三种方式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> help(object)</span><br><span class="line"><span class="number">2.</span> dir(object)</span><br><span class="line"><span class="number">3.</span> object.__dict__</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Golem</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name=None)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.built_year = datetime.date.today().year</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say_hi</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Hi!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">runningGolem</span><span class="params">(Golem)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Can\'t you see? I\'m running...'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say_hi</span><span class="params">(self)</span>:</span>                            <span class="comment"># 不再使用 Parent Class 中的定义，而是新的……</span></span><br><span class="line">        print(<span class="string">'Hey! Nice day, Huh?'</span>)</span><br><span class="line"></span><br><span class="line">rg = runningGolem(<span class="string">'Clay'</span>)</span><br><span class="line">help(rg)</span><br><span class="line">dir(rg)</span><br><span class="line">rg.__dict__</span><br><span class="line">hasattr(rg, <span class="string">'built_year'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Help on runningGolem in module __main__ object:

class runningGolem(Golem)
 |  runningGolem(name=None)
 |
 |  Method resolution order:
 |      runningGolem
 |      Golem
 |      builtins.object
 |
 |  Methods defined here:
 |
 |  run(self)
 |
 |  say_hi(self)
 |
 |  ----------------------------------------------------------------------
 |  Methods inherited from Golem:
 |
 |  __init__(self, name=None)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |
 |  ----------------------------------------------------------------------
 |  Data descriptors inherited from Golem:
 |
 |  __dict__
 |      dictionary for instance variables (if defined)
 |
 |  __weakref__
 |      list of weak references to the object (if defined)

[&apos;__class__&apos;,
 &apos;__delattr__&apos;,
 &apos;__dict__&apos;,
 &apos;__dir__&apos;,
 &apos;__doc__&apos;,
 &apos;__eq__&apos;,
 &apos;__format__&apos;,
 &apos;__ge__&apos;,
 &apos;__getattribute__&apos;,
 &apos;__gt__&apos;,
 &apos;__hash__&apos;,
 &apos;__init__&apos;,
 &apos;__init_subclass__&apos;,
 &apos;__le__&apos;,
 &apos;__lt__&apos;,
 &apos;__module__&apos;,
 &apos;__ne__&apos;,
 &apos;__new__&apos;,
 &apos;__reduce__&apos;,
 &apos;__reduce_ex__&apos;,
 &apos;__repr__&apos;,
 &apos;__setattr__&apos;,
 &apos;__sizeof__&apos;,
 &apos;__str__&apos;,
 &apos;__subclasshook__&apos;,
 &apos;__weakref__&apos;,
 &apos;built_year&apos;,
 &apos;name&apos;,
 &apos;run&apos;,
 &apos;say_hi&apos;]
{&apos;name&apos;: &apos;Clay&apos;, &apos;built_year&apos;: 2019}
True
</code></pre><h2 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h2><p>每个变量都属于某一个 <strong>Scope</strong>（变量的作用域），在同一个 Scope 中，变量可以被引用被操作…… 这么说非常抽象，难以理解 —— 只能通过例子说明。</p>
<p>我们先给 Golem 这个 Class 增加一点功能 —— 我们需要随时知道究竟有多少个 Golem 处于活跃状态…… 也因此顺带给 Golem 加上一个 Method：<code>cease()</code> —— 哈！机器人么，想关掉它，说关掉它，就能关掉它；</p>
<p>另外，我们还要给机器人设置个使用年限，比如 10 年；</p>
<p>…… 而外部会每隔一段时间，用 <code>Golem.is_active()</code> 去检查所有的机器人，所以，不需要外部额外操作，到了年头，它应该能关掉自己。—— 当然，又由于以下代码是简化书写的，核心目的是为了讲解 Scope，所以并没有专门写模拟 10 年后某些机器人自动关闭的情形……</p>
<p>在运行以下代码之前，需要先介绍三个 Python 的内建函数：</p>
<blockquote>
<ul>
<li><code>hasattr(object, attr)</code> 查询这个 <code>object</code> 中有没有这个 <code>attr</code>，返回布尔值</li>
<li><code>getattr(object, attr)</code> 获取这个 <code>object</code> 中这个 <code>attr</code> 的值</li>
<li><code>setattr(object, attr, value)</code> 将这个 <code>object</code> 中的 <code>attr</code> 值设置为 <code>value</code></li>
</ul>
</blockquote>
<p>现在的你，应该一眼望过去，就已经能掌握这三个内建函数的用法 —— 还记得之前的你吗？眼睁睁看着，那些字母放在那里对你来说没任何意义…… 这才多久啊！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Golem</span>:</span></span><br><span class="line">    population = <span class="number">0</span></span><br><span class="line">    __life_span = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name=None)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.built_year = datetime.date.today().year</span><br><span class="line">        self.__active = <span class="literal">True</span></span><br><span class="line">        Golem.population += <span class="number">1</span>          <span class="comment"># 执行一遍之后，试试把这句改成 population += 1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say_hi</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Hi!'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cease</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__active = <span class="literal">False</span></span><br><span class="line">        Golem.population -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_active</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> datetime.date.today().year - self.built_year &gt;= Golem.__life_span:</span><br><span class="line">            self.cease()</span><br><span class="line">        <span class="keyword">return</span> self.__active</span><br><span class="line"></span><br><span class="line">g = Golem()</span><br><span class="line">hasattr(Golem, <span class="string">'population'</span>)      <span class="comment"># True</span></span><br><span class="line">hasattr(g, <span class="string">'population'</span>)          <span class="comment"># True</span></span><br><span class="line">hasattr(Golem, <span class="string">'__life_span'</span>)     <span class="comment"># False</span></span><br><span class="line">hasattr(g, <span class="string">'__life_span'</span>)         <span class="comment"># False</span></span><br><span class="line">hasattr(g, <span class="string">'__active'</span>)            <span class="comment"># False</span></span><br><span class="line">Golem.population                  <span class="comment"># 1</span></span><br><span class="line">setattr(Golem, <span class="string">'population'</span>, <span class="number">10</span>)</span><br><span class="line">Golem.population                  <span class="comment"># 10</span></span><br><span class="line">x = Golem()</span><br><span class="line">Golem.population                  <span class="comment"># 11</span></span><br><span class="line">x.cease()</span><br><span class="line">Golem.population                  <span class="comment"># 10</span></span><br><span class="line">getattr(g, <span class="string">'population'</span>)          <span class="comment"># 10</span></span><br><span class="line">g.is_active()</span><br></pre></td></tr></table></figure>
<pre><code>True
True
False
False
False
1
10
11
10
10
True
</code></pre><p>如果你试过把第 13 行的 <code>Golem.population += 1</code> 改成 <code>population += 1</code>，你会被如下信息提醒：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">12</span>         self.__active = <span class="literal">True</span></span><br><span class="line">---&gt; 13         population += 1</span><br><span class="line">UnboundLocalError: local variable <span class="string">'population'</span> referenced before assignment</span><br></pre></td></tr></table></figure>
<p>—— 本地变量 <code>population</code> 尚未赋值，就已经提前被引用…… 为什么会这样呢？因为在你所创建 <code>g</code> 之后，马上执行的是 <code>__init()__</code> 这个初始化函数，而 <code>population</code> 是在这个函数之外定义的……</p>
<p>如果你足够细心，你会发现这个版本中，有些变量前面有两个下划线 <code>__</code>，比如，<code>__life_span</code> 和 <code>self.__active</code>。这是 Python 的定义，变量名前面加上一个以上下划线（Underscore）<code>_</code> 的话，那么该变量是 “私有变量”（Private Variables），不能被外部引用。而按照 Python 的惯例，我们会使用两个下划线起始，去命名私有变量，如：<code>__life_span</code>。你可以回去试试，把所有的 <code>__life_span</code> 改成 <code>_life_span</code>（即，变量名开头只有一个 <code>_</code>，那么，<code>hasattr(Golem, &#39;_life_span&#39;)</code> 和 <code>hasattr(g, &#39;_life_span&#39;)</code> 的返回值就都变成了 <code>True</code>。</p>
<p>看看下面的图示，理解起来更为直观一些，其中每个方框代表一个 Scope：</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/class-variables-scope.png?raw=true" alt></p>
<p>整个代码启动之后，总计有 4 个 Scopes 如图所示：</p>
<blockquote>
<ul>
<li>① <code>class Golem</code> 之外；</li>
<li>② <code>class Golem</code> 之内；</li>
<li>③ <code>__init__(self, name=None)</code> 之内；</li>
<li>④ <code>cease(self)</code> 之内；</li>
</ul>
</blockquote>
<p>在 Scope ① 中，可以引用 <code>Golem.population</code>，在生成一个 Golem 的实例 <code>g</code> 之后，也可以引用 <code>g.population</code>；但 <code>Golem.__life_span</code> 和 <code>g.__active</code> 在 Scope ① 是不存在的；</p>
<p>在 Scope ② 中，存在两个变量，<code>population</code> 和 <code>__life_span</code>；而 <code>__life_span</code> 是 Private（私有变量，因为它的变量名中前两个字符是下划线 <code>__</code>；于是，在 Scope ① 中，不存在 <code>Golem.__life_span</code> —— <code>hasattr(Golem, &#39;__life_span&#39;)</code> 的值为 <code>False</code>；</p>
<p>在 Scope ③ 中和 Scope ④ 中，由于都给它们传递了 <code>self</code> 这个参数，于是，在这两个 Scope 里，都可以引用 <code>self.xxx</code>，比如 <code>self.population</code>，比如 <code>self.__life_span</code>；</p>
<p>在 Scope ③ 中，<code>population</code> 是不存在的，如果需要引用这个值，可以用 <code>Golem.population</code>，也可以用 <code>self.population</code>。同样的道理，在 Scope ③ 中 <code>__life_span</code> 也不存在，如果想用这个值，可以用 <code>Golem.__life_span</code> 或者 <code>self.__life_span</code>；</p>
<p>Scope ④ 与 Scope ③ 平行存在。所以在这里，<code>population</code> 和 <code>__life_span</code> 也同样并不存在。</p>
<p><strong>补充</strong></p>
<p>在本例子中，在 <code>__init__(self, name=None)</code> 函数中 <code>self.population</code> 和 <code>Golem.population</code> 都可以使用，但使用效果是不一样的：</p>
<blockquote>
<ul>
<li><code>self.population</code> 总是去读取 <code>Golem</code> 类中 <code>population</code> 的初始值，即使后面通过 <code>setattr(Golem, &#39;population&#39;, 10)</code> 更改 <code>population</code> 的值后，<code>self.population</code> 的值仍为 <code>0</code>，但 <code>Golem.population</code> 值则为 <code>10</code>，你可以自己动手尝试一下。</li>
</ul>
</blockquote>
<h2 id="Encapsulation"><a href="#Encapsulation" class="headerlink" title="Encapsulation"></a>Encapsulation</h2><p>到目前为止，Golem 这个 Class 看起来不错，但有个问题，它里面的数据，外面是可以随便改的 —— 虽然，我们已经通过给变量 life_span 前面加上两个下划线，变成 <code>__life_span</code>，使其成为私有变量，外部不能触达（你不能引用 <code>Golem.__life_span</code>），可 Golem.population 就不一样，外面随时可以引用，还可以随时修改它，只需要写上一句：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Golem.population = <span class="number">1000000</span></span><br></pre></td></tr></table></figure>
<p>我们干脆把 <code>population</code> 这个变量也改成私有的罢：<code>__population</code>，而后需要从外界查看这个变量的话，就在 Class 里面写个函数，返回那个值好了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Golem</span>:</span></span><br><span class="line">    __population = <span class="number">0</span></span><br><span class="line">    __life_span = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name=None)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.built_year = datetime.date.today().year</span><br><span class="line">        self.__active = <span class="literal">True</span></span><br><span class="line">        Golem.__population += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say_hi</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Hi!'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cease</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__active = <span class="literal">False</span></span><br><span class="line">        Golem.__population -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_active</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> datetime.date.today().year - self.built_year &gt;= Golem.__life_span:</span><br><span class="line">            self.cease</span><br><span class="line">        <span class="keyword">return</span> self.__active</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">population</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Golem.__population</span><br><span class="line"></span><br><span class="line">g = Golem(<span class="string">'Clay'</span>)</span><br><span class="line">g.population</span><br><span class="line">g.population()</span><br></pre></td></tr></table></figure>
<pre><code>&lt;bound method Golem.population of &lt;__main__.Golem object at 0x1068da160&gt;&gt;
1
</code></pre><p>如果，你希望外部能够像获得 Class 的属性那样，直接写 <code>g.population</code>，而不是必须加上一个括号 <code>g.population()</code> 传递参数（实际上传递了一个隐含的 <code>self</code> 参数），那么可以在 <code>def population(self):</code> 之前的一行加上一句 <code>@property</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Golem</span>:</span></span><br><span class="line">    __population = <span class="number">0</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">population</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Golem.__population</span><br></pre></td></tr></table></figure>
<p>如此这般之后，你就可以用 <code>g.population</code> 了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Golem</span>:</span></span><br><span class="line">    __population = <span class="number">0</span></span><br><span class="line">    __life_span = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name=None)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.built_year = datetime.date.today().year</span><br><span class="line">        self.__active = <span class="literal">True</span></span><br><span class="line">        Golem.__population += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say_hi</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Hi!'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cease</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__active = <span class="literal">False</span></span><br><span class="line">        Golem.__population -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_active</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> datetime.date.today().year - self.built_year &gt;= Golem.__life_span:</span><br><span class="line">            self.cease</span><br><span class="line">        <span class="keyword">return</span> self.__active</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">population</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Golem.__population</span><br><span class="line"></span><br><span class="line">g = Golem(<span class="string">'Clay'</span>)</span><br><span class="line">g.population</span><br><span class="line"><span class="comment"># g.population = 100</span></span><br></pre></td></tr></table></figure>
<pre><code>1
</code></pre><p>如此这般之后，不仅你可以直接引用 <code>g.population</code>，并且，在外部不能再直接给 <code>g.population</code> 赋值了，否则会报错：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---------------------------------------------------------------------------</span><br><span class="line">AttributeError                            Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="number">-16</span><span class="number">-5</span>d8c475304d3&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">     <span class="number">26</span> g = Golem(<span class="string">'Clay'</span>)</span><br><span class="line">     <span class="number">27</span> g.population</span><br><span class="line">---&gt; 28 g.population = 100</span><br><span class="line"></span><br><span class="line">AttributeError: can<span class="string">'t set attribute</span></span><br></pre></td></tr></table></figure>
<p>到此为止，Encapsulation 就做得不错了。</p>
<p>如果你非得希望从外部可以设置这个值，那么，你就得再写个函数，并且在函数之前加上一句：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">population</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Golem.__population</span><br><span class="line"></span><br><span class="line"><span class="meta">@population.setter</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">population</span><span class="params">(self, value)</span>:</span></span><br><span class="line">    Golem.__population = value</span><br></pre></td></tr></table></figure></p>
<p>这样之后，<code>.population</code> 这个 Attribute 就可以从外部被设定其值了（虽然在当前的例子中显得没必要让外部设定 <code>__population</code> 这个值…… 以下仅仅是为了举例）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Golem</span>:</span></span><br><span class="line">    __population = <span class="number">0</span></span><br><span class="line">    __life_span = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name=None)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.built_year = datetime.date.today().year</span><br><span class="line">        self.__active = <span class="literal">True</span></span><br><span class="line">        Golem.__population += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say_hi</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Hi!'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cease</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__active = <span class="literal">False</span></span><br><span class="line">        Golem.__population -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_active</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> datetime.date.today().year - self.built_year &gt;= Golem.__life_span:</span><br><span class="line">            self.cease</span><br><span class="line">        <span class="keyword">return</span> self.__active</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">population</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> Golem.__population</span><br><span class="line"></span><br><span class="line"><span class="meta">    @population.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">population</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        Golem.__population = value</span><br><span class="line"></span><br><span class="line">g = Golem(<span class="string">'Clay'</span>)</span><br><span class="line">g.population</span><br><span class="line">g.population = <span class="number">100</span></span><br><span class="line">ga = Golem(<span class="string">'New'</span>)</span><br><span class="line">g.population</span><br><span class="line">ga.population</span><br><span class="line">help(Golem)</span><br><span class="line">Golem.__dict__</span><br><span class="line">g.__dict__</span><br><span class="line">hasattr(Golem, <span class="string">'population'</span>)</span><br><span class="line">getattr(Golem, <span class="string">'population'</span>)</span><br><span class="line">setattr(Golem, <span class="string">'population'</span>, <span class="number">10000</span>)</span><br><span class="line">g.population    <span class="comment"># 所以，在很多的情况下，不把数据封装在 Class 内部的话，后面会有很多麻烦。</span></span><br></pre></td></tr></table></figure>
<pre><code>1
101
101
Help on class Golem in module __main__:
class Golem(builtins.object)
 |  Golem(name=None)
 |
 |  Methods defined here:
 |
 |  __init__(self, name=None)
 |      Initialize self.  See help(type(self)) for accurate signature.
 |
 |  cease(self)
 |
 |  is_active(self)
 |
 |  say_hi(self)
 |
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |
 |  __dict__
 |      dictionary for instance variables (if defined)
 |
 |  __weakref__
 |      list of weak references to the object (if defined)
 |
 |  population
mappingproxy({&apos;__module__&apos;: &apos;__main__&apos;,
              &apos;_Golem__population&apos;: 101,
              &apos;_Golem__life_span&apos;: 10,
              &apos;__init__&apos;: &lt;function __main__.Golem.__init__(self, name=None)&gt;,
              &apos;say_hi&apos;: &lt;function __main__.Golem.say_hi(self)&gt;,
              &apos;cease&apos;: &lt;function __main__.Golem.cease(self)&gt;,
              &apos;is_active&apos;: &lt;function __main__.Golem.is_active(self)&gt;,
              &apos;population&apos;: &lt;property at 0x1068f9d68&gt;,
              &apos;__dict__&apos;: &lt;attribute &apos;__dict__&apos; of &apos;Golem&apos; objects&gt;,
              &apos;__weakref__&apos;: &lt;attribute &apos;__weakref__&apos; of &apos;Golem&apos; objects&gt;,
              &apos;__doc__&apos;: None})
{&apos;name&apos;: &apos;Clay&apos;, &apos;built_year&apos;: 2019, &apos;_Golem__active&apos;: True}
True
&lt;property at 0x1068f9d68&gt;
10000
</code></pre><h1 id="函数工具"><a href="#函数工具" class="headerlink" title="函数工具"></a>函数工具</h1><p>这一章要讲的是迭代器、生成器和装饰器，这些都是函数工具。有人把它们称为 <strong>DIG</strong>（Decorator，Iterator，Generator）—— 它们都是真正掌握 Python 的关键。</p>
<h2 id="迭代器（Iterator）"><a href="#迭代器（Iterator）" class="headerlink" title="迭代器（Iterator）"></a>迭代器（Iterator）</h2><p>我们已经见过 Python 中的所有容器，都是可迭代的 —— 准确地讲，是可以通过迭代遍历每一个元素：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">string = <span class="string">"this is a string."</span></span><br><span class="line">list = [<span class="string">'item 1'</span>, <span class="string">'item 2'</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">set = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> string:</span><br><span class="line">    print(c, end=<span class="string">', '</span>)</span><br><span class="line">print()</span><br><span class="line"><span class="keyword">for</span> L <span class="keyword">in</span> list:</span><br><span class="line">    print(L, end=<span class="string">', '</span>)</span><br><span class="line">print()</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> set:</span><br><span class="line">    print(s, end=<span class="string">', '</span>)</span><br><span class="line">print()</span><br></pre></td></tr></table></figure>
<pre><code>t, h, i, s,  , i, s,  , a,  , s, t, r, i, n, g, .,
item 1, item 2, 3, 5,
1, 2, 3, 4, 5,
</code></pre><p>有个内建函数，就是用来把一个 “可迭代对象”（Iterable）转换成 “迭代器”（Iterator）的 —— <code>iter()</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line">i = iter(<span class="string">"Python"</span>)</span><br><span class="line">type(i)</span><br><span class="line">s = iter((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line">type(s)</span><br><span class="line">L = iter([<span class="string">'item 1'</span>, <span class="string">'item 2'</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line">type(L)</span><br></pre></td></tr></table></figure>
<pre><code>str_iterator

tuple_iterator

list_iterator
</code></pre><p>迭代器如何使用呢？有个 <code>next()</code> 函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line">i = iter(<span class="string">"Python"</span>)</span><br><span class="line">next(i)</span><br><span class="line">next(i)</span><br><span class="line">next(i)</span><br><span class="line">next(i)</span><br><span class="line">next(i)</span><br><span class="line">next(i)</span><br><span class="line"><span class="comment"># next(i) 前面已经到 'n' 了，再调用就会有 StopIteration 错误提示。</span></span><br></pre></td></tr></table></figure>
<pre><code>&apos;P&apos;
&apos;y&apos;
&apos;t&apos;
&apos;h&apos;
&apos;o&apos;
&apos;n&apos;
</code></pre><p>在 <code>i</code> 这个迭代器里一共有 6 个元素，所以，<code>next(i)</code> 在被调用 6 次之后，就不能再被调用了，一旦再被调用，就会触发 StopIteration 错误。</p>
<p>那我们怎么自己写一个迭代器呢？</p>
<p>迭代器是个 Object，所以，写迭代器的时候写的是 Class，比如，我们写一个数数的迭代器，Counter：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, start, stop)</span>:</span></span><br><span class="line">        self.current = start</span><br><span class="line">        self.stop = stop</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.current &gt; self.stop:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            c = self.current</span><br><span class="line">            self.current += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line">c = Counter(<span class="number">11</span>, <span class="number">20</span>)</span><br><span class="line">next(c)</span><br><span class="line">next(c)</span><br><span class="line">next(c)</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> Counter(<span class="number">101</span>, <span class="number">105</span>):</span><br><span class="line">    print(c, end=<span class="string">', '</span>)</span><br><span class="line">type(Counter)</span><br></pre></td></tr></table></figure>
<pre><code>11
12
13
101
102
103
104
105

type
</code></pre><p>这里的重点在于两个函数的存在，<code>__iter__(self)</code> 和 <code>__next__(self)</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure>
<p>这两句是约定俗成的写法，写上它们，<code>Counter</code> 这个类就被会被识别为 Iterator 类型。而后再有 <code>__next__(self)</code> 的话，它就是个完整的迭代器了。除了可以用 <code>for loop</code> 之外，也可以用 <code>while loop</code> 去遍历迭代器中的所有元素：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, start, stop)</span>:</span></span><br><span class="line">        self.current = start</span><br><span class="line">        self.stop = stop</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.current &gt; self.stop:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            c = self.current</span><br><span class="line">            self.current += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> Counter(<span class="number">101</span>, <span class="number">103</span>):</span><br><span class="line">    print(c, sep=<span class="string">', '</span>)</span><br><span class="line"></span><br><span class="line">c = Counter(<span class="number">201</span>, <span class="number">203</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(next(c), sep=<span class="string">', '</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<pre><code>101
102
103
201
202
203
</code></pre><h2 id="生成器（Generator）"><a href="#生成器（Generator）" class="headerlink" title="生成器（Generator）"></a>生成器（Generator）</h2><p>那用函数（而不是 Class）能不能写一个 Counter 呢？答案是能，用生成器（Generator）就行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">counter</span><span class="params">(start, stop)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> start &lt;= stop:</span><br><span class="line">        <span class="keyword">yield</span> start</span><br><span class="line">        start += <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> counter(<span class="number">101</span>, <span class="number">105</span>):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<pre><code>101
102
103
104
105
</code></pre><p>哎呀！怎么感觉这个简洁很多呢？</p>
<p>不过，是否简洁并不是问题，这次看起来用生成器更简单，无非是因为当前的例子更适合用生成器而已。在不同的情况下，用迭代器和用生成器各有各的优势。</p>
<p>这里的关键在于 <code>yield</code> 这个语句。它和 <code>return</code> 最明显的不同在于，在它之后的语句依然会被执行 —— 而 <code>return</code> 之后的语句就被忽略了。</p>
<p>但正因为这个不同，在写生成器的时候，只能用 <code>yield</code>，而没办法使用 <code>return</code> —— 你现在可以回去把上面代码中的 <code>yield</code> 改成 <code>return</code> 看看，然后体会一下它们之间的不同。</p>
<p>生成器函数被 <code>next()</code> 调用后，执行到 <code>yield</code> 生成一个值返回（然后继续执行 <code>next()</code> 外部剩余的语句）；下次再被 <code>next()</code> 调用的时候，从上次生成返回值的 <code>yield</code> 语句处继续执行…… 如果感觉费解，就多读几遍 —— 而后再想想若是生成器中有多个 <code>yield</code> 语句会是什么情况？</p>
<p>还有一种东西，叫做生成器表达式。先看个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">even = (e <span class="keyword">for</span> e <span class="keyword">in</span> range(<span class="number">10</span>) <span class="keyword">if</span> <span class="keyword">not</span> e % <span class="number">2</span>)</span><br><span class="line"><span class="comment"># odd = (o for o in range(10) if o % 2)</span></span><br><span class="line">print(even)</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> even:</span><br><span class="line">    print(e)</span><br></pre></td></tr></table></figure>
<pre><code>&lt;generator object &lt;genexpr&gt; at 0x107cc0048&gt;
0
2
4
6
8
</code></pre><p>其实，这种表达式我们早就在 List Comprehension 里见过 —— 那就是通过生成器表达式完成的。</p>
<p><strong>注意</strong></p>
<p>仔细看 <code>even = (e for e in range(10) if not e % 2)</code> 中最外面那层括号，用了圆括号，<code>even</code> 就是用生成器创造的迭代器（Iterator），若是用了方括号，那就是用生成器创造的列表（List）—— 当然用花括号 <code>{}</code> 生成的就是集合（Set）……</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># even = (e for e in range(10) if not e % 2)</span></span><br><span class="line">odd = [o <span class="keyword">for</span> o <span class="keyword">in</span> range(<span class="number">10</span>) <span class="keyword">if</span> o % <span class="number">2</span>]</span><br><span class="line">print(odd)</span><br><span class="line"><span class="keyword">for</span> o <span class="keyword">in</span> odd:</span><br><span class="line">    print(o)</span><br></pre></td></tr></table></figure>
<pre><code>[1, 3, 5, 7, 9]
1
3
5
7
9
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># even = (e for e in range(10) if not e % 2)</span></span><br><span class="line">odd = &#123;o <span class="keyword">for</span> o <span class="keyword">in</span> range(<span class="number">10</span>) <span class="keyword">if</span> o % <span class="number">2</span>&#125;</span><br><span class="line">print(odd)</span><br><span class="line"><span class="keyword">for</span> o <span class="keyword">in</span> odd:</span><br><span class="line">    print(o)</span><br></pre></td></tr></table></figure>
<pre><code>{1, 3, 5, 7, 9}
1
3
5
7
9
</code></pre><p><strong>生成器表达式必须在括号内使用</strong>（参见官方 <a href="https://docs.python.org/3/howto/functional.html#generator-expressions-and-list-comprehensions" target="_blank" rel="noopener">HOWTOS</a>），包括函数的参数括号，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum_of_even = sum(e <span class="keyword">for</span> e <span class="keyword">in</span> range(<span class="number">10</span>) <span class="keyword">if</span> <span class="keyword">not</span> e % <span class="number">2</span>)</span><br><span class="line">print(sum_of_even)</span><br></pre></td></tr></table></figure>
<pre><code>20
</code></pre><p>函数内部当然可以包含其它的函数，以下就是一个函数中包含着其它函数的结构示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">b_func</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">c_func</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">d_func</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        b_func()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>想象一下，如果，我们让一个函数返回的是另外一个函数呢？我们一步一步来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">b_func</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"Hi, I'm b_func!"</span>)</span><br><span class="line">    print(<span class="string">"Hi, I'm a_func!"</span>)</span><br><span class="line">a_func()</span><br></pre></td></tr></table></figure>
<pre><code>Hi, I&apos;m a_func!
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">b_func</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"Hi, I'm b_func!"</span>)</span><br><span class="line">    print(<span class="string">"Hi, I'm a_func!"</span>)</span><br><span class="line">    b_func()</span><br><span class="line">a_func()</span><br></pre></td></tr></table></figure>
<pre><code>Hi, I&apos;m a_func!
Hi, I&apos;m b_func!
</code></pre><p>上一个代码，我们可以写成这样 —— 让 <code>a_func()</code> 将它内部的 <code>b_func()</code> 作为它的返回值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">b_func</span><span class="params">()</span>:</span></span><br><span class="line">       print(<span class="string">"Hi, I'm b_func!"</span>)</span><br><span class="line">    print(<span class="string">"Hi, I'm a_func!"</span>)</span><br><span class="line">    <span class="keyword">return</span> b_func()</span><br><span class="line">a_func()</span><br></pre></td></tr></table></figure>
<pre><code>Hi, I&apos;m a_func!
Hi, I&apos;m b_func!
</code></pre><p>如果我们在 <code>return</code> 语句里只写函数名呢？好像这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">b_func</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"Hi, I'm b_func!"</span>)</span><br><span class="line">    print(<span class="string">"Hi, I'm a_func!"</span>)</span><br><span class="line">    <span class="keyword">return</span> b_func</span><br><span class="line">a_func()</span><br></pre></td></tr></table></figure>
<pre><code>Hi, I&apos;m a_func!
&lt;function __main__.a_func.&lt;locals&gt;.b_func()&gt;
</code></pre><p>这次返回的不是调用 <code>b_func()</code> 这个函数的执行结果，返回的是 <code>b_func</code> 这个<em>函数本身</em>。</p>
<h2 id="装饰器（Decorator）"><a href="#装饰器（Decorator）" class="headerlink" title="装饰器（Decorator）"></a>装饰器（Decorator）</h2><h3 id="函数也是对象"><a href="#函数也是对象" class="headerlink" title="函数也是对象"></a>函数也是对象</h3><p>这是关键：</p>
<blockquote>
<p>函数本身也是对象（即，Python 定义的某个 Class 的一个 Instance）。</p>
</blockquote>
<p>于是，函数本身其实可以与其它的数据类型一样，作为其它函数的参数或者返回值。</p>
<p>让我们分步走 —— 注意，在以下代码中，<code>a_decorator</code> 返回的一个函数的调用 <code>wrapper()</code> 而不是 <code>wrapper</code> 这个函数本身：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'We can do sth. before a func is called...'</span>)</span><br><span class="line">        func()</span><br><span class="line">        print(<span class="string">'... and we can do sth. after it is called...'</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Hi, I'm a_func!"</span>)</span><br><span class="line"></span><br><span class="line">a_func()</span><br><span class="line">a_decorator(a_func)</span><br></pre></td></tr></table></figure>
<pre><code>Hi, I&apos;m a_func!
We can do sth. before a func is called...
Hi, I&apos;m a_func!
... and we can do sth. after it is called...
</code></pre><p>如果返回的是函数本身，<code>wrapper</code>，输出结果跟你想的并不一样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'We can do sth. before a func is called...'</span>)</span><br><span class="line">        func()</span><br><span class="line">        print(<span class="string">'... and we can do sth. after it is called...'</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper  <span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Hi, I'm a_func!"</span>)</span><br><span class="line"></span><br><span class="line">a_func()</span><br><span class="line">a_decorator(a_func)</span><br></pre></td></tr></table></figure>
<pre><code>Hi, I&apos;m a_func!
&lt;function __main__.a_decorator.&lt;locals&gt;.wrapper()&gt;
</code></pre><h3 id="装饰器操作符"><a href="#装饰器操作符" class="headerlink" title="装饰器操作符"></a>装饰器操作符</h3><p>不过，Python 提供了一个针对函数的操作符 <code>@</code>，它的作用是…… 很难一下子说清楚，先看看以下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'We can do sth. before calling a_func...'</span>)</span><br><span class="line">        func()</span><br><span class="line">        print(<span class="string">'... and we can do sth. after it was called...'</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@a_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Hi, I'm a_func!"</span>)</span><br><span class="line"></span><br><span class="line">a_func()</span><br></pre></td></tr></table></figure>
<pre><code>We can do sth. before calling a_func...
Hi, I&apos;m a_func!
... and we can do sth. after it was called...
</code></pre><p>注意：以上的代码中，<code>a_decorator(func)</code> 返回的是 <code>wrapper</code> 这个函数本身。</p>
<p>在我们定义 <code>a_func()</code> 的时候，在它之前，加上了一句 <code>@a_decorator</code>；这么做的结果是：</p>
<blockquote>
<p>每次 <code>a_func()</code> 在被调用的时候，因为它之前有一句 <code>@a_decorator</code>，所以它会先被当作参数传递到 <code>a_decorator(func)</code> 这个函数中…… 而后，真正的执行，是在 <code>a_decorator()</code> 里被完成的。</p>
</blockquote>
<p>—— 被 <code>@</code> 调用的函数，叫做 “装饰器”（Decorator），比如，以上代码中的 <code>a_decorator(func)</code>。</p>
<p>现在可以很简单直接地说清楚装饰器的作用了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@a_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_func</span><span class="params">()</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_func</span><span class="params">()</span>:</span></span><br><span class="line">    ...</span><br><span class="line">a_func = a_decorator(a_func)</span><br></pre></td></tr></table></figure>
<p>就是用 <code>a_decorator</code> 的调用结果替换掉原来的函数。<code>a_decorator</code> 返回值是什么，以后调用 <code>a_func</code> 时就是在调用这个返回值，而 <code>a_decorator</code> 本身此时已经执行完毕了。</p>
<h3 id="装饰器的用途"><a href="#装饰器的用途" class="headerlink" title="装饰器的用途"></a>装饰器的用途</h3><p>Decorator 最常用的场景是什么呢？最常用的场景就是用来改变其它函数的行为。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">an_output</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'The quick brown fox jumps over the lazy dog.'</span></span><br><span class="line">print(an_output())</span><br></pre></td></tr></table></figure>
<pre><code>The quick brown fox jumps over the lazy dog.
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uppercase</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        original_result = func()</span><br><span class="line">        modified_restult = original_result.upper()</span><br><span class="line">        <span class="keyword">return</span> modified_restult</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@uppercase</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">an_output</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'The quick brown fox jumps over the lazy dog.'</span></span><br><span class="line">print(an_output())</span><br></pre></td></tr></table></figure>
<pre><code>THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG.
</code></pre><p>你还可以给一个函数加上一个以上的装饰器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uppercase</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        original_result = func()</span><br><span class="line">        modified_restult = original_result.upper()</span><br><span class="line">        <span class="keyword">return</span> modified_restult</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">strong</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        original_result = func()</span><br><span class="line">        modified_restult = <span class="string">'&lt;strong&gt;'</span>+original_result+<span class="string">'&lt;/strong&gt;'</span></span><br><span class="line">        <span class="keyword">return</span> modified_restult</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@strong</span></span><br><span class="line"><span class="meta">@uppercase</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">an_output</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'The quick brown fox jumps over the lazy dog.'</span></span><br><span class="line">print(an_output())</span><br></pre></td></tr></table></figure>
<pre><code>&lt;strong&gt;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG.&lt;/strong&gt;
</code></pre><p>你把两个装饰器的顺序调换一下写成下面这样试试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@uppercase</span></span><br><span class="line"><span class="meta">@strong</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">an_output</span><span class="params">()</span>:</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>装饰器的执行顺序是 “自下而上” —— 其实是 “由里到外” 更为准确。体会一下。</p>
<h3 id="装饰带有参数的函数"><a href="#装饰带有参数的函数" class="headerlink" title="装饰带有参数的函数"></a>装饰带有参数的函数</h3><p>到现在我们见到的使用装饰器的函数都是没有参数的：<code>an_output</code> 以及之前的 <code>a_func</code>。</p>
<p>如果被装饰的函数有参数怎么办？装饰器自身内部又应该怎么写？</p>
<p>这时候，Python 的 <code>*args</code> and <code>**kwargs</code> 的威力就显现出来了 —— 之前怕麻烦没有通过仔细反复阅读搞定这 “一个星号、两个星号、直接晕倒” 的知识点的人，现在恐怕要吃亏了……</p>
<p>装饰器函数本身这么写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> original_result</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>
<p>在这里，<code>(*args, **kwargs)</code> 非常强大，它可以匹配所有函数传进来的所有参数…… 准确地讲，<code>*args</code> 接收并处理所有传递进来的位置参数，<code>**kwargs</code> 接收并处理所有传递进来的关键字参数。</p>
<p>假设我们有这么个函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hi</span><span class="params">(greeting, name=None)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> greeting + <span class="string">'! '</span> + name + <span class="string">'.'</span></span><br><span class="line"></span><br><span class="line">print(say_hi(<span class="string">'Hello'</span>, <span class="string">'Jack'</span>))</span><br></pre></td></tr></table></figure>
<pre><code>Hello! Jack.
</code></pre><p>如果我们想在装饰器里对函数名、参数，都做些事情 —— 比如，我们写个 <code>@trace</code> 用来告诉用户调用一个函数的时候都发生了什么……</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trace</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">f"Trace: You've called a function: <span class="subst">&#123;func.__name__&#125;</span>(),"</span>,</span><br><span class="line">              <span class="string">f"with args: <span class="subst">&#123;args&#125;</span>; kwargs: <span class="subst">&#123;kwargs&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">        original_result = func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">f"Trace: <span class="subst">&#123;func.__name__&#125;</span><span class="subst">&#123;args&#125;</span> returned: <span class="subst">&#123;original_result&#125;</span>"</span>)</span><br><span class="line">        <span class="keyword">return</span> original_result</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@trace</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hi</span><span class="params">(greeting, name=None)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> greeting + <span class="string">'! '</span> + name + <span class="string">'.'</span></span><br><span class="line"></span><br><span class="line">print(say_hi(<span class="string">'Hello'</span>, name = <span class="string">'Jack'</span>))</span><br></pre></td></tr></table></figure>
<pre><code>Trace: You&apos;ve called a function: say_hi(), with args: (&apos;Hello&apos;,); kwargs: {&apos;name&apos;: &apos;Jack&apos;}
Trace: say_hi(&apos;Hello&apos;,) returned: Hello! Jack.
Hello! Jack.
</code></pre><p>有了以上的基础知识之后，再去阅读 Python Decorator Library 的 Wiki 页面就会轻松许多：</p>
<blockquote>
<p><a href="https://wiki.python.org/moin/PythonDecoratorLibrary" target="_blank" rel="noopener">https://wiki.python.org/moin/PythonDecoratorLibrary</a></p>
</blockquote>
<h3 id="学会装饰器究竟有多重要？"><a href="#学会装饰器究竟有多重要？" class="headerlink" title="学会装饰器究竟有多重要？"></a>学会装饰器究竟有多重要？</h3><p>装饰器一定要学会 —— 因为很多人就是不会。</p>
<p>Oreilly.com 上有篇文章，《5 reasons you need to learn to write Python decorators》中，其中的第五条竟然是：<strong>Boosting your career</strong>!</p>
<blockquote>
<p>Writing decorators isn’t easy at first. It’s not rocket science, but takes enough effort to learn, and to grok the nuances involved, that many developers will never go to the trouble to master it. And that works to your advantage. When you become the person on your team who learns to write decorators well, and write decorators that solve real problems, other developers will use them. Because once the hard work of writing them is done, decorators are so easy to use. This can massively magnify the positive impact of the code you write. And it just might make you a hero, too.</p>
<p>As I’ve traveled far and wide, training hundreds of working software engineers to use Python more effectively, teams have consistently reported writing decorators to be one of the most valuable and important tools they’ve learned in my advanced Python programming workshops.</p>
</blockquote>
<p>为什么有那么多人就是学不会呢？—— 只不过是因为在此之前，遇到 <code>*args</code> <code>**kwargs</code> 的时候，“一个星号、两个星号、直接晕倒”…… 而后并未再多挣扎一下。</p>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>正则表达式本质上是个独立的语言，短小却格外强悍 —— 乃至于，如果你竟然没学会它的话，你的之前学的编程技能干脆与残疾无异。</p>
<p>Wikipedia 上对正则表达式的说明如下：</p>
<blockquote>
<p><strong>正则表达式</strong>（英语：Regular Expression，在代码中常简写为 regex、regexp 或 RE），又称<em>正规表示式</em>、<em>正规表示法</em>、<em>正规运算式</em>、<em>规则运算式</em>、<em>常规表示法</em>，是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。许多程序设计语言都支持利用正则表达式进行字符串操作。例如，在 Perl 中就内建了一个功能强大的正则表达式引擎。正则表达式这个概念最初是由 Unix 中的工具软件（例如 sed 和 grep）普及开的。</p>
</blockquote>
<p>以下是绝大多数翻译成中文的教程中对正则表达式进行讲解时所使用的描述：</p>
<blockquote>
<p>一个正则表达式（Regular Expression）通常被称为一个模式（Pattern）。</p>
</blockquote>
<p>我常常觉得当初要是它被翻译成 “规则表达式”，那么很可能初学者不会感到那么大的压力 —— 谁都一样，看着由 “每个都认识的字构成的词组” 却不能直观地想到它究竟是什么东西，都会感到莫名的压力。</p>
<p><strong>Regular</strong>，其实在它的众多语义中，取以下释义最符合 Regular Expression 的原意<a href="#fn1" name="fn1b"><sup>[1]</sup></a>：</p>
<blockquote>
<p>⑭ Linguistics 规则的 ▸ regular verbs 规则动词</p>
</blockquote>
<p>而 <strong>Pattern</strong> 这个词，在词典里有好几个对应的中文词汇：</p>
<blockquote>
<p>① 图案；② 式样；③ 图样；④ 榜样；⑤ 模式；⑥ 样品；⑦ 模子</p>
</blockquote>
<p>在当前语境之下，把 Pattern 翻译成 “模式”，显然不如 “模子” 更好（甚至连 “样品” 感觉都比 “模式” 更恰当）—— “模子” 这个词很直观啊，拿着一个模子去找与它一致的字符串…… “与规则一致”，英文用的是 <strong>Match</strong>，一般被翻译作 “匹配”。</p>
<p>在自学编程的过程中，处处都是这种语言翻译带来的迷惑、障碍，或者耽误。既然应该把 Regular Expression 理解为 “规则表达式” 更好，那其实吧，把 Pattern 直接理解为中文的 “<em>规则</em>”，可能更直观更准确，理解上更是毫无障碍：</p>
<blockquote>
<p>一个规则表达式（Regular Expression）通常被称为一个规则（Pattern）。</p>
</blockquote>
<p>那么，<strong>规则表达式</strong>里写的是什么呢？只能是<strong>规则</strong>了…… 到最后好像也就 “捕获”（Capture）这个词没什么歧义。</p>
<p>现在，我们已经把术语全部 “解密” 了，然后再看看下面的表述：</p>
<blockquote>
<p>我们可以用书写特定的规则，用来在文本中捕获与规则一致的字符串，而后对其进行操作……</p>
</blockquote>
<p>理解起来相当顺畅。</p>
<p>以下的 Python 代码中，<a href="https://regexper.com#%5Cwo%5Cw" target="_blank" rel="noopener"><code>\wo\w</code></a> 就是一个<em>规则表达式</em>（或称为<em>规则</em>）；</p>
<p>而 <code>re.findall(pttn, str)</code> 的作用就是，在 <code>str</code> 里找到所有与这个<strong>规则</strong>（Pattern，模式）<strong>一致</strong>（Match，匹配）的字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">str = <span class="string">'The quick brown fox jumps over the lazy dog'</span></span><br><span class="line">pttn = re.compile(<span class="string">r'\wo\w'</span>)</span><br><span class="line">re.findall(pttn, str)</span><br></pre></td></tr></table></figure>
<pre><code>[&apos;row&apos;, &apos;fox&apos;, &apos;dog&apos;]
</code></pre><p>总结一下：</p>
<blockquote>
<p><strong>规则表达式</strong>（Regular Expressions，通常缩写为 Regex）是最强大且不可或缺的文本处理工具 —— 它的用处就是在文本中<strong>扫描/搜索</strong>（Scan/Search）与某一<strong>规则</strong>（Pattern）<strong>匹配</strong>（Match，即，与规则一致）的所有实例，并且还可以按照规则<strong>捕获</strong>（Capture）其中的部分或者全部，对它们进行<strong>替换</strong>（Replace）。</p>
</blockquote>
<p>接下来为了避免歧义，我们干脆用 Regex 这个缩写，以及与它相关的英文单词：pattern, match, capture, replace(ment)……</p>
<p>有时，使用 Regex 并不是为了 Replace，而是为了检查格式，比如，可以用 Regex 检查用户输入的密码是否过于简单（比如，全部都由数字构成），比如可以用来验证用户输入的电话号码、证件号码是否符合特定格式等等。</p>
<p>另外，在自学的过程中，想尽一切办法把一切术语用简单直白的 “人话” 重新表述，是特别有效的促进进步的行为模式。</p>
<h2 id="视觉体验"><a href="#视觉体验" class="headerlink" title="视觉体验"></a>视觉体验</h2><p>所谓百闻不如一见。</p>
<p>眼见为实 —— 想办法让一个陌生的概念视觉上直观，是突破大多学习障碍的最简单粗暴直接有效的方式。</p>
<p>我们最好先直接看看 Regex 的工作过程。以下，是用微软发行的代码编辑工具 Visual Studio Code 针对一小段文本使用若干条 Regex 进行匹配的过程：</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/regex-test.gif?raw=true" alt></p>
<p>Python 的项目代码仓库里有一个很简短的 Demo 程序，叫 <a href="https://github.com/python/cpython/blob/master/Tools/demo/redemo.py" target="_blank" rel="noopener"><code>redemo.py</code></a>，它使用 <a href="https://docs.python.org/3/library/tkinter.html" target="_blank" rel="noopener">Tcl/Tk</a> 作为图形界面，也可以用来测试正则表达式。</p>
<p>它的代码地址是：</p>
<blockquote>
<p><a href="https://raw.githubusercontent.com/python/cpython/master/Tools/demo/redemo.py" target="_blank" rel="noopener">https://raw.githubusercontent.com/python/cpython/master/Tools/demo/redemo.py</a></p>
</blockquote>
<p>它运行起来长成这样：</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/redemo.png?raw=true" alt></p>
<p>目前（2019）网上最方便的 Regex 测试器，是 <a href="https://regex101.com" target="_blank" rel="noopener">regex101.com</a>：</p>
<p>以下，就是在一段文本中，找出所有首写字母大写的词汇的<em>过程</em>，并将其先全部替换成小写，再将其全部替换为大写的过程；使用的正则表达式是 <code>([A-Z]\w+)</code>，替换表达式分别是 <code>\L$1</code> 和 <code>\U$1</code>：</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/regex101.gif?raw=true" alt></p>
<p>这个网站太好了，所以，平日里我是用 <a href="https://github.com/jiahaog/nativefier" target="_blank" rel="noopener">Nativefier</a> 工具将这个网站打包为一个 Mac Desktop App 使用。不过，它也有局限，就是被搜索文件略微大点就报错，说 <code>timeout</code>……</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们需要个文本文件，用来当作练习使用正则表达式去搜索替换的目标。这个文件保存在当前的根目录，文件名称是：<code>regex-target-text-sample.txt</code>。</p>
<p>以下代码中，<code>pttn = r&#39;beg[iau]ns?&#39;</code> 这一句中的 <a href="https://regexper.com#beg[iau]ns?" target="_blank" rel="noopener"><code>beg[iau]ns?</code></a> 就是 Regex 的 Pattern。</p>
<p><strong>注意</strong>：在 Python 代码中，写 Pattern 的时候，之所以要在字符串 <code>&#39;...&#39;</code> 之前加上 <code>r</code>，写成 <code>r&#39;...&#39;</code>，是因为如果不用 raw string 的话，那么，每个转义符号都要写成 <code>\\</code>；如果用 raw string，转义符号就可以直接使用 <code>\</code> 本身了…… 当然，如果你想搜索 <code>\</code> 这个符号本身的话，那么还是得写 <code>\\</code>。</p>
<p>而 <code>re.findall(pttn, str)</code> 的意思是说，把 <code>str</code> 中所有与 <code>pttn</code> 这个规则一致的字符串都找出来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'regex-target-text-sample.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    str = f.read()</span><br><span class="line">pttn = <span class="string">r'beg[iau]ns?'</span></span><br><span class="line">re.findall(pttn, str)</span><br></pre></td></tr></table></figure>
<pre><code>[&apos;begin&apos;, &apos;began&apos;, &apos;begun&apos;, &apos;begin&apos;]
</code></pre><p>文件 <code>regex-target-text-sample.txt</code> 中的内容如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">pre</span>&gt;</span>begin began begun bigins begining<span class="tag">&lt;/<span class="name">pre</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">pre</span>&gt;</span>google gooogle goooogle goooooogle<span class="tag">&lt;/<span class="name">pre</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">pre</span>&gt;</span>coloured color coloring  colouring colored<span class="tag">&lt;/<span class="name">pre</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">pre</span>&gt;</span>never ever verb however everest<span class="tag">&lt;/<span class="name">pre</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">pre</span>&gt;</span>520 52000 5200000 520000000 520000000000<span class="tag">&lt;/<span class="name">pre</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">pre</span>&gt;</span>error wonderer achroiocythaemia achroiocythemia<span class="tag">&lt;/<span class="name">pre</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">pre</span>&gt;</span>The white dog wears a black hat.<span class="tag">&lt;/<span class="name">pre</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">pre</span>&gt;</span>Handel, Händel, Haendel<span class="tag">&lt;/<span class="name">pre</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span>(843) 542-4256<span class="tag">&lt;/<span class="name">dl</span>&gt;</span> <span class="tag">&lt;<span class="name">dl</span>&gt;</span>(431) 270-9664<span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span>3336741162<span class="tag">&lt;/<span class="name">dl</span>&gt;</span> <span class="tag">&lt;<span class="name">dl</span>&gt;</span>3454953965<span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>peoplesr@live.com<span class="tag">&lt;/<span class="name">li</span>&gt;</span> <span class="tag">&lt;<span class="name">li</span>&gt;</span>jaxweb@hotmail.com<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>dhwon@comcast.net<span class="tag">&lt;/<span class="name">li</span>&gt;</span> <span class="tag">&lt;<span class="name">li</span>&gt;</span>krueger@me.com<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>URLs<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">https://docs.python.org/3/howto/regex.html</span><br><span class="line">https://docs.python.org/3/library/re.html</span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>passwords<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">Pasw0rd~</span><br><span class="line">i*Eh,GF67E</span><br><span class="line">a$4Bh9XE&amp;E</span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>duplicate words<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>It's very very big.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Keep it simple, simple, simple!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在以下的示例中，有时直接设定了 str 的值，而不是使用以上整个文本文件 —— 因为读者在阅读的时候，最好能直接看到被搜索的字符串。另外，如果使用整个文件，所得到的 Match 太多，也确实影响阅读。</p>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>毕竟，你已经不是 “啥都不懂” 的人了。你已经知道一个事实：编程语言无非是用来运算的。</p>
<p>所谓的运算，就有操作符（Operators）和操作元（Operands）—— 而操作符肯定是有优先级的，不然的话，那么多操作元和操作符放在一起，究竟先操作哪个呢？</p>
<p>Regex 也一样，它本身就是个迷你语言（Mini Language）。在 Regex 中，操作符肯定也有优先级。它的操作元有个专门的名称，<strong>原子</strong>（Atom）。</p>
<p>先大致看看它的操作符优先级，你就会对它有相当不错的了解：</p>
<table>
<thead>
<tr>
<th>排列</th>
<th>原子与操作符优先级</th>
<th>（从高到低）</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>转义符号 (Escaping Symbol)</td>
<td><code>\</code></td>
</tr>
<tr>
<td>2</td>
<td>分组、捕获 (Grouping or Capturing)</td>
<td><code>(...)</code> <code>(?:...)</code> <code>(?=...)</code> <code>(?!...)</code> <code>(?&lt;=...)</code> <code>(?&lt;!...)</code></td>
</tr>
<tr>
<td>3</td>
<td>数量 (Quantifiers)</td>
<td><code>a*</code> <code>a+</code> <code>a?</code> <code>a{n, m}</code></td>
</tr>
<tr>
<td>4</td>
<td>序列与定位（Sequence and Anchor）</td>
<td><code>abc</code> <code>^</code> <code>$</code> <code>\b</code> <code>\B</code></td>
</tr>
<tr>
<td>5</td>
<td>或（Alternation）</td>
<td>`a\</td>
<td>b\</td>
<td>c`</td>
</tr>
<tr>
<td>6</td>
<td>原子 (Atoms)</td>
<td><code>a</code> <code>[^abc]</code> <code>\t</code> <code>\r</code> <code>\n</code> <code>\d</code> <code>\D</code> <code>\s</code> <code>\S</code> <code>\w</code> <code>\W</code> <code>.</code></td>
</tr>
</tbody>
</table>
<p>当然，你若是在之前，没有自学过、理解过 Python（或者任何其它编程语言）表达式中的操作符优先级，那么一上来就看上面的表格不仅对你没有帮助，只能让你更迷惑。</p>
<p>—— 这就是理解能力逐步积累逐步加强的过程。</p>
<h2 id="原子"><a href="#原子" class="headerlink" title="原子"></a>原子</h2><p>在 Regex 的 Pattern 中，操作元，即，被运算的 “值”，被称为<strong>原子</strong>（Atom）。</p>
<h3 id="本义字符"><a href="#本义字符" class="headerlink" title="本义字符"></a>本义字符</h3><p>最基本的原子，就是本义字符，它们都是单个字符。</p>
<p>本义字符包括从 <code>a</code> 到 <code>z</code>，<code>A</code> 到 <code>Z</code>，<code>0</code> 到 <code>9</code>，还有 <code>_</code> —— 它们所代表的就是它们的字面值。</p>
<p>即，相当于，<code>string.ascii_letters</code> 和 <code>string.digits</code> 以及 <code>_</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line">string.ascii_letters</span><br><span class="line">string.digits</span><br></pre></td></tr></table></figure>
<pre><code>&apos;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&apos;
&apos;0123456789&apos;
</code></pre><p>以下字符在 Regex 中都有特殊含义：</p>
<blockquote>
<p><code>\</code> <code>+</code> <code>*</code> <code>.</code> <code>?</code> <code>-</code> <code>^</code> <code>$</code> <code>|</code> <code>(</code> <code>)</code> <code>[</code> <code>]</code> <code>{</code> <code>}</code> <code>&lt;</code> <code>&gt;</code></p>
</blockquote>
<p>当你在写 Regex 的时候，如果你需要搜索的字符不是本义字符，而是以上这些特殊字符时，<em>建议</em>都直接加上转义符号 <code>\</code> 来表示，比如，你想搜索 <code>&#39;</code>，那你就写 <code>\&#39;</code>，或者你想搜索 <code>#</code> 那你就写 <code>\#</code>（事实上，<code>#</code> 并不是 Regex 的特殊符号，所以，它之前的转义符号可有可无）—— 这对初学者来说可能是最安全的策略。</p>
<p>跟过往一样，所有的细节都很重要，它们就是需要花时间逐步熟悉到牢记。</p>
<h3 id="集合原子"><a href="#集合原子" class="headerlink" title="集合原子"></a>集合原子</h3><p>集合原子还是原子。</p>
<p>标示集合原子，使用方括号 <code>[]</code>。<code>[abc]</code> 的意思是说，“<code>a</code> or <code>b</code> or <code>c</code>”，即，<code>abc</code> 中的任意一个字符。</p>
<p>比如，<a href="https://regexper.com#beg[iau]n" target="_blank" rel="noopener"><code>beg[iau]n</code></a> 能够代表 <code>begin</code>、<code>began</code>，以及 <code>begun</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">str = <span class="string">'begin began begun bigins begining'</span></span><br><span class="line">pttn = <span class="string">r'beg[iau]n'</span></span><br><span class="line">re.findall(pttn, str)</span><br></pre></td></tr></table></figure>
<pre><code>[&apos;begin&apos;, &apos;began&apos;, &apos;begun&apos;, &apos;begin&apos;]
</code></pre><p>在方括号中，我们可以使用两个操作符：<code>-</code>（区间）和 <code>^</code>（非）。</p>
<ul>
<li><code>[a-z]</code> 表示从小写字母 <code>a</code> 到小写字母 <code>z</code> 中的任意一个字符。</li>
<li><code>[^abc]</code> 表示 <code>abc</code> 以外的其它任意字符，即，非 <code>[abc]</code>。</li>
</ul>
<p>注意，一个集合原子中，<code>^</code> 符号只能用一次，只能紧跟在 <code>[</code> 之后。否则不起作用。</p>
<h3 id="类别原子"><a href="#类别原子" class="headerlink" title="类别原子"></a>类别原子</h3><p>类别原子，是指那些能够代表 “一类字符” 的原子，它们都得使用转义符号再加上另外一个符号表达，包括：</p>
<p><code>\d</code> 任意数字；等价于 <code>[0-9]</code></p>
<p><code>\D</code> 任意非数字；等价于 <code>[^0-9]</code></p>
<p><code>\w</code> 任意本义字符；等价于 <code>[a-zA-Z0-9_]</code></p>
<p><code>\W</code> 任意非本义字符；等价于 <code>[^a-zA-Z0-9_]</code></p>
<p><code>\s</code> 任意空白；相当于 <code>[ \f\n\r\t\v]</code>（注意，方括号内第一个字符是空格符号）</p>
<p><code>\S</code> 任意非空白；相当于 <code>[^ \f\n\r\t\v]</code>（注意，紧随 <code>^</code> 之后的是一个空格符号）</p>
<p><code>.</code> 除 <code>\r</code> <code>\n</code> 之外的任意字符；相当于 <code>[^\r\n]</code></p>
<p>类别原子挺好记忆的，如果你知道各个字母是哪个词的首字母的话：</p>
<blockquote>
<ul>
<li><code>d</code> 是 digits</li>
<li><code>w</code> 是 word characters</li>
<li><code>s</code> 是 spaces</li>
</ul>
</blockquote>
<p>另外，在空白的集合 <code>[ \f\n\r\t\v]</code> 中：<code>\f</code> 是分页符；<code>\n</code> <code>\r</code> 是换行符；<code>\t</code> 是制表符；<code>\v</code> 是纵向制表符（很少用到）。各种关于空白的转义符也同样挺好记忆的，如果你知道各个字母是那个词的首字母的话：</p>
<blockquote>
<ul>
<li><code>f</code> 是 flip</li>
<li><code>n</code> 是 new line</li>
<li><code>r</code> 是 return</li>
<li><code>t</code> 是 tab</li>
<li><code>v</code> 是 vertical tab</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">str = <span class="string">'&lt;dl&gt;(843) 542-4256&lt;/dl&gt; &lt;dl&gt;(431) 270-9664&lt;/dl&gt;'</span></span><br><span class="line">pttn = <span class="string">r'\d\d\d\-'</span></span><br><span class="line">re.findall(pttn, str)</span><br></pre></td></tr></table></figure>
<pre><code>[&apos;542-&apos;, &apos;270-&apos;]
</code></pre><h3 id="边界原子"><a href="#边界原子" class="headerlink" title="边界原子"></a>边界原子</h3><p>我们可以用边界原子指定边界。也可以称作 “定位操作符”。</p>
<p><code>^</code> 匹配被搜索字符串的开始位置；</p>
<p><code>$</code> 匹配被搜索字符串的结束位置；</p>
<p><code>\b</code> 匹配单词的边界；<a href="https://regexper.com#er%5Cb" target="_blank" rel="noopener"><code>er\b</code></a>，能匹配 <code>coder</code> 中的 <code>er</code>，却不能匹配 <code>error</code> 中的 <code>er</code>；</p>
<p><code>\B</code> 匹配非单词边界；<a href="https://regexper.com#er%5CB" target="_blank" rel="noopener"><code>er\B</code></a>，能匹配 <code>error</code> 中的 <code>er</code>，却不能匹配 <code>coder</code> 中的 <code>er</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">str = <span class="string">'never ever verb however everest'</span></span><br><span class="line">pttn = <span class="string">r'er\b'</span></span><br><span class="line">re.findall(pttn, str)</span><br><span class="line">pttn = <span class="string">r'er\B'</span></span><br><span class="line">re.findall(pttn, str)</span><br></pre></td></tr></table></figure>
<pre><code>[&apos;er&apos;, &apos;er&apos;, &apos;er&apos;]
[&apos;er&apos;, &apos;er&apos;]
</code></pre><p><strong>注意</strong>：<code>^</code> 和 <code>$</code> 在 Python 语言中被 <code>\A</code> 和 <code>\Z</code> 替代。</p>
<p>事实上，每种语言或多或少都对 Regex 有自己的定制。不过，本章讨论的绝大多数细节，都是通用的。</p>
<h3 id="组合原子"><a href="#组合原子" class="headerlink" title="组合原子"></a>组合原子</h3><p>我们可以用圆括号 <code>()</code> 将多个单字符原子组合成一个原子 —— 这么做的结果是，<code>()</code> 内的字符串将被当作一整个原子，可以被随后我们要讲解的数量操作符操作。</p>
<p>另外，<code>()</code> 这个操作符，有两个作用：<strong>组合</strong>（Grouping），就是我们刚刚讲到的作用；而另外一个作用是<strong>捕获</strong>（Capturing)，后面会讲到。</p>
<p>注意区别，<a href="https://regexper.com#er" target="_blank" rel="noopener"><code>er</code></a>、<a href="https://regexper.com#[er]" target="_blank" rel="noopener"><code>[er]</code></a> 和 <a href="https://regexper.com#(er" target="_blank" rel="noopener"><code>(er)</code></a> 各不相同。</p>
<blockquote>
<ul>
<li><code>er</code> 是两个原子，<code>&#39;e&#39;</code> 和紧随其后的 <code>&#39;r&#39;</code></li>
<li><code>[er]</code> 是一个原子，或者 <code>&#39;e&#39;</code> 或者 <code>&#39;r&#39;</code>；</li>
<li><code>(er)</code> 是一个原子，<code>&#39;er&#39;</code></li>
</ul>
</blockquote>
<p>下一节中讲到数量操作符的时候，会再次强调这点。</p>
<h2 id="数量操作符"><a href="#数量操作符" class="headerlink" title="数量操作符"></a>数量操作符</h2><p>数量操作符有：<code>+</code> <code>?</code> <code>*</code> <code>{n, m}</code>。</p>
<p>它们是用来限定位于它们之前的原子允许出现的个数；不加数量限定则代表出现一次且仅出现一次：</p>
<p><code>+</code> 代表前面的原子必须至少出现一次，即：<code>出现次数 ≧ 1</code></p>
<blockquote>
<p>例如，<a href="https://regexper.com#go+gle" target="_blank" rel="noopener"><code>go+gle</code></a>可以匹配 <code>google</code> <code>gooogle</code> <code>goooogle</code> 等；</p>
</blockquote>
<p><code>?</code> 代表前面的原子最多只可以出现一次，即：<code>0 ≦ 出现次数 ≦ 1</code></p>
<blockquote>
<p>例如，<a href="https://regexper.com#colou?red" target="_blank" rel="noopener"><code>colou?red</code></a>可以匹配 <code>colored</code> 或者 <code>coloured</code>;</p>
</blockquote>
<p><code>*</code> 代表前面的原子可以不出现，也可以出现一次或者多次，即：<code>出现次数 ≧ 0</code></p>
<blockquote>
<p>例如，<a href="https://regexper.com#520*" target="_blank" rel="noopener"><code>520*</code></a>可以匹配 <code>52</code> <code>520</code> <code>52000</code> <code>5200000</code> <code>520000000000</code> 等。</p>
</blockquote>
<p><code>{n}</code> 之前的原子出现确定的 <code>n</code> 次；</p>
<p><code>{n,}</code> 之前的原子出现至少 <code>n</code> 次；</p>
<p><code>{n, m}</code> 之前的原子出现至少 <code>n</code> 次，至多 <code>m</code> 次</p>
<blockquote>
<p>例如，<a href="https://regexper.com#go%7B2,5%7Dgle" target="_blank" rel="noopener"><code>go{2,5}gle</code></a>，能匹配 <code>google</code> <code>gooogle</code> <code>goooogle</code> 或 <code>gooooogle</code>，但不能匹配 <code>gogle</code> 和 <code>gooooooogle</code></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'regex-target-text-sample.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    str = f.read()</span><br><span class="line"></span><br><span class="line">pttn = <span class="string">r'go+gle'</span></span><br><span class="line">re.findall(pttn, str)</span><br><span class="line"></span><br><span class="line">pttn = <span class="string">r'go&#123;2,5&#125;gle'</span></span><br><span class="line">re.findall(pttn, str)</span><br><span class="line"></span><br><span class="line">pttn = <span class="string">r'colou?red'</span></span><br><span class="line">re.findall(pttn, str)</span><br><span class="line"></span><br><span class="line">pttn = <span class="string">r'520*'</span></span><br><span class="line">re.findall(pttn, str)</span><br></pre></td></tr></table></figure>
<pre><code>[&apos;google&apos;, &apos;gooogle&apos;, &apos;goooogle&apos;, &apos;goooooogle&apos;]

[&apos;google&apos;, &apos;gooogle&apos;, &apos;goooogle&apos;]

[&apos;coloured&apos;, &apos;colored&apos;]

[&apos;520&apos;, &apos;52000&apos;, &apos;5200000&apos;, &apos;520000000&apos;, &apos;520000000000&apos;]
</code></pre><p>数量操作符是对它之前的原子进行操作的，换言之，数量操作符的操作元是操作符之前的原子。</p>
<p>上一节提到，要注意区别：<code>er</code>、<code>[er]</code> 和 <code>(er)</code> 各不相同。</p>
<blockquote>
<ul>
<li><code>er</code> 是两个原子，<code>&#39;e&#39;</code> 之后 <code>&#39;r&#39;</code></li>
<li><code>[er]</code> 是一个原子，或者 <code>&#39;e&#39;</code> 或者 <code>&#39;r&#39;</code>；</li>
<li><code>(er)</code> 是一个原子，<code>&#39;er&#39;</code></li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">str = <span class="string">'error wonderer severeness'</span></span><br><span class="line"></span><br><span class="line">pttn = <span class="string">r'er'</span></span><br><span class="line">re.findall(pttn, str)</span><br><span class="line"></span><br><span class="line">pttn = <span class="string">r'[er]'</span></span><br><span class="line">re.findall(pttn, str)</span><br><span class="line"></span><br><span class="line">pttn = <span class="string">r'(er)'</span></span><br><span class="line">re.findall(pttn, str)</span><br></pre></td></tr></table></figure>
<pre><code>[&apos;er&apos;, &apos;er&apos;, &apos;er&apos;, &apos;er&apos;]
[&apos;e&apos;, &apos;r&apos;, &apos;r&apos;, &apos;r&apos;, &apos;e&apos;, &apos;r&apos;, &apos;e&apos;, &apos;r&apos;, &apos;e&apos;, &apos;e&apos;, &apos;r&apos;, &apos;e&apos;, &apos;e&apos;]
[&apos;er&apos;, &apos;er&apos;, &apos;er&apos;, &apos;er&apos;]
</code></pre><p>在以上的例子中，看不出 <code>er</code> 和 <code>(er)</code> 的区别，但是，加上数量操作符就不一样了 —— 因为<em>数量操作符只对它之前的那一个原子进行操作</em>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">str = <span class="string">'error wonderer severeness'</span></span><br><span class="line"></span><br><span class="line">pttn = <span class="string">r'er+'</span></span><br><span class="line">re.findall(pttn, str)</span><br><span class="line"></span><br><span class="line">pttn = <span class="string">r'[er]+'</span></span><br><span class="line">re.findall(pttn, str)</span><br><span class="line"></span><br><span class="line">pttn = <span class="string">r'(er)+'</span></span><br><span class="line">re.findall(pttn, str)</span><br></pre></td></tr></table></figure>
<pre><code>[&apos;err&apos;, &apos;er&apos;, &apos;er&apos;, &apos;er&apos;]
[&apos;err&apos;, &apos;r&apos;, &apos;erer&apos;, &apos;e&apos;, &apos;ere&apos;, &apos;e&apos;]
[&apos;er&apos;, &apos;er&apos;, &apos;er&apos;]
</code></pre><h2 id="或操作符"><a href="#或操作符" class="headerlink" title="或操作符 |"></a>或操作符 <code>|</code></h2><p>或操作符 <code>|</code> 是所有操作符中优先级最低的，数量操作符的优先级比它高，所以，在 <code>|</code> 前后的原子被数量操作符（如果有的话）操作之后才交给 <code>|</code> 操作。</p>
<p>于是，<a href="https://regexper.com#begin%7Cbegan%7Cbegun" target="_blank" rel="noopener"><code>begin|began|begun</code></a> 能够匹配 <code>begin</code> 或 <code>began</code> 或 <code>begun</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">str = <span class="string">'begin began begun begins beginn'</span></span><br><span class="line">pttn = <span class="string">r'begin|began|begun'</span></span><br><span class="line">re.findall(pttn, str)</span><br></pre></td></tr></table></figure>
<pre><code>[&apos;begin&apos;, &apos;began&apos;, &apos;begun&apos;, &apos;begin&apos;, &apos;begin&apos;]
</code></pre><p>在集合原子中（即，<code>[]</code> 内的原子）各个原子之间的关系，只有 “或” —— 相当于方括号中的每个原子之间都有一个被省略的 <code>|</code>。</p>
<p><strong>注意</strong>：方括号的 <code>|</code> 不被当作特殊符号，而是被当作 <code>|</code> 这个符号本身。在方括号中的圆括号，也被当作圆括号 <code>()</code> 本身，而无分组含义。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">str = <span class="string">'achroiocythaemia achroiocythemia a|e'</span></span><br><span class="line">pttn = <span class="string">r'[a|ae]'</span></span><br><span class="line">re.findall(pttn, str)</span><br><span class="line"></span><br><span class="line">pttn = <span class="string">r'[a|e]'</span></span><br><span class="line">re.findall(pttn, str)</span><br><span class="line"></span><br><span class="line">pttn = <span class="string">r'[ae]'</span></span><br><span class="line">re.findall(pttn, str)</span><br><span class="line"></span><br><span class="line">pttn = <span class="string">r'[(ae)]'</span></span><br><span class="line">re.findall(pttn, str)</span><br><span class="line"></span><br><span class="line">pttn = <span class="string">r'[a|ae|(ae)]'</span></span><br><span class="line">re.findall(pttn, str)</span><br></pre></td></tr></table></figure>
<pre><code>[&apos;a&apos;, &apos;a&apos;, &apos;e&apos;, &apos;a&apos;, &apos;a&apos;, &apos;e&apos;, &apos;a&apos;, &apos;a&apos;, &apos;|&apos;, &apos;e&apos;]
</code></pre><h2 id="匹配并捕获"><a href="#匹配并捕获" class="headerlink" title="匹配并捕获"></a>匹配并捕获</h2><p>捕获（Capture），使用的是圆括号 <code>()</code>。使用圆括号得到的匹配的值被暂存成一个带有索引的列表，第一个是 <code>$1</code>，第二个是 <code>$2</code>…… 以此类推。随后，我们可以在替换的过程中使用 <code>$1</code> <code>$2</code> 中所保存的值。</p>
<p><strong>注意</strong>：在 Python 语言中调用 <code>re</code> 模块之后，在 <code>re.sub()</code> 中调用被匹配的值，用的索引方法是 <code>\1</code>、<code>\2</code>…… 以此类推。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">str = <span class="string">'The white dog wears a black hat.'</span></span><br><span class="line">pttn = <span class="string">r'The (white|black) dog wears a (white|black) hat.'</span></span><br><span class="line">re.findall(pttn, str)</span><br><span class="line"></span><br><span class="line">repl = <span class="string">r'The \2 dog wears a \1 hat.'</span></span><br><span class="line">re.sub(pttn, repl, str)</span><br><span class="line"></span><br><span class="line">repl = <span class="string">r'The \1 dog wears a \1 hat.'</span></span><br><span class="line">re.sub(pttn, repl, str)</span><br></pre></td></tr></table></figure>
<pre><code>[(&apos;white&apos;, &apos;black&apos;)]
&apos;The black dog wears a white hat.&apos;
&apos;The white dog wears a white hat.&apos;
</code></pre><h2 id="非捕获匹配"><a href="#非捕获匹配" class="headerlink" title="非捕获匹配"></a>非捕获匹配</h2><p>有时，你并不想捕获圆括号中的内容，在那个地方你使用括号的目的只是分组，而非捕获，那么，你就在圆括号内最开头加上 <code>?:</code> —— <code>(?:...)</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">str = <span class="string">'The white dog wears a black hat.'</span></span><br><span class="line">pttn = <span class="string">r'The (?:white|black) dog wears a (white|black) hat.'</span></span><br><span class="line">re.findall(pttn, str)                   <span class="comment"># 只捕获了一处，也就是说只有一个值将来可以被引用</span></span><br><span class="line"></span><br><span class="line">repl = <span class="string">r'The \1 dog wears a \1 hat.'</span>    <span class="comment"># 之前的一处捕获，在替换时可被多次引用</span></span><br><span class="line">書評</span><br><span class="line">re.sub(pttn, repl, str)</span><br></pre></td></tr></table></figure>
<pre><code>[&apos;black&apos;]

&apos;The black dog wears a black hat.&apos;
</code></pre><p>在 Python 代码中使用正则表达式，匹配和捕获以及随后的替换，有更灵活的方式，因为可以对那些值直接编程。<code>re.sub()</code> 中，<code>repl</code> 参数甚至可以接收另外一个函数作为参数 —— 以后你肯定会自行认真阅读以下页面中的所有内容：</p>
<blockquote>
<p><a href="https://docs.python.org/3/library/re.html" target="_blank" rel="noopener">https://docs.python.org/3/library/re.html</a></p>
</blockquote>
<p>非捕获匹配，还有若干个操作符：</p>
<p> <code>(?=pattern)</code></p>
<blockquote>
<p>正向肯定预查（look ahead positive assert），在任何匹配规则的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，<a href="https://regexper.com#%60Windows(?=95%7C98%7CNT%7C2000" target="_blank" rel="noopener"><code>Windows(?=95|98|NT|2000)</code></a>%60)<br>能匹配 <code>Windows2000</code> 中的 <code>Windows</code>，但不能匹配 <code>Windows3.1</code> 中的 <code>Windows</code>。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</p>
</blockquote>
<p><code>(?!pattern)</code></p>
<blockquote>
<p>正向否定预查（negative assert），在任何不匹配规则的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如<a href="https://regexper.com#Windows(?=95%7C98%7CNT%7C2000" target="_blank" rel="noopener"><code>Windows(?!95|98|NT|2000)</code></a>)<br>能匹配 <code>Windows3.1</code> 中的 <code>Windows</code>，但不能匹配 <code>Windows2000</code> 中的 <code>Windows</code>。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</p>
</blockquote>
<p><code>(?&lt;=pattern)</code></p>
<blockquote>
<p>反向（look behind）肯定预查，与正向肯定预查类似，只是方向相反。例如，<a href="https://regexper.com#(?%3C=95%7C98%7CNT%7C2000" target="_blank" rel="noopener"><code>(?&lt;=95|98|NT|2000)Windows</code></a>Windows)<br>能匹配 <code>2000Windows</code> 中的 <code>Windows</code>，但不能匹配 <code>3.1Windows</code> 中的 <code>Windows</code>。</p>
</blockquote>
<p> <code>(?&lt;!pattern)</code></p>
<blockquote>
<p>反向否定预查，与正向否定预查类似，只是方向相反。例如 <code>(?&lt;!95|98|NT|2000)Windows</code><br>能匹配 <code>3.1Windows</code> 中的 <code>Windows</code>，但不能匹配 <code>2000Windows</code> 中的 <code>Windows</code>。</p>
</blockquote>
<h2 id="控制标记"><a href="#控制标记" class="headerlink" title="控制标记"></a>控制标记</h2><p>有几个全局控制标记（Flag）需要了解，其中最常默认指定的有 <code>G</code> 和 <code>M</code>：</p>
<p><code>A</code>/<code>ASCII</code>，默认为 <code>False</code></p>
<blockquote>
<ul>
<li><code>\d</code>, <code>\D</code>, <code>\w</code>, <code>\W</code>, <code>\s</code>, <code>\S</code>, <code>\b</code>, 和 <code>\B</code> 等只限于 ASCII 字符</li>
<li>行内写法：<code>(?a)</code></li>
<li>Python re 模块中的常量：<code>re.A</code> <code>re.ASCII</code></li>
</ul>
</blockquote>
<p><code>I</code>/<code>IGNORECASE</code>，默认为 <code>False</code></p>
<blockquote>
<ul>
<li>忽略字母大小写</li>
<li>行内写法：<code>(?i)</code></li>
<li>Python re 模块中的常量：<code>re.I</code> <code>re.IGNORECASE</code></li>
</ul>
</blockquote>
<p><code>G</code>/<code>GLOBAL</code>，默认为 <code>True</code></p>
<blockquote>
<ul>
<li>找到第一个 match 之后不返回</li>
<li>行内写法：<code>(?g)</code></li>
<li>Python re 模块中这个标记不能更改，默认为 TRUE</li>
</ul>
</blockquote>
<p><code>L</code>/<code>LOCALE</code>，默认为 <code>False</code></p>
<blockquote>
<ul>
<li>由本地语言设置决定 <code>\d</code>, <code>\D</code>, <code>\w</code>, <code>\W</code>, <code>\s</code>, <code>\S</code>, <code>\b</code>, 和 <code>\B</code> 等等的内容</li>
<li>行内写法：<code>(?L)</code></li>
<li>Python re 模块中的常量：<code>re.L</code> <code>re.LOCALE</code></li>
</ul>
</blockquote>
<p><code>M</code>/<code>MULTILINE</code>，默认为 <code>True</code></p>
<blockquote>
<ul>
<li>使用本标志后，<code>^</code> 和 <code>$</code> 匹配行首和行尾时，会增加换行符之前和之后的位置。</li>
<li>行内写法：<code>(?m)</code></li>
<li>Python re 模块中的常量：<code>re.M</code> <code>re.MULTILINE</code></li>
</ul>
</blockquote>
<p><code>S</code>/<code>DOTALL</code>，默认为 <code>False</code></p>
<blockquote>
<ul>
<li>使 <code>.</code> 完全匹配任何字符，包括换行；没有这个标志，<code>.</code> 匹配除了 <code>n</code> <code>r</code> 之外的任何字符。</li>
<li>行内写法：<code>(?s)</code></li>
<li>Python re 模块中的常量：<code>re.S</code> <code>re.DOTALL</code></li>
</ul>
</blockquote>
<p><code>X</code>/<code>VERBOSE</code>，默认为 <code>False</code></p>
<blockquote>
<ul>
<li>当该标志被指定时，Pattern 中的的空白符会被忽略，除非该空白符在圆括号或方括号中，或在反斜杠 <code>\</code> 之后。这样做的结果是允许将注释写入 Pattern，这些注释会被 Regex 解析引擎忽略。注释用 <code>#</code> 号来标识，不过该符号不能在字符串或反斜杠之后。</li>
<li>行内写法：<code>(?x)</code></li>
<li>Python re 模块中的常量：<code>re.X</code> <code>re.VERBOSE</code></li>
</ul>
</blockquote>
<h2 id="几个最常用的-Regex"><a href="#几个最常用的-Regex" class="headerlink" title="几个最常用的 Regex"></a>几个最常用的 Regex</h2><p>以下是几个常用的 Regex<a href="#fn2" name="fn2b"><sup>[2]</sup></a>，值得保存：</p>
<ul>
<li><p>matching username</p>
<blockquote>
<p><a href="https://regexper.com#/%5E[a-z0-9_-]%7B3,16%7D$/" target="_blank" rel="noopener"><code>/^[a-z0-9_-]{3,16}$/</code></a></p>
</blockquote>
</li>
<li><p>matching password<a href="#fn3" name="fn3b"><sup>[3]</sup></a></p>
<blockquote>
<p><a href="https://regexper.com#/%5E[a-z0-9_-]%7B6,18%7D$/" target="_blank" rel="noopener"><code>/^[a-z0-9_-]{6,18}$/</code></a></p>
</blockquote>
</li>
<li><p>matching a HEX value</p>
<blockquote>
<p><a href="https://regexper.com#/%5E#?([a-f0-9]%7B6%7D%7C[a-f0-9]%7B3%7D" target="_blank" rel="noopener"><code>/^#?([a-f0-9]{6}|[a-f0-9]{3})$/</code></a>$/)</p>
</blockquote>
</li>
<li><p>matching a slug</p>
<blockquote>
<p><a href="https://regexper.com#/%5E[a-z0-9-]+$/" target="_blank" rel="noopener"><code>/^[a-z0-9-]+$/</code></a></p>
</blockquote>
</li>
<li><p>matching email address</p>
<blockquote>
<p><a href="https://regexper.com#/%5E([a-z0-9_%5C.-]+" target="_blank" rel="noopener"><code>/^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6})$/</code></a>@([%5Cda-z%5C.-]+)%5C.([a-z%5C.]%7B2,6%7D)$/)</p>
</blockquote>
</li>
<li><p>matching a URL</p>
<blockquote>
<p><a href="https://regexper.com#/%5E(https?:%5C/%5C/" target="_blank" rel="noopener"><code>/^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]{2,6})([\/\w \.-]*)*\/?$/</code></a>?([%5Cda-z%5C.-]+)%5C.([a-z%5C.]%7B2,6%7D)([%5C/%5Cw%20%5C.-]<em>)</em>%5C/?$/)</p>
</blockquote>
</li>
<li><p>matching an IP address</p>
<blockquote>
<p><a href="https://regexper.com/#%2F%5E%28%3F%3A%28%3F%3A25%5B0-5%5D%7C2%5B0-4%5D%5B0-9%5D%7C%5B01%5D%3F%5B0-9%5D%5B0-9%5D%3F%29%5C.%29%7B3%7D%28%3F%3A25%5B0-5%5D%7C2%5B0-4%5D%5B0-9%5D%7C%5B01%5D%3F%5B0-9%5D%5B0-9%5D%3F%29%24%2F" target="_blank" rel="noopener"><code>/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/</code></a></p>
</blockquote>
</li>
<li><p>matching a HTML tag</p>
<blockquote>
<p><a href="https://regexper.com/#%2F%5E&lt;%28%5Ba-z%5D%2B%29%28%5B%5E&lt;%5D%2B%29*%28%3F%3A&gt;%28.*%29&lt;%5C%2F%5C1&gt;%7C%5Cs%2B%5C%2F&gt;%29%24%2F" target="_blank" rel="noopener"><code>/^&lt;([a-z]+)([^&lt;]+)*(?:&gt;(.*)&lt;\/\1&gt;|\s+\/&gt;)$/</code></a></p>
</blockquote>
</li>
</ul>
<p>对了，告诉你一个小秘密：</p>
<blockquote>
<p>以上的正则表达式，点击都能连接到 <a href="https://regexper.com" target="_blank" rel="noopener">regexper.com</a>，在那里你能查看这些正则表达式的图形化示意图。另外，本文中，处于 markdown cell 的绝大多数正则表达式都有这样的连接…… 你可以重读的时候试试。</p>
</blockquote>
<p>写 Regex 最烧脑的地方在于 “使其全面” —— 要考虑到各种意外情况。</p>
<p>当然，除非必要，也不要在 “全面” 这事上面花太多时间 —— 给你看一个据说是 “最大程度上能够匹配所有 email 地址的 Regex” <a href="#fn4" name="fn4b"><sup>[4]</sup></a>，我都懒得测试的一个正则表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">(?:(?:\r\n)?[ \t])*(?:(?:(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t]</span><br><span class="line">)+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|&quot;(?:[^\&quot;\r\\]|\\.|(?:(?:\r\n)?[ \t]))*&quot;(?:(?:</span><br><span class="line">\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(</span><br><span class="line">?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|&quot;(?:[^\&quot;\r\\]|\\.|(?:(?:\r\n)?[</span><br><span class="line">\t]))*&quot;(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\0</span><br><span class="line">31]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|\[([^\[\]\r\\]|\\.)*\</span><br><span class="line">](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+</span><br><span class="line">(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:</span><br><span class="line">(?:\r\n)?[ \t])*))*|(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z</span><br><span class="line">|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|&quot;(?:[^\&quot;\r\\]|\\.|(?:(?:\r\n)?[ \t]))*&quot;(?:(?:\r\n)</span><br><span class="line">?[ \t])*)*\&lt;(?:(?:\r\n)?[ \t])*(?:@(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\</span><br><span class="line">r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[</span><br><span class="line"> \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)</span><br><span class="line">?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t]</span><br><span class="line">)*))*(?:,@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[</span><br><span class="line"> \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*</span><br><span class="line">)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t]</span><br><span class="line">)+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*)</span><br><span class="line">*:(?:(?:\r\n)?[ \t])*)?(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+</span><br><span class="line">|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|&quot;(?:[^\&quot;\r\\]|\\.|(?:(?:\r\n)?[ \t]))*&quot;(?:(?:\r</span><br><span class="line">\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:</span><br><span class="line">\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|&quot;(?:[^\&quot;\r\\]|\\.|(?:(?:\r\n)?[ \t</span><br><span class="line">]))*&quot;(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031</span><br><span class="line">]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|\[([^\[\]\r\\]|\\.)*\](</span><br><span class="line">?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?</span><br><span class="line">:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?</span><br><span class="line">:\r\n)?[ \t])*))*\&gt;(?:(?:\r\n)?[ \t])*)|(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?</span><br><span class="line">:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|&quot;(?:[^\&quot;\r\\]|\\.|(?:(?:\r\n)?</span><br><span class="line">[ \t]))*&quot;(?:(?:\r\n)?[ \t])*)*:(?:(?:\r\n)?[ \t])*(?:(?:(?:[^()&lt;&gt;@,;:\\&quot;.\[\]</span><br><span class="line">\000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|&quot;(?:[^\&quot;\r\\]|</span><br><span class="line">\\.|(?:(?:\r\n)?[ \t]))*&quot;(?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;</span><br><span class="line">@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|&quot;</span><br><span class="line">(?:[^\&quot;\r\\]|\\.|(?:(?:\r\n)?[ \t]))*&quot;(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t]</span><br><span class="line">)*(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\</span><br><span class="line">&quot;.\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?</span><br><span class="line">:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[</span><br><span class="line">\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*|(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-</span><br><span class="line">\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|&quot;(?:[^\&quot;\r\\]|\\.|(</span><br><span class="line">?:(?:\r\n)?[ \t]))*&quot;(?:(?:\r\n)?[ \t])*)*\&lt;(?:(?:\r\n)?[ \t])*(?:@(?:[^()&lt;&gt;@,;</span><br><span class="line">:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|\[([</span><br><span class="line">^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\&quot;</span><br><span class="line">.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|\[([^\[\</span><br><span class="line">]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*(?:,@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\&quot;.\</span><br><span class="line">[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|\[([^\[\]\</span><br><span class="line">r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\&quot;.\[\]</span><br><span class="line">\000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|\[([^\[\]\r\\]</span><br><span class="line">|\\.)*\](?:(?:\r\n)?[ \t])*))*)*:(?:(?:\r\n)?[ \t])*)?(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \0</span><br><span class="line">00-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|&quot;(?:[^\&quot;\r\\]|\\</span><br><span class="line">.|(?:(?:\r\n)?[ \t]))*&quot;(?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,</span><br><span class="line">;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|&quot;(?</span><br><span class="line">:[^\&quot;\r\\]|\\.|(?:(?:\r\n)?[ \t]))*&quot;(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t])*</span><br><span class="line">(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.</span><br><span class="line">\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[</span><br><span class="line">^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]</span><br><span class="line">]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*\&gt;(?:(?:\r\n)?[ \t])*)(?:,\s*(</span><br><span class="line">?:(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\</span><br><span class="line">&quot;.\[\]]))|&quot;(?:[^\&quot;\r\\]|\\.|(?:(?:\r\n)?[ \t]))*&quot;(?:(?:\r\n)?[ \t])*)(?:\.(?:(</span><br><span class="line">?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[</span><br><span class="line">\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|&quot;(?:[^\&quot;\r\\]|\\.|(?:(?:\r\n)?[ \t]))*&quot;(?:(?:\r\n)?[ \t</span><br><span class="line">])*))*@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t</span><br><span class="line">])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?</span><br><span class="line">:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|</span><br><span class="line">\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*|(?:</span><br><span class="line">[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\</span><br><span class="line">]]))|&quot;(?:[^\&quot;\r\\]|\\.|(?:(?:\r\n)?[ \t]))*&quot;(?:(?:\r\n)?[ \t])*)*\&lt;(?:(?:\r\n)</span><br><span class="line">?[ \t])*(?:@(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;</span><br><span class="line">()&lt;&gt;@,;:\\&quot;.\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)</span><br><span class="line">?[ \t])*(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;</span><br><span class="line">@,;:\\&quot;.\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*(?:,@(?:(?:\r\n)?[</span><br><span class="line"> \t])*(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,</span><br><span class="line">;:\\&quot;.\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t]</span><br><span class="line">)*(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\</span><br><span class="line">&quot;.\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*)*:(?:(?:\r\n)?[ \t])*)?</span><br><span class="line">(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.</span><br><span class="line">\[\]]))|&quot;(?:[^\&quot;\r\\]|\\.|(?:(?:\r\n)?[ \t]))*&quot;(?:(?:\r\n)?[ \t])*)(?:\.(?:(?:</span><br><span class="line">\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[</span><br><span class="line">&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|&quot;(?:[^\&quot;\r\\]|\\.|(?:(?:\r\n)?[ \t]))*&quot;(?:(?:\r\n)?[ \t])</span><br><span class="line">*))*@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])</span><br><span class="line">+|\Z|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\</span><br><span class="line">.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\&quot;.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z</span><br><span class="line">|(?=[\[&quot;()&lt;&gt;@,;:\\&quot;.\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*\&gt;(?:(</span><br><span class="line">?:\r\n)?[ \t])*))*)?;\s*)</span><br></pre></td></tr></table></figure>
<h2 id="趣事一则"><a href="#趣事一则" class="headerlink" title="趣事一则"></a>趣事一则</h2><p><a href="https://en.wikipedia.org/wiki/ELIZA" target="_blank" rel="noopener">ELIZA</a> 是人类史上第一个 “聊天机器人” 程序，上个世纪六十年代，1966 年实现的。核心就是使用正则表达式匹配对方语句中的关键词汇，再经过替换，形成看似有意义的 “回应” —— 事实上，ELIZA 完全不知道自己在说什么……</p>
<p>几年后，就是七十年代初，1972 年，另外一个聊天机器人 <a href="https://en.wikipedia.org/wiki/PARRY" target="_blank" rel="noopener">Parry</a> <a href="#fn5" name="fn5b"><sup>[5]</sup></a>被写了出来…… 随后第二年，这两个聊天机器人在 ARPANET “碰面” 好好地聊了一下<a href="#fn6" name="fn6b"><sup>[6]</sup></a>：</p>
<blockquote>
<p>ELIZA: Good Evening. Tell me your problems. Please terminate input with a period or a question mark.</p>
<p>PARRY: People get on my nerves sometimes.</p>
<p>ELIZA: I am not sure I understand you fully.</p>
<p>PARRY: You should pay more attention.</p>
<p>ELIZA: Suppose you should pay more attention.</p>
<p>PARRY: You’re entitled to your own opinion.</p>
<p>ELIZA: What makes you think I am entitled to my own opinion?</p>
<p>PARRY: It bothers me just to be around people in general.</p>
<p>ELIZA: Please go on.</p>
<p>PARRY: I went to the track at Bay Meadows a while back.</p>
<p>ELIZA: What does that suggest to you?</p>
<p>PARRY: I went to the races.</p>
<p>……</p>
</blockquote>
<p>以下是后人用 Python 重新实现的 ELIZA 的程序代码，你可以直接执行它，尝试一下与 ELIZA 聊聊天：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># %load https://raw.githubusercontent.com/jezhiggins/eliza.py/master/eliza.py</span></span><br><span class="line"><span class="comment">#----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#  eliza.py</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  a cheezy little Eliza knock-off by Joe Strout</span></span><br><span class="line"><span class="comment">#  with some updates by Jeff Epler</span></span><br><span class="line"><span class="comment">#  hacked into a module and updated by Jez Higgins</span></span><br><span class="line"><span class="comment">#----------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">eliza</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.keys = list(map(<span class="keyword">lambda</span> x:re.compile(x[<span class="number">0</span>], re.IGNORECASE),gPats))</span><br><span class="line">    self.values = list(map(<span class="keyword">lambda</span> x:x[<span class="number">1</span>],gPats))</span><br><span class="line"></span><br><span class="line">  <span class="comment">#----------------------------------------------------------------------</span></span><br><span class="line">  <span class="comment"># translate: take a string, replace any words found in dict.keys()</span></span><br><span class="line">  <span class="comment">#  with the corresponding dict.values()</span></span><br><span class="line">  <span class="comment">#----------------------------------------------------------------------</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">translate</span><span class="params">(self,str,dict)</span>:</span></span><br><span class="line">    words = str.lower().split()</span><br><span class="line">    keys = dict.keys();</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(words)):</span><br><span class="line">      <span class="keyword">if</span> words[i] <span class="keyword">in</span> keys:</span><br><span class="line">        words[i] = dict[words[i]]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">' '</span>.join(words)</span><br><span class="line"></span><br><span class="line">  <span class="comment">#----------------------------------------------------------------------</span></span><br><span class="line">  <span class="comment">#  respond: take a string, a set of regexps, and a corresponding</span></span><br><span class="line">  <span class="comment">#    set of response lists; find a match, and return a randomly</span></span><br><span class="line">  <span class="comment">#    chosen response from the corresponding list.</span></span><br><span class="line">  <span class="comment">#----------------------------------------------------------------------</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">respond</span><span class="params">(self,str)</span>:</span></span><br><span class="line">    <span class="comment"># find a match among keys</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(self.keys)):</span><br><span class="line">      match = self.keys[i].match(str)</span><br><span class="line">      <span class="keyword">if</span> match:</span><br><span class="line">        <span class="comment"># found a match ... stuff with corresponding value</span></span><br><span class="line">        <span class="comment"># chosen randomly from among the available options</span></span><br><span class="line">        resp = random.choice(self.values[i])</span><br><span class="line">        <span class="comment"># we've got a response... stuff in reflected text where indicated</span></span><br><span class="line">        pos = resp.find(<span class="string">'%'</span>)</span><br><span class="line">        <span class="keyword">while</span> pos &gt; <span class="number">-1</span>:</span><br><span class="line">          num = int(resp[pos+<span class="number">1</span>:pos+<span class="number">2</span>])</span><br><span class="line">          resp = resp[:pos] + \</span><br><span class="line">            self.translate(match.group(num),gReflections) + \</span><br><span class="line">            resp[pos+<span class="number">2</span>:]</span><br><span class="line">          pos = resp.find(<span class="string">'%'</span>)</span><br><span class="line">        <span class="comment"># fix munged punctuation at the end</span></span><br><span class="line">        <span class="keyword">if</span> resp[<span class="number">-2</span>:] == <span class="string">'?.'</span>: resp = resp[:<span class="number">-2</span>] + <span class="string">'.'</span></span><br><span class="line">        <span class="keyword">if</span> resp[<span class="number">-2</span>:] == <span class="string">'??'</span>: resp = resp[:<span class="number">-2</span>] + <span class="string">'?'</span></span><br><span class="line">        <span class="keyword">return</span> resp</span><br><span class="line"></span><br><span class="line"><span class="comment">#----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># gReflections, a translation table used to convert things you say</span></span><br><span class="line"><span class="comment">#    into things the computer says back, e.g. "I am" --&gt; "you are"</span></span><br><span class="line"><span class="comment">#----------------------------------------------------------------------</span></span><br><span class="line">gReflections = &#123;</span><br><span class="line">  <span class="string">"am"</span>   : <span class="string">"are"</span>,</span><br><span class="line">  <span class="string">"was"</span>  : <span class="string">"were"</span>,</span><br><span class="line">  <span class="string">"i"</span>    : <span class="string">"you"</span>,</span><br><span class="line">  <span class="string">"i'd"</span>  : <span class="string">"you would"</span>,</span><br><span class="line">  <span class="string">"i've"</span>  : <span class="string">"you have"</span>,</span><br><span class="line">  <span class="string">"i'll"</span>  : <span class="string">"you will"</span>,</span><br><span class="line">  <span class="string">"my"</span>  : <span class="string">"your"</span>,</span><br><span class="line">  <span class="string">"are"</span>  : <span class="string">"am"</span>,</span><br><span class="line">  <span class="string">"you've"</span>: <span class="string">"I have"</span>,</span><br><span class="line">  <span class="string">"you'll"</span>: <span class="string">"I will"</span>,</span><br><span class="line">  <span class="string">"your"</span>  : <span class="string">"my"</span>,</span><br><span class="line">  <span class="string">"yours"</span>  : <span class="string">"mine"</span>,</span><br><span class="line">  <span class="string">"you"</span>  : <span class="string">"me"</span>,</span><br><span class="line">  <span class="string">"me"</span>  : <span class="string">"you"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># gPats, the main response table.  Each element of the list is a</span></span><br><span class="line"><span class="comment">#  two-element list; the first is a regexp, and the second is a</span></span><br><span class="line"><span class="comment">#  list of possible responses, with group-macros labelled as</span></span><br><span class="line"><span class="comment">#  %1, %2, etc.</span></span><br><span class="line"><span class="comment">#----------------------------------------------------------------------</span></span><br><span class="line">gPats = [</span><br><span class="line">  [<span class="string">r'I need (.*)'</span>,</span><br><span class="line">  [  <span class="string">"Why do you need %1?"</span>,</span><br><span class="line">    <span class="string">"Would it really help you to get %1?"</span>,</span><br><span class="line">    <span class="string">"Are you sure you need %1?"</span>]],</span><br><span class="line"></span><br><span class="line">  [<span class="string">r'Why don\'?t you ([^\?]*)\??'</span>,</span><br><span class="line">  [  <span class="string">"Do you really think I don't %1?"</span>,</span><br><span class="line">    <span class="string">"Perhaps eventually I will %1."</span>,</span><br><span class="line">    <span class="string">"Do you really want me to %1?"</span>]],</span><br><span class="line"></span><br><span class="line">  [<span class="string">r'Why can\'?t I ([^\?]*)\??'</span>,</span><br><span class="line">  [  <span class="string">"Do you think you should be able to %1?"</span>,</span><br><span class="line">    <span class="string">"If you could %1, what would you do?"</span>,</span><br><span class="line">    <span class="string">"I don't know -- why can't you %1?"</span>,</span><br><span class="line">    <span class="string">"Have you really tried?"</span>]],</span><br><span class="line"></span><br><span class="line">  [<span class="string">r'I can\'?t (.*)'</span>,</span><br><span class="line">  [  <span class="string">"How do you know you can't %1?"</span>,</span><br><span class="line">    <span class="string">"Perhaps you could %1 if you tried."</span>,</span><br><span class="line">    <span class="string">"What would it take for you to %1?"</span>]],</span><br><span class="line"></span><br><span class="line">  [<span class="string">r'I am (.*)'</span>,</span><br><span class="line">  [  <span class="string">"Did you come to me because you are %1?"</span>,</span><br><span class="line">    <span class="string">"How long have you been %1?"</span>,</span><br><span class="line">    <span class="string">"How do you feel about being %1?"</span>]],</span><br><span class="line"></span><br><span class="line">  [<span class="string">r'I\'?m (.*)'</span>,</span><br><span class="line">  [  <span class="string">"How does being %1 make you feel?"</span>,</span><br><span class="line">    <span class="string">"Do you enjoy being %1?"</span>,</span><br><span class="line">    <span class="string">"Why do you tell me you're %1?"</span>,</span><br><span class="line">    <span class="string">"Why do you think you're %1?"</span>]],</span><br><span class="line"></span><br><span class="line">  [<span class="string">r'Are you ([^\?]*)\??'</span>,</span><br><span class="line">  [  <span class="string">"Why does it matter whether I am %1?"</span>,</span><br><span class="line">    <span class="string">"Would you prefer it if I were not %1?"</span>,</span><br><span class="line">    <span class="string">"Perhaps you believe I am %1."</span>,</span><br><span class="line">    <span class="string">"I may be %1 -- what do you think?"</span>]],</span><br><span class="line"></span><br><span class="line">  [<span class="string">r'What (.*)'</span>,</span><br><span class="line">  [  <span class="string">"Why do you ask?"</span>,</span><br><span class="line">    <span class="string">"How would an answer to that help you?"</span>,</span><br><span class="line">    <span class="string">"What do you think?"</span>]],</span><br><span class="line"></span><br><span class="line">  [<span class="string">r'How (.*)'</span>,</span><br><span class="line">  [  <span class="string">"How do you suppose?"</span>,</span><br><span class="line">    <span class="string">"Perhaps you can answer your own question."</span>,</span><br><span class="line">    <span class="string">"What is it you're really asking?"</span>]],</span><br><span class="line"></span><br><span class="line">  [<span class="string">r'Because (.*)'</span>,</span><br><span class="line">  [  <span class="string">"Is that the real reason?"</span>,</span><br><span class="line">    <span class="string">"What other reasons come to mind?"</span>,</span><br><span class="line">    <span class="string">"Does that reason apply to anything else?"</span>,</span><br><span class="line">    <span class="string">"If %1, what else must be true?"</span>]],</span><br><span class="line"></span><br><span class="line">  [<span class="string">r'(.*) sorry (.*)'</span>,</span><br><span class="line">  [  <span class="string">"There are many times when no apology is needed."</span>,</span><br><span class="line">    <span class="string">"What feelings do you have when you apologize?"</span>]],</span><br><span class="line"></span><br><span class="line">  [<span class="string">r'Hello(.*)'</span>,</span><br><span class="line">  [  <span class="string">"Hello... I'm glad you could drop by today."</span>,</span><br><span class="line">    <span class="string">"Hi there... how are you today?"</span>,</span><br><span class="line">    <span class="string">"Hello, how are you feeling today?"</span>]],</span><br><span class="line"></span><br><span class="line">  [<span class="string">r'I think (.*)'</span>,</span><br><span class="line">  [  <span class="string">"Do you doubt %1?"</span>,</span><br><span class="line">    <span class="string">"Do you really think so?"</span>,</span><br><span class="line">    <span class="string">"But you're not sure %1?"</span>]],</span><br><span class="line"></span><br><span class="line">  [<span class="string">r'(.*) friend (.*)'</span>,</span><br><span class="line">  [  <span class="string">"Tell me more about your friends."</span>,</span><br><span class="line">    <span class="string">"When you think of a friend, what comes to mind?"</span>,</span><br><span class="line">    <span class="string">"Why don't you tell me about a childhood friend?"</span>]],</span><br><span class="line"></span><br><span class="line">  [<span class="string">r'Yes'</span>,</span><br><span class="line">  [  <span class="string">"You seem quite sure."</span>,</span><br><span class="line">    <span class="string">"OK, but can you elaborate a bit?"</span>]],</span><br><span class="line"></span><br><span class="line">  [<span class="string">r'(.*) computer(.*)'</span>,</span><br><span class="line">  [  <span class="string">"Are you really talking about me?"</span>,</span><br><span class="line">    <span class="string">"Does it seem strange to talk to a computer?"</span>,</span><br><span class="line">    <span class="string">"How do computers make you feel?"</span>,</span><br><span class="line">    <span class="string">"Do you feel threatened by computers?"</span>]],</span><br><span class="line"></span><br><span class="line">  [<span class="string">r'Is it (.*)'</span>,</span><br><span class="line">  [  <span class="string">"Do you think it is %1?"</span>,</span><br><span class="line">    <span class="string">"Perhaps it's %1 -- what do you think?"</span>,</span><br><span class="line">    <span class="string">"If it were %1, what would you do?"</span>,</span><br><span class="line">    <span class="string">"It could well be that %1."</span>]],</span><br><span class="line"></span><br><span class="line">  [<span class="string">r'It is (.*)'</span>,</span><br><span class="line">  [  <span class="string">"You seem very certain."</span>,</span><br><span class="line">    <span class="string">"If I told you that it probably isn't %1, what would you feel?"</span>]],</span><br><span class="line"></span><br><span class="line">  [<span class="string">r'Can you ([^\?]*)\??'</span>,</span><br><span class="line">  [  <span class="string">"What makes you think I can't %1?"</span>,</span><br><span class="line">    <span class="string">"If I could %1, then what?"</span>,</span><br><span class="line">    <span class="string">"Why do you ask if I can %1?"</span>]],</span><br><span class="line"></span><br><span class="line">  [<span class="string">r'Can I ([^\?]*)\??'</span>,</span><br><span class="line">  [  <span class="string">"Perhaps you don't want to %1."</span>,</span><br><span class="line">    <span class="string">"Do you want to be able to %1?"</span>,</span><br><span class="line">    <span class="string">"If you could %1, would you?"</span>]],</span><br><span class="line"></span><br><span class="line">  [<span class="string">r'You are (.*)'</span>,</span><br><span class="line">  [  <span class="string">"Why do you think I am %1?"</span>,</span><br><span class="line">    <span class="string">"Does it please you to think that I'm %1?"</span>,</span><br><span class="line">    <span class="string">"Perhaps you would like me to be %1."</span>,</span><br><span class="line">    <span class="string">"Perhaps you're really talking about yourself?"</span>]],</span><br><span class="line"></span><br><span class="line">  [<span class="string">r'You\'?re (.*)'</span>,</span><br><span class="line">  [  <span class="string">"Why do you say I am %1?"</span>,</span><br><span class="line">    <span class="string">"Why do you think I am %1?"</span>,</span><br><span class="line">    <span class="string">"Are we talking about you, or me?"</span>]],</span><br><span class="line"></span><br><span class="line">  [<span class="string">r'I don\'?t (.*)'</span>,</span><br><span class="line">  [  <span class="string">"Don't you really %1?"</span>,</span><br><span class="line">    <span class="string">"Why don't you %1?"</span>,</span><br><span class="line">    <span class="string">"Do you want to %1?"</span>]],</span><br><span class="line"></span><br><span class="line">  [<span class="string">r'I feel (.*)'</span>,</span><br><span class="line">  [  <span class="string">"Good, tell me more about these feelings."</span>,</span><br><span class="line">    <span class="string">"Do you often feel %1?"</span>,</span><br><span class="line">    <span class="string">"When do you usually feel %1?"</span>,</span><br><span class="line">    <span class="string">"When you feel %1, what do you do?"</span>]],</span><br><span class="line"></span><br><span class="line">  [<span class="string">r'I have (.*)'</span>,</span><br><span class="line">  [  <span class="string">"Why do you tell me that you've %1?"</span>,</span><br><span class="line">    <span class="string">"Have you really %1?"</span>,</span><br><span class="line">    <span class="string">"Now that you have %1, what will you do next?"</span>]],</span><br><span class="line"></span><br><span class="line">  [<span class="string">r'I would (.*)'</span>,</span><br><span class="line">  [  <span class="string">"Could you explain why you would %1?"</span>,</span><br><span class="line">    <span class="string">"Why would you %1?"</span>,</span><br><span class="line">    <span class="string">"Who else knows that you would %1?"</span>]],</span><br><span class="line"></span><br><span class="line">  [<span class="string">r'Is there (.*)'</span>,</span><br><span class="line">  [  <span class="string">"Do you think there is %1?"</span>,</span><br><span class="line">    <span class="string">"It's likely that there is %1."</span>,</span><br><span class="line">    <span class="string">"Would you like there to be %1?"</span>]],</span><br><span class="line"></span><br><span class="line">  [<span class="string">r'My (.*)'</span>,</span><br><span class="line">  [  <span class="string">"I see, your %1."</span>,</span><br><span class="line">    <span class="string">"Why do you say that your %1?"</span>,</span><br><span class="line">    <span class="string">"When your %1, how do you feel?"</span>]],</span><br><span class="line"></span><br><span class="line">  [<span class="string">r'You (.*)'</span>,</span><br><span class="line">  [  <span class="string">"We should be discussing you, not me."</span>,</span><br><span class="line">    <span class="string">"Why do you say that about me?"</span>,</span><br><span class="line">    <span class="string">"Why do you care whether I %1?"</span>]],</span><br><span class="line"></span><br><span class="line">  [<span class="string">r'Why (.*)'</span>,</span><br><span class="line">  [  <span class="string">"Why don't you tell me the reason why %1?"</span>,</span><br><span class="line">    <span class="string">"Why do you think %1?"</span> ]],</span><br><span class="line"></span><br><span class="line">  [<span class="string">r'I want (.*)'</span>,</span><br><span class="line">  [  <span class="string">"What would it mean to you if you got %1?"</span>,</span><br><span class="line">    <span class="string">"Why do you want %1?"</span>,</span><br><span class="line">    <span class="string">"What would you do if you got %1?"</span>,</span><br><span class="line">    <span class="string">"If you got %1, then what would you do?"</span>]],</span><br><span class="line"></span><br><span class="line">  [<span class="string">r'(.*) mother(.*)'</span>,</span><br><span class="line">  [  <span class="string">"Tell me more about your mother."</span>,</span><br><span class="line">    <span class="string">"What was your relationship with your mother like?"</span>,</span><br><span class="line">    <span class="string">"How do you feel about your mother?"</span>,</span><br><span class="line">    <span class="string">"How does this relate to your feelings today?"</span>,</span><br><span class="line">    <span class="string">"Good family relations are important."</span>]],</span><br><span class="line"></span><br><span class="line">  [<span class="string">r'(.*) father(.*)'</span>,</span><br><span class="line">  [  <span class="string">"Tell me more about your father."</span>,</span><br><span class="line">    <span class="string">"How did your father make you feel?"</span>,</span><br><span class="line">    <span class="string">"How do you feel about your father?"</span>,</span><br><span class="line">    <span class="string">"Does your relationship with your father relate to your feelings today?"</span>,</span><br><span class="line">    <span class="string">"Do you have trouble showing affection with your family?"</span>]],</span><br><span class="line"></span><br><span class="line">  [<span class="string">r'(.*) child(.*)'</span>,</span><br><span class="line">  [  <span class="string">"Did you have close friends as a child?"</span>,</span><br><span class="line">    <span class="string">"What is your favorite childhood memory?"</span>,</span><br><span class="line">    <span class="string">"Do you remember any dreams or nightmares from childhood?"</span>,</span><br><span class="line">    <span class="string">"Did the other children sometimes tease you?"</span>,</span><br><span class="line">    <span class="string">"How do you think your childhood experiences relate to your feelings today?"</span>]],</span><br><span class="line"></span><br><span class="line">  [<span class="string">r'(.*)\?'</span>,</span><br><span class="line">  [  <span class="string">"Why do you ask that?"</span>,</span><br><span class="line">    <span class="string">"Please consider whether you can answer your own question."</span>,</span><br><span class="line">    <span class="string">"Perhaps the answer lies within yourself?"</span>,</span><br><span class="line">    <span class="string">"Why don't you tell me?"</span>]],</span><br><span class="line"></span><br><span class="line">  [<span class="string">r'quit'</span>,</span><br><span class="line">  [  <span class="string">"Thank you for talking with me."</span>,</span><br><span class="line">    <span class="string">"Good-bye."</span>,</span><br><span class="line">    <span class="string">"Thank you, that will be $150.  Have a good day!"</span>]],</span><br><span class="line"></span><br><span class="line">  [<span class="string">r'(.*)'</span>,</span><br><span class="line">  [  <span class="string">"Please tell me more."</span>,</span><br><span class="line">    <span class="string">"Let's change focus a bit... Tell me about your family."</span>,</span><br><span class="line">    <span class="string">"Can you elaborate on that?"</span>,</span><br><span class="line">    <span class="string">"Why do you say that %1?"</span>,</span><br><span class="line">    <span class="string">"I see."</span>,</span><br><span class="line">    <span class="string">"Very interesting."</span>,</span><br><span class="line">    <span class="string">"%1."</span>,</span><br><span class="line">    <span class="string">"I see.  And what does that tell you?"</span>,</span><br><span class="line">    <span class="string">"How does that make you feel?"</span>,</span><br><span class="line">    <span class="string">"How do you feel when you say that?"</span>]]</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line"><span class="comment">#----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#  command_interface</span></span><br><span class="line"><span class="comment">#----------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">command_interface</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'Therapist\n---------'</span>)</span><br><span class="line">  print(<span class="string">'Talk to the program by typing in plain English, using normal upper-'</span>)</span><br><span class="line">  print(<span class="string">'and lower-case letters and punctuation.  Enter "quit" when done.'</span>)</span><br><span class="line">  print(<span class="string">'='</span>*<span class="number">72</span>)</span><br><span class="line">  print(<span class="string">'Hello.  How are you feeling today?'</span>)</span><br><span class="line"></span><br><span class="line">  s = <span class="string">''</span></span><br><span class="line">  therapist = eliza();</span><br><span class="line">  <span class="keyword">while</span> s != <span class="string">'quit'</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      s = input(<span class="string">'&gt; '</span>)</span><br><span class="line">    <span class="keyword">except</span> EOFError:</span><br><span class="line">      s = <span class="string">'quit'</span></span><br><span class="line">    print(s)</span><br><span class="line">    <span class="keyword">while</span> s[<span class="number">-1</span>] <span class="keyword">in</span> <span class="string">'!.'</span>:</span><br><span class="line">      s = s[:<span class="number">-1</span>]</span><br><span class="line">    print(therapist.respond(s))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">  command_interface()</span><br></pre></td></tr></table></figure>
<pre><code>Therapist
---------
Talk to the program by typing in plain English, using normal upper-
and lower-case letters and punctuation.  Enter &quot;quit&quot; when done.
========================================================================
Hello.  How are you feeling today?
</code></pre><hr>
<p><strong>脚注</strong></p>
<p><a name="fn1">[1]</a>：释义摘自苹果电脑上系统内建的《牛津英汉双解辞典》</p>
<p><a href="#fn1b"><small>↑Back to Content↑</small></a></p>
<p><a name="fn2">[2]</a>：<a href="https://bit.ly/2tz8v9n" target="_blank" rel="noopener">8 Regular Expressions You Should Know</a> by Vasili</p>
<p><a href="#fn2b"><small>↑Back to Content↑</small></a></p>
<p><a name="fn3">[3]</a>：关于校验密码强度的正则表达式，往往需要设置更为复杂的规则，Stackoverflow 上的一则答复中有很好的示例：<a href="https://stackoverflow.com/a/21456918" target="_blank" rel="noopener">https://stackoverflow.com/a/21456918</a></p>
<p><a href="#fn3b"><small>↑Back to Content↑</small></a></p>
<p><a name="fn4">[4]</a>：<a href="http://www.ex-parrot.com/pdw/Mail-RFC822-Address.html" target="_blank" rel="noopener">http://www.ex-parrot.com/pdw/Mail-RFC822-Address.html</a></p>
<p><a href="#fn4b"><small>↑Back to Content↑</small></a></p>
<p><a name="fn5">[5]</a>：Parry 的源代码（用 Lisp 写的）在这里：<a href="http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/areas/classics/parry/" target="_blank" rel="noopener">http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/areas/classics/parry/</a></p>
<p><a href="#fn5b"><small>↑Back to Content↑</small></a></p>
<p><a name="fn6">[6]</a>：ELIZA 和 Parry 的完整聊天记录在这里：<a href="https://tools.ietf.org/html/rfc439" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc439</a></p>
<p><a href="#fn6b"><small>↑Back to Content↑</small></a></p>
<h1 id="BNF-以及-EBNF"><a href="#BNF-以及-EBNF" class="headerlink" title="BNF 以及 EBNF"></a>BNF 以及 EBNF</h1><p>通常情况下，你很少会在入门书籍里读到关于 Backus-Naur Form（BNF，巴科斯-诺尔范式）和 Extended Backus-Naur Form（EBNF）的话题 —— 它们都被普遍认为是 “非专业人士无需了解的话题”，隐含的另外一层含义是 “反正就算给他们讲他们也无论如何看不懂”……</p>
<p>然而，在我眼里，这事非讲不可 —— 这是这本 “书” 的设计目标决定的。</p>
<p>严格意义上来讲，在《自学是门手艺》中，以自学编程为例，我完全没必要自己动手耗时费力写那么多东西 —— 如果仅仅是为了让读者 “入门” 的话。编程入门书籍，或者 Python 编程入门书籍，都已经太多太多了，其中质量过硬的书籍也多得去了 —— 并且，如果你没有英文阅读障碍，那你就会发现网上有太多非常优质的免费教程…… 真的轮不到李笑来同学再写一次。</p>
<p>我写这本书的目标是：</p>
<blockquote>
<p>让读者从认知自学能力开始，通过自学编程作为第一个实践，逐步完整掌握自学能力，进而在随后漫长的人生中，需要什么就去学什么，</p>
</blockquote>
<p>…… 不用非得找人教、找人带 —— 只有这样，<strong>前途</strong>这两个字才会变得实在。</p>
<p>于是，我最希望能做到的是，从这里了解了自学方法论，也了解了编程以及 Python 编程的基础概念之后，《自学是门手艺》的读者能够<strong>自顾自地踏上征程，一路走下去</strong> —— 至于走到哪里，能走到哪里，不是我一个作者一厢情愿能够决定的，是吧？</p>
<p>当然，会自学的人运气一定不会差。</p>
<p>于是，这本 “书” 的核心目标之一，换个说法就是：</p>
<blockquote>
<p>我希望读者在读完《自学是门手艺》之后，有能力独立地去全面研读<a href="https://docs.python.org/3/" target="_blank" rel="noopener">官方文档</a> —— 甚至是各种编程语言、各种软件的相关的文档（包括它们的官方文档）。</p>
</blockquote>
<p>自学编程，很像独自一人冲入了一个丛林，里面什么动物都有…… 而且那个丛林很大很大，虽然丛林里有的地方很美，可若是没有地图和指南针，你就会迷失方向。</p>
<p>其实吧，地图也不是没有 —— 别说 Python 了，无论什么编程语言（包括无论什么软件）都有很翔实的官方文档…… 可是吧，绝大多数人无论买多少书、上多少课，就是不去用官方 “地图”，就不！</p>
<p>—— 其实倒不是说 “第三方地图” 更好，实际的原因很不好意思说出来：</p>
<blockquote>
<ul>
<li>这首先吧，觉得官方文档阅读量太大了……（嗯？那地图不是越详细越好吗？）</li>
<li>那还有吧…… 也不是没去看过，<strong>看不懂</strong>……（嗯…… 这对初学者倒是个问题！）</li>
</ul>
</blockquote>
<p>所以，我要认为这本 “书” 的最重要工作是：</p>
<blockquote>
<p>为读者解读清楚地图上的 “图例”，从此之后读者在任何需要的时候能够彻底读懂地图。</p>
</blockquote>
<p>在阅读官方文档的时候，很多人在 <a href="https://docs.python.org/3/tutorial/index.html" target="_blank" rel="noopener">The Python Tutorial</a> 上就已经觉得吃力了…… 如果到了 <a href="https://docs.python.org/3/library/index.html" target="_blank" rel="noopener">Standard Libraries</a> 和 <a href="https://docs.python.org/3/reference/index.html" target="_blank" rel="noopener">Language References</a> 的部分，就基本上完全放弃了，比如，以下这段摘自 <a href="https://docs.python.org/3/library/string.html" target="_blank" rel="noopener">string —— Common string operations</a>：</p>
<blockquote>
<p>Format Specification Mini-Language<br>…<br>The general form of a standard format specifier is:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">format_spec     ::=  [[fill]align][sign][#][0][width][grouping_option][.precision][type]</span><br><span class="line">fill            ::=  &lt;any character&gt;</span><br><span class="line">align           ::=  &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;=&quot; | &quot;^&quot;</span><br><span class="line">sign            ::=  &quot;+&quot; | &quot;-&quot; | &quot; &quot;</span><br><span class="line">width           ::=  digit+</span><br><span class="line">grouping_option ::=  &quot;_&quot; | &quot;,&quot;</span><br><span class="line">precision       ::=  digit+</span><br><span class="line">type            ::=  &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;E&quot; | &quot;f&quot; | &quot;F&quot; | &quot;g&quot; | &quot;G&quot; |</span><br><span class="line">                     &quot;n&quot; | &quot;o&quot; | &quot;s&quot; | &quot;x&quot; | &quot;X&quot; | &quot;%&quot;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>…</p>
</blockquote>
<p>读到这，看着一大堆的 <code>::=</code> <code>[]</code> <code>|</code> 当场傻眼了……</p>
<p>这是 BNF 描述，还是 Python 自己定制的 EBNF…… 为了理解它们，以后当然最好有空研究一下 “上下文无关文法”（<a href="https://en.wikipedia.org/wiki/Context-free_grammar" target="_blank" rel="noopener">Context-free Grammar</a>），没准未来你一高兴就会去玩一般人不敢玩的各种 Parser，甚至干脆自己写门编程语言啥的…… 不过，完全可以跳过那些复杂的东西的 —— 因为你当前的目标只不过是 “能够读懂那些符号的含义”。</p>
<p>其实吧，真的不难的 —— 它就是语法描述的方法。</p>
<p>比如，什么是符合语法的整数（Integer）呢？符合以下语法描述的是整数（使用 Python 的 EBNF）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">integer ::= [sign] digit +</span><br><span class="line">sign    ::= &quot;+&quot; | &quot;-&quot;</span><br><span class="line">digit   ::=  &quot;0&quot; | &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot; | &quot;5&quot; | &quot;6&quot; | &quot;7&quot; | &quot;8&quot; | &quot;9&quot;</span><br></pre></td></tr></table></figure>
<p>以上的描述中，基本符号没几个，它们各自的含义是：</p>
<blockquote>
<ul>
<li><code>::=</code> 表示定义；</li>
<li><code>&lt; &gt;</code> 尖括号里的内容表示必选内容；</li>
<li><code>[ ]</code> 中是可选项；</li>
<li><code>&quot; &quot;</code> 双引号里的内容表示字符；</li>
<li><code>|</code> 竖线两边的是可选内容，相当于or；</li>
<li><code>*</code> 表示零个或者多个……</li>
<li><code>+</code> 表示一个或者多个……</li>
</ul>
</blockquote>
<p>于是：</p>
<blockquote>
<ol>
<li><code>interger</code> 定义是：由 “可选的 <code>sign</code>” 和 “一个或者多个 <code>digit</code> 的集合” 构成 —— 第一行末尾那个 <code>+</code> 的作用和正则表达式里的 <code>+</code> 一样；</li>
<li><code>sign</code> 的定义是什么呢？要么是 <code>+</code> 要么是 <code>-；</code></li>
<li><code>digit</code> 的定义是什么呢？从 <code>&quot;0&quot;</code> 到 <code>&quot;9&quot;</code> 中的任何一个值……</li>
</ol>
</blockquote>
<p>于是，<code>99</code>、<code>+99</code>、<code>-99</code>，都是符合以上语法描述的 <code>integer</code>；但 <code>99+</code> 和 <code>99-</code> 肯定不符合以上语法描述的 <code>integer</code>。</p>
<p>很简单吧？反正就是在 <code>::=</code> 左边逐行列出一个语法构成的所有要素，而后在右边逐行逐一定义，直至全部要素定义完毕。</p>
<p>也许那些在此之前已经熟悉 BNF 范式的人会有点惊讶，“你怎么连 ‘<em>终结符</em>’ 和 ‘<em>非终结符</em>’ 这种最基本的概念都跳过了？” —— 是呀，即便不讲那俩概念也能把这事讲清楚到 “能马上开始用” 了的地步…… 这就是我经常说的，“人类有这个神奇的本领，擅长使用自己并不懂的东西……”</p>
<p>Python 对 BNF 的拓展，借鉴了正则表达式<a href="#fn1" name="fn1b"><sup>[1]</sup></a> —— 从最后两个符号的使用（<code>*</code> <code>+</code>）你可以看得出来。顺带说，这也是为什么这本 “书” 里非要讲其他入门书籍里不讲的正则表达式的原因之一。</p>
<p>又由于 Python 的社区文档是二十来年长期积累的，有时标注方法并不一致。比如，在描述 <a href="https://docs.python.org/3/reference/grammar.html" target="_blank" rel="noopener">Python Full Grammar specification</a> 的时候，他们用的语法标注符号体系就跟上面描述 String 的语法不一样了，是这样的：</p>
<blockquote>
<ul>
<li><code>:</code> 表示定义；</li>
<li><code>[ ]</code> 中是可选项；</li>
<li><code>&#39; &#39;</code> 引号里的内容表示字符；</li>
<li><code>|</code> 竖线两边的是可选内容，相当于or；</li>
<li><code>*</code> 表示零个或者多个……</li>
<li><code>+</code> 表示一个或者多个……</li>
</ul>
</blockquote>
<p>—— 用冒号 <code>:</code> 替代了 <code>::=</code>，用单引号 <code>&#39;&#39;</code> 替代了双引号 <code>&quot;&quot;</code>，而尖括号 <code>&lt;&gt;</code> 干脆不用了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Grammar for Python</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># NOTE WELL: You should also follow all the steps listed at</span></span><br><span class="line"><span class="comment"># https://devguide.python.org/grammar/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Start symbols for the grammar:</span></span><br><span class="line"><span class="comment">#       single_input is a single interactive statement;</span></span><br><span class="line"><span class="comment">#       file_input is a module or sequence of commands read from an input file;</span></span><br><span class="line"><span class="comment">#       eval_input is the input for the eval() functions.</span></span><br><span class="line"><span class="comment"># NB: compound_stmt in single_input is followed by extra NEWLINE!</span></span><br><span class="line">single_input: NEWLINE | simple_stmt | compound_stmt NEWLINE</span><br><span class="line">file_input: (NEWLINE | stmt)* ENDMARKER</span><br><span class="line">eval_input: testlist NEWLINE* ENDMARKER</span><br><span class="line"></span><br><span class="line">decorator: <span class="string">'@'</span> dotted_name [ <span class="string">'('</span> [arglist] <span class="string">')'</span> ] NEWLINE</span><br><span class="line">decorators: decorator+</span><br><span class="line">decorated: decorators (classdef | funcdef | async_funcdef)</span><br><span class="line"></span><br><span class="line">async_funcdef: <span class="string">'async'</span> funcdef</span><br><span class="line">funcdef: <span class="string">'def'</span> NAME parameters [<span class="string">'-&gt;'</span> test] <span class="string">':'</span> suite</span><br><span class="line"></span><br><span class="line">parameters: <span class="string">'('</span> [typedargslist] <span class="string">')'</span></span><br><span class="line">typedargslist: (tfpdef [<span class="string">'='</span> test] (<span class="string">','</span> tfpdef [<span class="string">'='</span> test])* [<span class="string">','</span> [</span><br><span class="line">        <span class="string">'*'</span> [tfpdef] (<span class="string">','</span> tfpdef [<span class="string">'='</span> test])* [<span class="string">','</span> [<span class="string">'**'</span> tfpdef [<span class="string">','</span>]]]</span><br><span class="line">      | <span class="string">'**'</span> tfpdef [<span class="string">','</span>]]]</span><br><span class="line">  | <span class="string">'*'</span> [tfpdef] (<span class="string">','</span> tfpdef [<span class="string">'='</span> test])* [<span class="string">','</span> [<span class="string">'**'</span> tfpdef [<span class="string">','</span>]]]</span><br><span class="line">  | <span class="string">'**'</span> tfpdef [<span class="string">','</span>])</span><br><span class="line">tfpdef: NAME [<span class="string">':'</span> test]</span><br><span class="line">varargslist: (vfpdef [<span class="string">'='</span> test] (<span class="string">','</span> vfpdef [<span class="string">'='</span> test])* [<span class="string">','</span> [</span><br><span class="line">        <span class="string">'*'</span> [vfpdef] (<span class="string">','</span> vfpdef [<span class="string">'='</span> test])* [<span class="string">','</span> [<span class="string">'**'</span> vfpdef [<span class="string">','</span>]]]</span><br><span class="line">      | <span class="string">'**'</span> vfpdef [<span class="string">','</span>]]]</span><br><span class="line">  | <span class="string">'*'</span> [vfpdef] (<span class="string">','</span> vfpdef [<span class="string">'='</span> test])* [<span class="string">','</span> [<span class="string">'**'</span> vfpdef [<span class="string">','</span>]]]</span><br><span class="line">  | <span class="string">'**'</span> vfpdef [<span class="string">','</span>]</span><br><span class="line">)</span><br><span class="line">vfpdef: NAME</span><br><span class="line"></span><br><span class="line">stmt: simple_stmt | compound_stmt</span><br><span class="line">simple_stmt: small_stmt (<span class="string">';'</span> small_stmt)* [<span class="string">';'</span>] NEWLINE</span><br><span class="line">small_stmt: (expr_stmt | del_stmt | pass_stmt | flow_stmt |</span><br><span class="line">             import_stmt | global_stmt | nonlocal_stmt | assert_stmt)</span><br><span class="line">expr_stmt: testlist_star_expr (annassign | augassign (yield_expr|testlist) |</span><br><span class="line">                     (<span class="string">'='</span> (yield_expr|testlist_star_expr))*)</span><br><span class="line">annassign: <span class="string">':'</span> test [<span class="string">'='</span> test]</span><br><span class="line">testlist_star_expr: (test|star_expr) (<span class="string">','</span> (test|star_expr))* [<span class="string">','</span>]</span><br><span class="line">augassign: (<span class="string">'+='</span> | <span class="string">'-='</span> | <span class="string">'*='</span> | <span class="string">'@='</span> | <span class="string">'/='</span> | <span class="string">'%='</span> | <span class="string">'&amp;='</span> | <span class="string">'|='</span> | <span class="string">'^='</span> |</span><br><span class="line">            <span class="string">'&lt;&lt;='</span> | <span class="string">'&gt;&gt;='</span> | <span class="string">'**='</span> | <span class="string">'//='</span>)</span><br><span class="line"><span class="comment"># For normal and annotated assignments, additional restrictions enforced by the interpreter</span></span><br><span class="line">del_stmt: <span class="string">'del'</span> exprlist</span><br><span class="line">pass_stmt: <span class="string">'pass'</span></span><br><span class="line">flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt | yield_stmt</span><br><span class="line">break_stmt: <span class="string">'break'</span></span><br><span class="line">continue_stmt: <span class="string">'continue'</span></span><br><span class="line">return_stmt: <span class="string">'return'</span> [testlist]</span><br><span class="line">yield_stmt: yield_expr</span><br><span class="line">raise_stmt: <span class="string">'raise'</span> [test [<span class="string">'from'</span> test]]</span><br><span class="line">import_stmt: import_name | import_from</span><br><span class="line">import_name: <span class="string">'import'</span> dotted_as_names</span><br><span class="line"><span class="comment"># note below: the ('.' | '...') is necessary because '...' is tokenized as ELLIPSIS</span></span><br><span class="line">import_from: (<span class="string">'from'</span> ((<span class="string">'.'</span> | <span class="string">'...'</span>)* dotted_name | (<span class="string">'.'</span> | <span class="string">'...'</span>)+)</span><br><span class="line">              <span class="string">'import'</span> (<span class="string">'*'</span> | <span class="string">'('</span> import_as_names <span class="string">')'</span> | import_as_names))</span><br><span class="line">import_as_name: NAME [<span class="string">'as'</span> NAME]</span><br><span class="line">dotted_as_name: dotted_name [<span class="string">'as'</span> NAME]</span><br><span class="line">import_as_names: import_as_name (<span class="string">','</span> import_as_name)* [<span class="string">','</span>]</span><br><span class="line">dotted_as_names: dotted_as_name (<span class="string">','</span> dotted_as_name)*</span><br><span class="line">dotted_name: NAME (<span class="string">'.'</span> NAME)*</span><br><span class="line">global_stmt: <span class="string">'global'</span> NAME (<span class="string">','</span> NAME)*</span><br><span class="line">nonlocal_stmt: <span class="string">'nonlocal'</span> NAME (<span class="string">','</span> NAME)*</span><br><span class="line">assert_stmt: <span class="string">'assert'</span> test [<span class="string">','</span> test]</span><br><span class="line"></span><br><span class="line">compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt | with_stmt | funcdef | classdef | decorated | async_stmt</span><br><span class="line">async_stmt: <span class="string">'async'</span> (funcdef | with_stmt | for_stmt)</span><br><span class="line">if_stmt: <span class="string">'if'</span> test <span class="string">':'</span> suite (<span class="string">'elif'</span> test <span class="string">':'</span> suite)* [<span class="string">'else'</span> <span class="string">':'</span> suite]</span><br><span class="line">while_stmt: <span class="string">'while'</span> test <span class="string">':'</span> suite [<span class="string">'else'</span> <span class="string">':'</span> suite]</span><br><span class="line">for_stmt: <span class="string">'for'</span> exprlist <span class="string">'in'</span> testlist <span class="string">':'</span> suite [<span class="string">'else'</span> <span class="string">':'</span> suite]</span><br><span class="line">try_stmt: (<span class="string">'try'</span> <span class="string">':'</span> suite</span><br><span class="line">           ((except_clause <span class="string">':'</span> suite)+</span><br><span class="line">            [<span class="string">'else'</span> <span class="string">':'</span> suite]</span><br><span class="line">            [<span class="string">'finally'</span> <span class="string">':'</span> suite] |</span><br><span class="line">           <span class="string">'finally'</span> <span class="string">':'</span> suite))</span><br><span class="line">with_stmt: <span class="string">'with'</span> with_item (<span class="string">','</span> with_item)*  <span class="string">':'</span> suite</span><br><span class="line">with_item: test [<span class="string">'as'</span> expr]</span><br><span class="line"><span class="comment"># NB compile.c makes sure that the default except clause is last</span></span><br><span class="line">except_clause: <span class="string">'except'</span> [test [<span class="string">'as'</span> NAME]]</span><br><span class="line">suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT</span><br><span class="line"></span><br><span class="line">test: or_test [<span class="string">'if'</span> or_test <span class="string">'else'</span> test] | lambdef</span><br><span class="line">test_nocond: or_test | lambdef_nocond</span><br><span class="line">lambdef: <span class="string">'lambda'</span> [varargslist] <span class="string">':'</span> test</span><br><span class="line">lambdef_nocond: <span class="string">'lambda'</span> [varargslist] <span class="string">':'</span> test_nocond</span><br><span class="line">or_test: and_test (<span class="string">'or'</span> and_test)*</span><br><span class="line">and_test: not_test (<span class="string">'and'</span> not_test)*</span><br><span class="line">not_test: <span class="string">'not'</span> not_test | comparison</span><br><span class="line">comparison: expr (comp_op expr)*</span><br><span class="line"><span class="comment"># &lt;&gt; isn't actually a valid comparison operator in Python. It's here for the</span></span><br><span class="line"><span class="comment"># sake of a __future__ import described in PEP 401 (which really works :-)</span></span><br><span class="line">comp_op: <span class="string">'&lt;'</span>|<span class="string">'&gt;'</span>|<span class="string">'=='</span>|<span class="string">'&gt;='</span>|<span class="string">'&lt;='</span>|<span class="string">'&lt;&gt;'</span>|<span class="string">'!='</span>|<span class="string">'in'</span>|<span class="string">'not'</span> <span class="string">'in'</span>|<span class="string">'is'</span>|<span class="string">'is'</span> <span class="string">'not'</span></span><br><span class="line">star_expr: <span class="string">'*'</span> expr</span><br><span class="line">expr: xor_expr (<span class="string">'|'</span> xor_expr)*</span><br><span class="line">xor_expr: and_expr (<span class="string">'^'</span> and_expr)*</span><br><span class="line">and_expr: shift_expr (<span class="string">'&amp;'</span> shift_expr)*</span><br><span class="line">shift_expr: arith_expr ((<span class="string">'&lt;&lt;'</span>|<span class="string">'&gt;&gt;'</span>) arith_expr)*</span><br><span class="line">arith_expr: term ((<span class="string">'+'</span>|<span class="string">'-'</span>) term)*</span><br><span class="line">term: factor ((<span class="string">'*'</span>|<span class="string">'@'</span>|<span class="string">'/'</span>|<span class="string">'%'</span>|<span class="string">'//'</span>) factor)*</span><br><span class="line">factor: (<span class="string">'+'</span>|<span class="string">'-'</span>|<span class="string">'~'</span>) factor | power</span><br><span class="line">power: atom_expr [<span class="string">'**'</span> factor]</span><br><span class="line">atom_expr: [<span class="string">'await'</span>] atom trailer*</span><br><span class="line">atom: (<span class="string">'('</span> [yield_expr|testlist_comp] <span class="string">')'</span> |</span><br><span class="line">       <span class="string">'['</span> [testlist_comp] <span class="string">']'</span> |</span><br><span class="line">       <span class="string">'&#123;'</span> [dictorsetmaker] <span class="string">'&#125;'</span> |</span><br><span class="line">       NAME | NUMBER | STRING+ | <span class="string">'...'</span> | <span class="string">'None'</span> | <span class="string">'True'</span> | <span class="string">'False'</span>)</span><br><span class="line">testlist_comp: (test|star_expr) ( comp_for | (<span class="string">','</span> (test|star_expr))* [<span class="string">','</span>] )</span><br><span class="line">trailer: <span class="string">'('</span> [arglist] <span class="string">')'</span> | <span class="string">'['</span> subscriptlist <span class="string">']'</span> | <span class="string">'.'</span> NAME</span><br><span class="line">subscriptlist: subscript (<span class="string">','</span> subscript)* [<span class="string">','</span>]</span><br><span class="line">subscript: test | [test] <span class="string">':'</span> [test] [sliceop]</span><br><span class="line">sliceop: <span class="string">':'</span> [test]</span><br><span class="line">exprlist: (expr|star_expr) (<span class="string">','</span> (expr|star_expr))* [<span class="string">','</span>]</span><br><span class="line">testlist: test (<span class="string">','</span> test)* [<span class="string">','</span>]</span><br><span class="line">dictorsetmaker: ( ((test <span class="string">':'</span> test | <span class="string">'**'</span> expr)</span><br><span class="line">                   (comp_for | (<span class="string">','</span> (test <span class="string">':'</span> test | <span class="string">'**'</span> expr))* [<span class="string">','</span>])) |</span><br><span class="line">                  ((test | star_expr)</span><br><span class="line">                   (comp_for | (<span class="string">','</span> (test | star_expr))* [<span class="string">','</span>])) )</span><br><span class="line"></span><br><span class="line">classdef: <span class="string">'class'</span> NAME [<span class="string">'('</span> [arglist] <span class="string">')'</span>] <span class="string">':'</span> suite</span><br><span class="line"></span><br><span class="line">arglist: argument (<span class="string">','</span> argument)*  [<span class="string">','</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># The reason that keywords are test nodes instead of NAME is that using NAME</span></span><br><span class="line"><span class="comment"># results in an ambiguity. ast.c makes sure it's a NAME.</span></span><br><span class="line"><span class="comment"># "test '=' test" is really "keyword '=' test", but we have no such token.</span></span><br><span class="line"><span class="comment"># These need to be in a single rule to avoid grammar that is ambiguous</span></span><br><span class="line"><span class="comment"># to our LL(1) parser. Even though 'test' includes '*expr' in star_expr,</span></span><br><span class="line"><span class="comment"># we explicitly match '*' here, too, to give it proper precedence.</span></span><br><span class="line"><span class="comment"># Illegal combinations and orderings are blocked in ast.c:</span></span><br><span class="line"><span class="comment"># multiple (test comp_for) arguments are blocked; keyword unpackings</span></span><br><span class="line"><span class="comment"># that precede iterable unpackings are blocked; etc.</span></span><br><span class="line">argument: ( test [comp_for] |</span><br><span class="line">            test <span class="string">'='</span> test |</span><br><span class="line">            <span class="string">'**'</span> test |</span><br><span class="line">            <span class="string">'*'</span> test )</span><br><span class="line"></span><br><span class="line">comp_iter: comp_for | comp_if</span><br><span class="line">sync_comp_for: <span class="string">'for'</span> exprlist <span class="string">'in'</span> or_test [comp_iter]</span><br><span class="line">comp_for: [<span class="string">'async'</span>] sync_comp_for</span><br><span class="line">comp_if: <span class="string">'if'</span> test_nocond [comp_iter]</span><br><span class="line"></span><br><span class="line"><span class="comment"># not used in grammar, but may appear in "node" passed from Parser to Compiler</span></span><br><span class="line">encoding_decl: NAME</span><br><span class="line"></span><br><span class="line">yield_expr: <span class="string">'yield'</span> [yield_arg]</span><br><span class="line">yield_arg: <span class="string">'from'</span> test | testlist</span><br></pre></td></tr></table></figure>
<p>现在你已经能读懂 BNF 了，那么，可以再读读用 BNF 描述的 Regex 语法<a href="#fn2" name="fn2b"><sup>[2]</sup></a>，就当复习了 —— 很短的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">BNF grammar for Perl-style regular expressions</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">RE</span>&gt;</span>             ::=  <span class="tag">&lt;<span class="name">union</span>&gt;</span> | <span class="tag">&lt;<span class="name">simple-RE</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">union</span>&gt;</span>          ::=  <span class="tag">&lt;<span class="name">RE</span>&gt;</span> "|" <span class="tag">&lt;<span class="name">simple-RE</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">simple-RE</span>&gt;</span>      ::=  <span class="tag">&lt;<span class="name">concatenation</span>&gt;</span> | <span class="tag">&lt;<span class="name">basic-RE</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">concatenation</span>&gt;</span>  ::=  <span class="tag">&lt;<span class="name">simple-RE</span>&gt;</span> <span class="tag">&lt;<span class="name">basic-RE</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">basic-RE</span>&gt;</span>       ::=  <span class="tag">&lt;<span class="name">star</span>&gt;</span> | <span class="tag">&lt;<span class="name">plus</span>&gt;</span> | <span class="tag">&lt;<span class="name">elementary-RE</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">star</span>&gt;</span>           ::=  <span class="tag">&lt;<span class="name">elementary-RE</span>&gt;</span> "*"</span><br><span class="line"><span class="tag">&lt;<span class="name">plus</span>&gt;</span>           ::=  <span class="tag">&lt;<span class="name">elementary-RE</span>&gt;</span> "+"</span><br><span class="line"><span class="tag">&lt;<span class="name">elementary-RE</span>&gt;</span>  ::=  <span class="tag">&lt;<span class="name">group</span>&gt;</span> | <span class="tag">&lt;<span class="name">any</span>&gt;</span> | <span class="tag">&lt;<span class="name">eos</span>&gt;</span> | <span class="tag">&lt;<span class="name">char</span>&gt;</span> | <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">group</span>&gt;</span>          ::=  "(" <span class="tag">&lt;<span class="name">RE</span>&gt;</span> ")"</span><br><span class="line"><span class="tag">&lt;<span class="name">any</span>&gt;</span>            ::=  "."</span><br><span class="line"><span class="tag">&lt;<span class="name">eos</span>&gt;</span>            ::=  "$"</span><br><span class="line"><span class="tag">&lt;<span class="name">char</span>&gt;</span>           ::=  any non metacharacter | "\" metacharacter</span><br><span class="line"><span class="tag">&lt;<span class="name">set</span>&gt;</span>            ::=  <span class="tag">&lt;<span class="name">positive-set</span>&gt;</span> | <span class="tag">&lt;<span class="name">negative-set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">positive-set</span>&gt;</span>   ::=  "[" <span class="tag">&lt;<span class="name">set-items</span>&gt;</span> "]"</span><br><span class="line"><span class="tag">&lt;<span class="name">negative-set</span>&gt;</span>   ::=  "[^" <span class="tag">&lt;<span class="name">set-items</span>&gt;</span> "]"</span><br><span class="line"><span class="tag">&lt;<span class="name">set-items</span>&gt;</span>      ::=  <span class="tag">&lt;<span class="name">set-item</span>&gt;</span> | <span class="tag">&lt;<span class="name">set-item</span>&gt;</span> <span class="tag">&lt;<span class="name">set-items</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set-item</span>&gt;</span>       ::=  <span class="tag">&lt;<span class="name">range</span>&gt;</span> | <span class="tag">&lt;<span class="name">char</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">range</span>&gt;</span>          ::=  <span class="tag">&lt;<span class="name">char</span>&gt;</span> "-" <span class="tag">&lt;<span class="name">char</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>真的没原来以为得那么神秘，是不？<a href="#fn3" name="fn3b"><sup>[3]</sup></a></p>
<p>都学到这儿了…… 顺带再自学个东西吧。</p>
<p>这个东西叫 <code>glob</code>，是 Global 的缩写。你可以把它理解为 “超级简化版正则表达式” —— 它最初是 Unix/Posix 操作系统中用来匹配文件名的 “通配符”。</p>
<p>先看一张 1971 的 Unix 操作系统中关于 glob 的截图：<br><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/Unix_Glob_Reference.png?raw=true" alt></p>
<blockquote>
<p>A screenshot of the original 1971 Unix reference page for glob – note the owner is dmr, short for Dennis Ritchie.</p>
</blockquote>
<p>glob 的主要符号只有这么几个：</p>
<blockquote>
<ul>
<li><code>*</code></li>
<li><code>?</code></li>
<li><code>[abc]</code></li>
<li><code>[^abc]</code></li>
</ul>
</blockquote>
<p>现在的你，打开 Wikipedia 上的关于 glob 和 Wildcard character 的页面，肯定能做到 “无障碍” 理解：</p>
<blockquote>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Glob_(programming)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Glob_(programming)</a></li>
<li><a href="https://en.wikipedia.org/wiki/Wildcard_character" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Wildcard_character</a></li>
</ul>
</blockquote>
<p>顺带说，现在你再去读关于 Format String 的官方文档，就不会再觉得 “根本看不懂” 了，恰恰相反，你会觉得 “我怎么之前连这个都看不懂呢？”</p>
<blockquote>
<p><a href="https://docs.python.org/3/library/string.html#format-string-syntax" target="_blank" rel="noopener">https://docs.python.org/3/library/string.html#format-string-syntax</a></p>
</blockquote>
<p>在自学这件事上，失败者的死法看起来千变万化，但其实都是一样的…… 只不过是因为怕麻烦或者基础知识不够而不去读最重要的文档。</p>
<p>比如，学英语的时候死活不读语法书。其实英文语法书也没多难啊？再厚，不也是用来 “查” 的吗？不就是多记几个标记就可以读懂的吗？比如，词性标记，<code>v.</code>, <code>n.</code>, <code>adj.</code>, <code>adv.</code>, <code>prep.</code>… 不就是相当于地图上的图例吗？那语法书，和现在这里提到的官方文档，不都是 “自学者地图” 吗？</p>
<p>但就是这么一点点简单的东西，挡住了几乎所有人，真是可怕。</p>
<hr>
<p><strong>脚注</strong></p>
<p><a name="fn1">[1]</a>：<a href="https://docs.python.org/3/reference/introduction.html#notation" target="_blank" rel="noopener">The Python Language Reference » 1.2 Notation</a> —— 这个链接必须去看一看……</p>
<p><a href="#fn1b"><small>↑Back to Content↑</small></a></p>
<p><a name="fn2">[2]</a>：<a href="http://www.cs.sfu.ca/~cameron/Teaching/384/99-3/regexp-plg.html" target="_blank" rel="noopener">Perl Style Regular Expressions in Prolog</a> CMPT 384 Lecture Notes<br>Robert D. Cameron November 29 - December 1, 1999</p>
<p><a href="#fn2b"><small>↑Back to Content↑</small></a></p>
<p><a name="fn3">[3]</a>：很少有人注意到：在很多编程语言的文法文档中，<code>&quot;$&quot;</code> 被称为 <code>&lt;eos&gt;</code> —— 2017 年 5 月我投资了一个初创公司，听说他们的资产名称叫做 <code>eos</code>…… 我当场就被这个梗逗乐了。</p>
<p><a href="#fn3b"><small>↑Back to Content↑</small></a></p>
<h1 id="拆解"><a href="#拆解" class="headerlink" title="拆解"></a>拆解</h1><p>在学习编程的过程中，你会不由自主地学会一个重要技能：</p>
<blockquote>
<p><strong>拆解</strong></p>
</blockquote>
<p>这么简单的两个字，在人生中的作用重大到不可想像…… 而且它也的确是自学能力中最重要的底层能力之一。</p>
<h2 id="横向拆解"><a href="#横向拆解" class="headerlink" title="横向拆解"></a>横向拆解</h2><p>我很幸运，12 岁的时候有机会学习编程（习得了最基本的概念，那时候学的编程语言是 BASIC），所以，相对其他人在 “拆解任务” 方面有更强的初始意识。</p>
<p>后来，15 岁开始学着玩吉他的时候，发现道理其实是一样的。</p>
<p>有个曲子很难（当然也非常好听），曲名是 <a href="https://www.youtube.com/watch?v=OOsRMECWKAE" target="_blank" rel="noopener">Recrerdes Da La Alhambra</a> 阿罕布拉宫的回忆。你看看曲谱就知道它多难了：</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/guitar-tab.gif?raw=true" alt></p>
<p>那怎么办？怎么办？！—— 我的办法听起来看起来都很笨：</p>
<blockquote>
<ul>
<li>每次只弹一个小节；<ul>
<li>而且还是放慢速度弹，刚开始很慢很慢；</li>
<li>等熟悉了之后逐渐快起来，直到正常速度；</li>
</ul>
</li>
<li>再开始弹下一个小节；<ul>
<li>同样是放慢速度弹，刚开始很慢很慢；</li>
<li>等熟悉了之后逐渐快起来，直到正常速度；</li>
</ul>
</li>
<li>再把两个小节拼起来；<ul>
<li>有些小节拼起来相对容易，另外一些需要挣扎很久才顺畅；</li>
</ul>
</li>
</ul>
</blockquote>
<p>如此这般，最终就把这个很难的曲子弹出来了 —— 其实所有的初学者都是这么干的。</p>
<p>可以听听这个曲子放松一下（当然肯定不是我弹的哈哈）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> IFrame</span><br><span class="line"></span><br><span class="line">IFrame(<span class="string">'https://www.youtube.com/embed/OOsRMECWKAE?'</span>, width=<span class="string">'800'</span>, height=<span class="string">'450'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>&lt;iframe
    width=&quot;800&quot;
    height=&quot;450&quot;
    src=&quot;https://www.youtube.com/embed/OOsRMECWKAE?&quot;
    frameborder=&quot;0&quot;
    allowfullscreen
&gt;&lt;/iframe&gt;
</code></pre><p>提起这事，总是会不由自主地叹口气 —— 因为在这事上我运气太差，刚把这个曲子练完没多久，还没来得及找人显摆，就摔断了掌骨和指骨，给我的手指灵活性造成了不可修复的损伤，于是，后来只能用拨片玩玩吉他了……</p>
<p>话说回来，自学的一个重要技巧就是，</p>
<blockquote>
<p>把那些很难的任务无限拆分 —— 直至每个子任务都很小，小到都<strong>可操作</strong>为止。</p>
</blockquote>
<p>比如，正则表达式，这个你必须学会的东西，学会学好真的不那么容易。一切的技能都一样，没学会之前都是很难很难的，可学会之后用熟了，你就会 “发现” 那东西其实也没多难……</p>
<p>那刚开始的时候怎么办？你其实需要运用拆分的本领：</p>
<blockquote>
<ul>
<li>先囫囵吞枣至少读一遍教程；</li>
<li>给自己搭好测试的环境（或许在 Regex101.com 上，或许用一个编辑器，比如 VS Code）；</li>
<li>先不管什么意思，找一些 Regex 自己试试；</li>
<li>正式进入 “精度” 状态，每一小节每一小节地突破；</li>
<li>搞定一小节之后，就把它与之前的小节再反复翻两三遍；</li>
<li>把学习任务拆分成若干块，再重新逐个突破，比如，匹配，替换，在编辑器中使用，在 Python 代码中使用；</li>
<li>把各种操作符与特殊字符拆分成若干个组，而后，熟悉到牢记（而不用将来反复回来查询）；<br>……</li>
</ul>
</blockquote>
<p>事实上，当你习惯这么做了之后，就会 “发现” 一切的自学任务，其实都不是 “难”，不过是 “繁杂程度不一” 而已。</p>
<p>很多人最终自学失败，要么是不懂拆分任务，要么就仅仅是<strong>怕麻烦</strong>而已 —— 还是那句话，人活着就挺麻烦的……</p>
<h2 id="纵向拆解"><a href="#纵向拆解" class="headerlink" title="纵向拆解"></a>纵向拆解</h2><p>拆解的第一种方法是把某个任务拆分成若干个小任务，正如上面的讲解那样，我称它为 “横向拆解”。</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/decompose-x.png?raw=true" alt></p>
<p>另外一种方法，我称它为 “纵向拆解”（有时，我也会用 “分层拆解” 这个说法）。</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/decompose-y.png?raw=true" alt></p>
<p>这种方式在自学复杂的概念体系时特别管用。</p>
<p>编程这种东西，之所以刚开始觉得难学，是因为其中涉及的概念除了之前我们强调的 “<a href="Part.1.F.deal-with-forward-references">过早引用</a>” 之外，还有个特征：</p>
<blockquote>
<p>有的概念虽然并不同属一个层面，却常常纠缠在一起，没有明确的提示……</p>
</blockquote>
<p>比如，常量、变量、字符串、函数、文件等等的概念，其实并不是某个特定的编程语言的专有概念，它们是所有编程语言都会涉及到的概念，因为计算机处理的就是这些东西，而无论哪个编程语言最终都要通过计算机去处理这些东西。</p>
<p>又比如说，分支与循环，每个编程语言都有对应的语句，所以，分支循环在逻辑判断、流程管理这个层面，而分支循环的 “<strong>实现</strong>” 应该划分到另外一个层面中去；而每个语言实现分支循环语句的语法多少有点差异 —— 这些细节属于那个编程语言本身：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python 这么写：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaScript 这么写：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自学正则表达式的时候也如此。最基本的规则是属于 Regex 自己的；而后各种语言的实现各不相同，那是各个编程语言层面的；在各种编辑器中，除了基础的规则之外，也有它们自己的定制…… 看起来细节很多，但分层分类之后，就会变得很容易理解、很容易记住。</p>
<p>遇到 “面向对象编程” 也是如此。类、实例、对象、继承、多态…… 这些其实并不属于某一个编程语言，但它们也确实在几乎所有编程语言中被实现、被应用 —— 所谓的难，无非是因为属于两个层面甚至多个层面的概念被拧在一起教、学、练……</p>
<p>再比如说，在我把这个用编程当作习得自学能力的第一个 “实战项目” 之时，甚至要把 “读” 和 “写” 分成两个层面，先照顾 “读”，至于 “写”，要等到有了基本的 “读” 的能力之后再说；即便是到了 “写”，还要划分至少两个层面，首先是从 “简单的函数” 开始，而非上来就要写个 “大程序”…… 这种拆分层面的技能好像可以用在方方面面呢！</p>
<p>所以，要在自学的过程中，不停地想办法把它们从层面上区分开来 —— 不能总是把它们混在一块儿 “大锅烩”。</p>
<p>日常生活中，我们会遇到被评价为 “理解能力强” 的人，而另外那些不被如此评价的人就很不理解，很迷惑：</p>
<blockquote>
<p>我到底差在哪儿了，你不说我理解能力强？难道我的理解能力很差吗？</p>
</blockquote>
<p>当老师当久了，经常被这种现象震惊：</p>
<blockquote>
<p>原来很简单的东西竟然可能成为很多人一生的障碍。</p>
</blockquote>
<p>—— 并且，这话重复多少遍都不过分。</p>
<p>大多数人不太在意自己脑中的概念之间的关系，因为平日里这也不怎么耽误事。但一旦遇到复杂一点的知识体系，就完全搞不定了…… 而所谓知识体系的复杂，无非就是新的概念多一些，概念之间的关联更复杂一些…… 而概念之间的关联更复杂一些，无非是各个概念之间不仅只有一种联系，最后会形成网状连接……</p>
<p>—— 在《通往财富自由之路》那本书里，我几乎用了整本书的篇幅去讲解、厘清概念及其之间关系的重要性。</p>
<p>复杂吗？其实并不复杂 —— 在横向纵向分别逐步分清之后。</p>
<p>可问题在于，脑子里概念关联一团糟的人，自己并不觉得，甚至无法知道 —— 他们是那种<a href="Part.1.C.must.learn.sth.only.by.reading.md">跟你一块去看一场电影却能看到另外一部电影的人</a>。说他们理解能力差过分吗？他们不能理解被评价为理解能力差，难道不是很自然吗？</p>
<p>分清概念的方法是什么？其实也不难，就是不断拆解，不断主动整理。每次用图表整理那些概念的时候，就会发现比原来更清晰一些，多次整理，最终就谙熟于心了。</p>
<p>想要再举更恰当更惊人的例子很难，勉为其难再举个例子。</p>
<p>当我在 2011 年遇到比特币的时候，现在回头看，在当时的情况下，我平日里习惯对概念及其关联进行各种纵向横向的拆解这件事给我 “创造” 了巨大的好运。后来我在《<a href="https://github.com/xiaolai/INB-Principles/blob/master/Chinese.md" target="_blank" rel="noopener">INBlockchain 的开源区块链投资原则</a>》里提过这事：</p>
<blockquote>
<p>“比特币” 这个概念，可以有多重的理解 —— 这也是为什么人们感到迷惑，或者相互之间很难达成一致理解的根本原因。</p>
<p>首先，比特币是世界上第一个，也是迄今为止最成功的区块链应用。</p>
<p>其次，比特币是一家世界银行，只不过它不属于任何权威管辖，它是由一个去中心化网络构成的。</p>
<p>另外，这家叫做比特币的，去中心化的世界银行，发行了一个货币，恰好也叫 “比特币”。有些人更喜欢使用相对小心的说法，把这个货币指称为 BTC，而不是 “比特币”（Bitcoin）。</p>
<p>最后，即便在比特币横空出世的七年后（2017），也很少有人意识到比特币（或者 BTC）其实也可以被理解为这家叫做比特币的去中心化的世界银行的股票。</p>
</blockquote>
<p>—— 这无非就是把一个概念拆分成若干个层面再对每个层面准确理解而已。</p>
<p>但毫无疑问，这点靠很简单很简单的方法练就的理解能力，帮了我大忙。</p>
<h2 id="触类旁通"><a href="#触类旁通" class="headerlink" title="触类旁通"></a>触类旁通</h2><p>无论听起来多么简单的任务，落实成代码肯定没那么简单，没那么容易。</p>
<p>以后你会越来越清楚的：写程序的主要工作量，往往并非来自于在编辑器里敲代码那个阶段。</p>
<blockquote>
<p>更多的工作量，其实在于如何才能在脑子里把整个流程拆解清楚，考虑到各个方面……</p>
</blockquote>
<p>所以，编程，更多是拿着纸笔梳理细节的工作。一旦所有的细节都想明白了，落实成代码其实是飞快的 —— 越是工程量大的项目越是如此。</p>
<p>这个道理在哪里都是相同、相通的。不说编程，说写书，也是一样的。</p>
<p>随着时间的推移，你花在 “拆解” 上的时间会越来越多，因为所有大的工程，都可以被拆解成小工程 —— 于是，也为了做出大工程，拆解的工作首先是必须，其次是最耗时费力但最值得的。</p>
<p>我身边很多人，包括出版社的专业编辑，都慨叹过我的 “写书速度”。我猜，实际上把他们惊到甚至惊倒的，并不是他们以为的 “李笑来写书的速度”，而是 “李笑来打字的速度” 而已。</p>
<p>当我告诉他们我要写一本什么书了的时候，实际上，有个工作早就完成了：“系统梳理要写的那本书的所有细节”，剩下的只是落笔把那些东西写出来而已 —— 当然，我是敲出来，用我那几乎无以伦比的输入速度敲出来 —— 那当然 “显得” 很快了！</p>
<p>创业也好，投资也罢，还是一样的。因为我这个人脸皮厚，不怕人们笑话，所以我可以平静地说这事：</p>
<blockquote>
<p>我参与（或投资）过<strong>很多</strong>失败的创业项目……</p>
</blockquote>
<p>对所有复盘的结果，无一例外，根源都是当初立项的时候，很多重要细节还没搞清楚，甚至没想到要去搞清楚，就已经开始行动…… 于是，在成本不断积累的情况下，没完没了地处理各种 “意外”，没完没了地重新制定目标，没完没了地拖延，没完没了地 “重新启动”…… 直至开始苟延残喘，最后不了了之。</p>
<p>拆解得不够，就容易导致想不清楚，想错，想歪……</p>
<p>也许，有人可能会理直气壮地反问，“怎么可能从一开始就把所有情况都想清楚么！” 唉，是呀，以前我也是这么想的…… 直到吃了很多亏，很多很多亏，很多很多很大很大的亏，才 “发现” 且不得不痛下决心去接受：事先想不清楚的，就不要去做。</p>
<p>这是一种特殊、且重要、又极有价值的能力。现实生活中，后来我也见过若干有这种能力的高人，比如，你可以到网上搜一个人名，<a href="https://www.google.com/search?q=庄辰超" target="_blank" rel="noopener">庄辰超</a>，他就是我见过的能做到干什么事之前都能全都想清楚的真人活人之一。</p>
<p>自学的时候，拆解任务的重要性更是如此。</p>
<p>这本 “书” 的一个特点，就是把 “自学”（或者平日里称为 “学习”）这个流程，拆解为 “学”、“练”、“用”、后面还会讲到 “造” 总计四个环节来处理 —— 从内容编排本身就这么干，甚至，在开头相当一部分，就明确说明，“根本不指望你读过一遍就会了”，还反复提醒，“要重复读很多遍，虽然第一遍必须囫囵吞枣”……</p>
<p>对于初学者常面临的尴尬，我们也从一开始就提醒，编程语言，和你之前在学校里学的语文，本质上没什么区别，先学会读，而后在多读多读再多读的同时，开始练习写 —— 这才真的很自然。</p>
<p>即便是开始讲如何写，我们的做法也是从 “写函数” 开始，而不是 “来，让我们写个程序……” —— 这一点点看起来不起眼的差异，作用是很大的，因为从 “小而完整” 的东西开始做（任何事）非常重要。</p>
<p><a href="Part.3.F.social-selfteaching.md"> “小” 无所谓，“完整” 才是关键</a>。</p>
<h1 id="刚需幻觉"><a href="#刚需幻觉" class="headerlink" title="刚需幻觉"></a>刚需幻觉</h1><p>在前言之中，就举过一个例子，人们一不小心就把自己搭了进去…… 只不过因为没搞明白，道理就是道理，跟讲道理的老生其实全然没什么关系。</p>
<p>在自学中，耽误人的幻觉很多。比如，时间幻觉。人们总觉得自己时间不够了，所以学东西的时候总是很急…… 可实际上，练成一门手艺，到够用的地步，一两年足够；到很好的地步，三五年足够 —— 至于极好么，那是一辈子的事。结果呢，很多人瞎着急，乱 “省时间”，学啥都不全面，练啥都不足数足量，一晃三五年就过去，然后又开始焦虑，换个手艺再学学再试试…… 然后循环焦虑。</p>
<p>最坑人的幻觉，在我看来，就是刚需幻觉 —— 这又是我杜撰的一个词…… 听我慢慢讲。</p>
<h2 id="感觉总是最大的坑"><a href="#感觉总是最大的坑" class="headerlink" title="感觉总是最大的坑"></a>感觉总是最大的坑</h2><p>我的结论是：</p>
<blockquote>
<p>绝大多数人的自学能力，基本上都是被 “自己的感觉” 耽误掉的。</p>
</blockquote>
<p>即，原本每个人都有一定的自学能力，但最终，都被自己的感觉给干掉了，直至全然失去自学能力 —— 虽然其后也经常学习，但其后一生从事的全都是学习这个行为里最初级的模式：“模仿”。</p>
<p>为什么 “模仿” 是学习行为最初级的模式呢？</p>
<p>首先，模仿必须依赖模仿对象，受自己的视野所限。</p>
<p>其次，模仿只能处理表里如一的简单知识和技能；一旦遇到那些深层次的、表面上看不大出来的，模仿就无效了，即便是非要模仿、愣模仿，结果就只能是 “东施效颦”。</p>
<p>在《<a href="https://github.com/xiaolai/time-as-a-friend" target="_blank" rel="noopener">把时间当作朋友</a>》中，我就反复强调一件事：</p>
<blockquote>
<p>不要问学它有什么用，学就是了……</p>
</blockquote>
<p>这原本是自学的最佳策略之一，也是自学的最根本策略。然而，听进去这句话的人不多，即便是我举了无数的例子，即便是他可能当时也有一点认同…… 然而，转瞬间又变成了原来的状态，无论遇到什么自学机会都不由自主地问：</p>
<blockquote>
<p>我学它有什么用啊？</p>
</blockquote>
<p>如果，得到的答案中，那 “用处” 对自己不是 “刚需”，瞬间就失去了动力，瞬间就放弃了追求…… 直至某一天，突然 “发现” 那竟然是个刚需…… 于是，临时抱佛脚。人么，总是对追求的事情形影相随；又有谁会对曾经放弃的事情念念不忘呢？于是，下一次还是会再做 “预算不足” 的决定。</p>
<p>最终失去自学能力的人，都是因为对 “刚需” 的判断失误 —— 这就是我说的 “刚需幻觉”。</p>
<h2 id="刚需幻觉-1"><a href="#刚需幻觉-1" class="headerlink" title="刚需幻觉"></a>刚需幻觉</h2><p>“刚需幻觉” 的根源在于：</p>
<blockquote>
<p>你不会的东西，对你来说感觉上就不是刚需。</p>
</blockquote>
<p>要不是这本 “书” 里有个自学编程那么大且立体的一个例子存在，供我反复地、多角度地阐述道理，上面这句话还真的不好解释 —— 即便解释清楚了，也因为缺乏生动的例证而失去效力。</p>
<p>正则表达式（Regex）就是很好的例子。</p>
<p>当你没有学会它的时候，甚至不知道它的时候，感觉上，你不可能觉得那是个刚需 —— 因为你一直都活得好好的，甚至在你全然不知道那个东西竟然存在的情况下。</p>
<p>你略微学了一下，没学会、没学好、或者干脆放弃了之后，在感觉上，你也同样不会觉得那是刚需。因为你不会用它，所以你当然 “用不上它”…… 你根本没办法知道你不懂正则表达式这个事实让你 “未得到” 什么（不是 “失去”，因为你不曾拥有）。</p>
<p>然而，只要你花了一点力气，真的掌握了它，你会有两个 “发现”：</p>
<blockquote>
<ul>
<li>你根本离不开它<a href="#fn1" name="fn1b"><sup>[1]</sup></a>；</li>
<li>它其实真没多难……</li>
</ul>
</blockquote>
<p>第二个 “发现” 总是让你无比庆幸 —— 幸亏学了，幸亏 “发现” 了，否则，自己耽误自己一辈子且完全不自知。庆幸！庆幸！！但第一个 “发现” 更为重要，因为但凡哪怕只有过一次这样的经历，你就可以永久摆脱 “刚需幻觉” 的诅咒。</p>
<p>编程也是一样的，当你开始学编程的时候，被身边的人发现，他们中的大多数一定会问你：</p>
<blockquote>
<p>你学它要干嘛啊？</p>
</blockquote>
<p>无论你怎么回答，他们的反应应该都是差不多的：反正就是不理解你的投入是否合理。</p>
<p>然后，等你学会了编程，掌握了这个技能，你的 “发现” 肯定包括那两点：</p>
<blockquote>
<ul>
<li>你根本离不开它；</li>
<li>它其实真没多难……</li>
</ul>
</blockquote>
<p>哪怕很简单的技能都是如此。许多年前，我专门花一两周的时间练习键盘盲打，以及把输入法方案选择改为微软双拼方案…… 也有人揶揄过我：“我靠，你练这玩意干嘛？难道将来要当一辈子打字员？”</p>
<p>当然，我很早就练就了一定的自学能力，所以很早就有一些自学经验，所以我用不着事后 “发现”，而是 “直接就知道”，将来：</p>
<blockquote>
<ul>
<li>我根本离不开它；</li>
<li>它其实真没多难……</li>
</ul>
</blockquote>
<p>事实上呢？事实上就是如此。打字速度极快，直接导致了后来我成为多产作家。无法想象如果我是个打字速度极慢的人，我如何写书，如何写那么多书和那么多文章；以及，后来我又是如何于 2018 年 9 月的某一天开始在 72 小时之内完成《韭菜的自我修养》初稿…… 可问题在于，这个技能难吗？在我长大的年代里，它算个技能；在今天，全都是从小就用键盘的人的世界里，谁不会呢？</p>
<p>所以，当面对一项新技能的时候，“觉得并非刚需” 肯定是幻觉。因为一个技能到底是不是刚需，在掌握它之前是不知道的……</p>
<blockquote>
<p>只有真正掌握了那个技能之后，那个技能才会 “变” 成刚需。</p>
</blockquote>
<p>并且，</p>
<blockquote>
<p>一旦掌握了某项技能，它只能是刚需。</p>
</blockquote>
<p>这种幻觉非常坑人。</p>
<p>我们的大脑，有一种神奇的功能 —— “无论如何都会用已有信息拼成一个完整图像的功能”。</p>
<p>“无论如何” 的意思是说，不管那已有信息有多么凌乱、有多么残缺、有多么无意义、人脑竟然还是可以拼出一个完整的 “有意义” 的图像。</p>
<p>这一点也经常被人利用。在新闻学里，就有著名的 “Framing Effect”：</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/framing-effect.png?raw=true" alt></p>
<p>这个原理也经常被各路营销使用：</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/framing-bias.png?raw=true" alt></p>
<p>很容易想象，经常被这些东西误导的人，“脑力” 欠缺到什么程度 —— 这当然也是他们全无自学能力的结果之一。</p>
<p>而当我们被刚需幻觉所左右的时候，我们明显是使用 “片面的信息” 拼出了 “完整的意义”，而后被其误导，严重误导，且全然不自知 —— 最气人的是，误导我们的竟然不是别人，竟然是我们自己的大脑！刚需幻觉如此，时间幻觉、困难幻觉亦如是。后面会讲到的注意力漂移，也依然是这种情况，自己才是真正的元凶……</p>
<p>所以，在决定学任何东西的时候，最好不要去咨询身边的人 —— 除非你确定对方是高手，最好是自学高手。否则，你遇到的永远是怀疑、打击、甚至嘲笑。最令人遗憾、最令人无奈的是，那些人其实也不是坏人，他们其实也不是故意，他们只是被自己的 “刚需幻觉” 误导了而已，他们（竟然）以为所有人都和他们一样…… 然后，若是你（居然）听信了他们的话，那就实在是太惨了！</p>
<p><strong>要学，想学，那就自顾自去学吧，用不着征求别人的意见！</strong></p>
<h2 id="优势策略"><a href="#优势策略" class="headerlink" title="优势策略"></a>优势策略</h2><p>如何不被 “刚需幻觉” 所迷惑、所限制呢？</p>
<p>首先，基础策略是，要深刻理解这个现象及其解释：</p>
<blockquote>
<p>对任何一项技能来说，<strong>刚需是自学的结果</strong>，而不是自学的原因。</p>
</blockquote>
<p>用 “是否为刚需” 作为自己是否开始学习的理由，注定会吃亏的，因为如此做的下场就是肯定被 “刚需幻觉” 所迷惑、所限制。</p>
<p>而后，也是更为重要的一个策略：</p>
<blockquote>
<p><strong>做个自驱动的人</strong>，而非被外部驱动的被动的人。</p>
</blockquote>
<p>这基本上是个越早建立越好的习惯。绝大多数人一生都是被动者，终生只是被外界驱动而已。所以，他们会在某一时刻，“发现” 某个技能是刚需，然后再去学，但可惜却肯定的是，到那时候预算总是并不充裕，总是捉襟见肘。</p>
<p>最后一个很简单却很有效的策略是三个字，<a href="Part.2.E.deliberate-thinking.md">之前提到过的</a>：</p>
<blockquote>
<p><strong>找活干</strong></p>
</blockquote>
<p>有活干，真的很幸福。</p>
<h2 id="影响下一代"><a href="#影响下一代" class="headerlink" title="影响下一代"></a>影响下一代</h2><p>想象一下有些父母是这样跟孩子对话的：</p>
<blockquote>
<ul>
<li>爸爸（妈妈），你在干什么呀？</li>
<li>我在学 _________________（请自行填空）</li>
<li>那你学它干什么用啊？</li>
<li>等我学会就知道了……</li>
</ul>
</blockquote>
<p>而后又过了段时间……</p>
<blockquote>
<ul>
<li>孩子，过来看看！这是爸爸（妈妈）做的东西！</li>
</ul>
</blockquote>
<p>我猜，这样的孩子，会从小就自然而然地破解掉 “刚需幻觉”。</p>
<p>所谓的 “潜移默化”，所谓的 “耳闻目染”，其实是很简单的东西。</p>
<p>然而，效果呢？效果不会因为策略的简单或者容易而消减。通常的情况是，越是简单容易的策略，效用越是惊人。</p>
<p>所以，正确结论是这样的：</p>
<blockquote>
<p><strong>一切的技能都是刚需。</strong></p>
</blockquote>
<p>虽然，这并不意味着你不需要选择。</p>
<p>然而，至于学还是不学，其实从来都不是从 “有没有用” 来判断的，真正有意义的判断依据只有一条：</p>
<blockquote>
<p>有没有时间？</p>
</blockquote>
<p>有时间就学呗！没时间就挤时间呗！学得不足够好怎么办？花更多时间呗……</p>
<hr>
<p><strong>脚注</strong></p>
<p><a name="fn1">[1]</a>：写这本书的时候，前后弄出来那么多 <code>.ipynb</code> 文件 —— 于是，到最后哪怕 “生成个目录” 这样看起来简单的活，若是会用正则表达式，就能几分钟完成；但若是不会，那就得逐一手工提取、排序、编辑…… 对我来说怎么可能不是<strong>刚需</strong>！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">files = [f <span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(<span class="string">'.'</span>) <span class="keyword">if</span> os.path.isfile(f)]</span><br><span class="line">files.sort()</span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> files:</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'.ipynb'</span> <span class="keyword">in</span> f:</span><br><span class="line">        <span class="keyword">with</span> open(f, <span class="string">'r'</span>, encoding = <span class="string">'UTF-8'</span>) <span class="keyword">as</span> file:</span><br><span class="line">            str = file.read()</span><br><span class="line">            pttn = <span class="string">r'"# (.*)"\n'</span></span><br><span class="line">            r = re.findall(pttn, str)</span><br><span class="line">            <span class="keyword">if</span> len(r) &gt; <span class="number">0</span>:</span><br><span class="line">                print(<span class="string">f'&gt; - [<span class="subst">&#123;f.replace(<span class="string">".ipynb"</span>, <span class="string">""</span>)&#125;</span>（**<span class="subst">&#123;r[<span class="number">0</span>]&#125;</span>**）](<span class="subst">&#123;f&#125;</span>)'</span>) <span class="comment"># 生成 markdown</span></span><br></pre></td></tr></table></figure>
<pre><code>&gt; - [01.preface（**前言**）](01.preface.md)
&gt; - [02.proof-of-work（**如何证明你真的读过这本书？**）](02.proof-of-work.md)
&gt; - [Part.1.A.better.teachyourself（**为什么一定要掌握自学能力？**）](Part.1.A.better.teachyourself.md)
&gt; - [Part.1.B.why.start.from.learning.coding（**为什么把编程当作自学的入口？**）](Part.1.B.why.start.from.learning.coding.md)
&gt; - [Part.1.C.must.learn.sth.only.by.reading（**只靠阅读习得新技能**）](Part.1.C.must.learn.sth.only.by.reading.md)
&gt; - [Part.1.D.preparation.for.reading（**开始阅读前的一些准备**）](Part.1.D.preparation.for.reading.md)
&gt; - [Part.1.E.1.entrance（**入口**）](Part.1.E.1.entrance.md)
&gt; - [Part.1.E.2.values-and-their-operators（**值及其相应的运算**）](Part.1.E.2.values-and-their-operators.md)
&gt; - [Part.1.E.3.controlflow（**流程控制**）](Part.1.E.3.controlflow.md)
&gt; - [Part.1.E.4.functions（**函数**）](Part.1.E.4.functions.md)
&gt; - [Part.1.E.5.strings（**字符串**）](Part.1.E.5.strings.md)
&gt; - [Part.1.E.6.containers（**数据容器**）](Part.1.E.6.containers.md)
&gt; - [Part.1.E.7.files（**文件**）](Part.1.E.7.files.md)
&gt; - [Part.1.F.deal-with-forward-references（**如何从容应对含有过多 “过早引用” 的知识？**）](Part.1.F.deal-with-forward-references.md)
&gt; - [Part.1.G.The-Python-Tutorial-local（**官方教程：The Python Tutorial**）](Part.1.G.The-Python-Tutorial-local.md)
&gt; - [Part.2.A.clumsy-and-patience（**笨拙与耐心**）](Part.2.A.clumsy-and-patience.md)
&gt; - [Part.2.B.deliberate-practicing（**刻意练习**）](Part.2.B.deliberate-practicing.md)
&gt; - [Part.2.C.why-start-from-writing-functions（**为什么从函数开始？**）](Part.2.C.why-start-from-writing-functions.md)
&gt; - [Part.2.D.1-args（**关于参数（上）**）](Part.2.D.1-args.md)
&gt; - [Part.2.D.2-aargs（**关于参数（下）**）](Part.2.D.2-aargs.md)
&gt; - [Part.2.D.3-lambda（**化名与匿名**）](Part.2.D.3-lambda.md)
&gt; - [Part.2.D.4-recursion（**递归函数**）](Part.2.D.4-recursion.md)
&gt; - [Part.2.D.5-docstrings（**函数的文档**）](Part.2.D.5-docstrings.md)
&gt; - [Part.2.D.6-modules（**保存到文件的函数**）](Part.2.D.6-modules.md)
&gt; - [Part.2.D.7-tdd（**测试驱动的开发**）](Part.2.D.7-tdd.md)
&gt; - [Part.2.D.8-main（**可执行的 Python 文件**）](Part.2.D.8-main.md)
&gt; - [Part.2.E.deliberate-thinking（**刻意思考**）](Part.2.E.deliberate-thinking.md)
&gt; - [Part.3.A.conquering-difficulties（**战胜难点**）](Part.3.A.conquering-difficulties.md)
&gt; - [Part.3.B.1.classes-1（**类 —— 面向对象编程**）](Part.3.B.1.classes-1.md)
&gt; - [Part.3.B.2.classes-2（**类 —— Python 的实现**）](Part.3.B.2.classes-2.md)
&gt; - [Part.3.B.3.decorator-iterator-generator（**函数工具**）](Part.3.B.3.decorator-iterator-generator.md)
&gt; - [Part.3.B.4.regex（**正则表达式**）](Part.3.B.4.regex.md)
&gt; - [Part.3.B.5.bnf-ebnf-pebnf（**BNF 以及 EBNF**）](Part.3.B.5.bnf-ebnf-pebnf.md)
&gt; - [Part.3.C.breaking-good-and-bad（**拆解**）](Part.3.C.breaking-good-and-bad.md)
&gt; - [Part.3.D.indispensable-illusion（**刚需幻觉**）](Part.3.D.indispensable-illusion.md)
&gt; - [Part.3.E.to-be-thorough（**全面 —— 自学的境界**）](Part.3.E.to-be-thorough.md)
&gt; - [Part.3.F.social-selfteaching（**自学者的社交**）](Part.3.F.social-selfteaching.md)
&gt; - [Part.3.G.the-golden-age-and-google（**这是自学者的黄金时代**）](Part.3.G.the-golden-age-and-google.md)
&gt; - [Part.3.H.prevent-focus-drifting（**避免注意力漂移**）](Part.3.H.prevent-focus-drifting.md)
&gt; - [Q.good-communiation（**如何成为优秀沟通者**）](Q.good-communiation.md)
&gt; - [R.finale（**自学者的终点**）](R.finale.md)
&gt; - [S.whats-next（**下一步干什么？**）](S.whats-next.md)
&gt; - [T-appendix.editor.vscode（**Visual Studio Code 的安装与配置**）](T-appendix.editor.vscode.md)
&gt; - [T-appendix.git-introduction（**Git 简介**）](T-appendix.git-introduction.md)
&gt; - [T-appendix.jupyter-installation-and-setup（**Jupyterlab 的安装与配置**）](T-appendix.jupyter-installation-and-setup.md)
&gt; - [T-appendix.symbols（**这些符号都代表什么？**）](T-appendix.symbols.md)
</code></pre><p><a href="#fn1b"><small>↑Back to Content↑</small></a></p>
<h1 id="全面-——-自学的境界"><a href="#全面-——-自学的境界" class="headerlink" title="全面 —— 自学的境界"></a>全面 —— 自学的境界</h1><p>之前提到过那些 “貌似一出手就已然是高手” 的人，也为此做过一番解释：</p>
<blockquote>
<p>他们的特点就是善于<strong>刻意练习</strong>……</p>
</blockquote>
<p>为了真正做到刻意练习，更重要的是需要不断地进行<strong>刻意思考</strong> —— 刻意思考自己究竟应该在哪些地方必须刻意练习？</p>
<p>之前也说过，人和人非常不同，于是，需要刻意练习的地方也各不相同。</p>
<p>不过，倒是有一个方面，所有的自学者都必须刻意练习 —— 这是谁都逃不过的地方：</p>
<blockquote>
<p><strong>全面</strong></p>
</blockquote>
<p>那些 “貌似一出手就已然是高手” 的人就是在这一方面超越了绝大多数人 —— 在每个层面上，他们都学习得更全面，练习得更全面，使用得更全面，在使用此技能去创造的时候，思考得也就自然更为全面。于是，就产生了 “全面碾压” 的效果。</p>
<p>然而，这是很难被人发现的 “秘密”，因为 “全面” 这个事实，只存在于这些高人的大脑之中，很难被展示出来…… 而他们不会想到这是个什么 “秘密” —— 因为他们一直就是这么做的，他们会误以为所有人都是这么做的。</p>
<p>小时候，我经常看到父亲备课到深夜。他手中的教科书，每一页的页边都密密麻麻地写着各种注释，实在没地方写了，就在那个地方插上一张纸，于是能写得更多…… 到最后，他的那本书，要比别人同样的书看起来厚很多。</p>
<p>许多年后，我竟然成了老师，于是，我就备课。我备课的方法自然是 “拷贝” 过来的，我父亲怎么做的，我见过，于是我也那么做。到最后，都到了这个地步：只有那书已经成了别人的两倍厚度心里才踏实。</p>
<p>又过了一段时间，在一个内部分享会中，我听到一位老师的说法，他问我：</p>
<blockquote>
<p>…… 李老师啊，您已经讲了这么久了，都熟到干脆不用备课的地步了吧？</p>
</blockquote>
<p>我愣了一下，讲课前不用备课这事根本就不在我的想象范围之内啊！我父亲讲了那么多年的课，不还是经常备课到深夜嘛？我也一样做了，总是觉得 “还是有很多可以补充的地方” 啊！</p>
<p>然而，这个小插曲提醒了我一个现象：</p>
<blockquote>
<p>我会那么做，我就会误以为所有人都会那么做……</p>
</blockquote>
<p>我猜，那些 “貌似一出手就已然是高手” 的人，也一样，他们从未觉得这是什么 “秘密”，他就是那么做的，他们很久以来就是那么做的，他们误以为所有人都是那么做的。</p>
<p>从另外一方面，外人更希望他们拥有的是个 “秘密”。于是，因为自己并不知道那个 “秘密”，所以，自己做不到他们那样 —— 这样看起来就合理了，自己的心里也够舒服了，毕竟看起来理所应当了么。</p>
<p>把自学当作一门手艺，把所有的技能也都当作一门手艺，那就相对容易理解了：</p>
<blockquote>
<p><strong>全面</strong>，是掌握一门手艺的基本。</p>
</blockquote>
<p>为了全面，当然要靠时间。所以，关于 “混与不混”，我们有了更深刻却又更朴素的认识：</p>
<blockquote>
<p>所谓的不混时间，无非就是<strong>刻意练习</strong>、<strong>追求全面</strong>。</p>
</blockquote>
<p>也正是这个原因，几乎所有自学高手都懂这个道理：</p>
<blockquote>
<p><strong>绝对不能只靠一本书</strong></p>
</blockquote>
<p>有个特别有趣的现象，我觉得绝大多数人平日里都挺大手大脚的，都挺舍不得对自己过分苛刻的，但一到买书这件事上，绝大多数人真的很节俭，真的很苛刻 —— 对待越严肃的知识越是如此。倒是在买本小说啊或者买张电影票的时候，基本不用过脑子。</p>
<p>他们好像完全不知道自己正在疯狂地虐待自己…… 的大脑。</p>
<p>对自己的胃好一点，我绝对认同 —— 因为我自己就是个吃货。</p>
<p>可是，在很长一段时间里，我完全不能理解人们为什么不由自主地对自己的大脑不好，不仅是不好，还是格外地不好，甚至干脆是虐待。</p>
<p>观察学生多了，也就慢慢理解了。</p>
<p>绝大多数人事实上从来没有习得过自学能力，他们终生都在被指导、被引领。而在校教育少则九年，多则十几年二十年，他们体验过太多 “不过尔尔” 的学习过程。他们肯定不是没花过钱，九年义务教育的过程中，就花了父母很多钱，后面若是上了大学，花钱更多…… 花过那么多钱，却总是没什么收获，在他们的经验中，“这次我应该小心点” 是再自然不过的事。</p>
<p>“第一次突破” 很重要。</p>
<p>如果一个人有过一次只通过阅读书籍即获得一项新技能的体验，那么，他们内心深处（更准的说法是大脑的底层操作系统）的那个成本计算方法就会发生改变，心里想的更可能是：</p>
<blockquote>
<ul>
<li>这肯定是有用的，一旦学会，收益可不是几十块钱的书价或几百块课价那么一点点……</li>
<li>至于是否能学会，主要看我投入的时间精力预算有多少……</li>
</ul>
</blockquote>
<p>我身边有很多自学能力非常强的人。</p>
<p>这些人买书的方式都是一样的，一旦他们决定学习什么技能的时候，第一个想到的是去买书，而不是去找人。他们之前体验过，他们就是很清楚：</p>
<blockquote>
<ul>
<li>首先，书里什么都有；</li>
<li>其次，仅靠阅读在大多数情况下绝对够了……</li>
</ul>
</blockquote>
<p>更为不一样的是，他们一定会买回来一大堆书 —— 而不是四处去问，“关于 xx 的哪一本书最好啊？”</p>
<p>在他们眼里，书是成本最低的东西，比起最终的收益来讲更是不值一提。</p>
<p>更为重要的是，<strong>一本书绝对不够</strong> —— 无论是谁写的，无论那个作者多么著名，影响力有多大…… 因为，书也好、教程也罢，这种东西就是有 “篇幅限制” 的。更为关键的是，每个作者都有不一样的视角、不一样的出发点和不一样的讲解方式、组织方法。</p>
<p>比如，我这本就跟别人写的很不一样。我的出发点是把编程当作一个自学的例子，重点在于学会如何自学，并且通过实践真的习得一个起初你觉得不是刚需，学会之后发现干脆离不开的、不可或缺的技能。这本书的内容组织方式也不一样 —— 反正你现在已经知道了。</p>
<p>另外，这本书的目标里有更重要的另外一个：“让你有能力靠自己能够理解所有的官方文档” —— 书里不用讲官方标准库里的每个模块、每个函数究竟如何使用，因为那些在官方文档里定义得非常清楚……</p>
<p>而其他人写的呢？比如 <a href="http://greenteapress.com/wp/think-python-2e/" target="_blank" rel="noopener">Think Python</a>，比如 <a href="https://python.swaroopch.com/" target="_blank" rel="noopener">A Bite of Python</a>，再比如 <a href="https://linux.die.net/diveintopython/html/" target="_blank" rel="noopener">Dive into Python</a><a href="#fn1" name="fn1b"><sup>[1]</sup></a>，以及网上很多很多免费的 Python 教程都写得很好呢！</p>
<p>没有经验的人不懂而已。当你搞明白了一本书，后面再多读哪怕很多本的时间精力成本都是很低的，但每多读一本，都能让你在这个话题中变得<strong>更为完整</strong>。</p>
<p>针对同一个话题读很多本书的最常见体验就是：</p>
<blockquote>
<ul>
<li>嗯？这个点很好玩！这个角度有意思！</li>
<li>看看比比前面几个作者怎么论述的呢？</li>
<li>嗯？！怎么我看过却竟然没注意到呢！</li>
</ul>
</blockquote>
<p>这最后一条真的是很令人恼火却又享受的体验。它令你恼火，是因为你竟然错过；它令你享受，是因为虽然错过却竟然还有弥补的机会！</p>
<p>总有一天你会明白的，一切的 “学会” 和 “学好” 之间的差异，无非是<strong>全面程度</strong>的差异。</p>
<p>于是，翻译过来，“学好” 竟然如此简单：</p>
<blockquote>
<p><strong>多读几本书。狠一点，就是多读很多本书。</strong></p>
</blockquote>
<p>到最后，这种习惯会慢慢延伸到生活中。比如，我在遇到好歌的时候，总是想尽一切办法找到那首歌的很多版本，首唱者可能有很多版本，录音版、现场版，不同年份的版本等等；还有很多翻唱…… 看电影也一样，若是有翻拍版本，一定会找过来看 —— 不同国家的翻拍版本对比起来特别好玩。</p>
<p>甚至，到最后，你做东西的时候都会想着顺手多做几个版本。我这本 “书”，就肯定会有印刷版、电子版…… 到最后还会有个产品版 —— 这基本上是目前尚无其它作者做到的事情。</p>
<p>提高对所学知识技能的 “全面程度”，有个最狠的方法 —— 再次说出来不惊人，但实际效果惊到爆：</p>
<blockquote>
<p><strong>教是最好的学习方法。</strong></p>
</blockquote>
<p>这真的不是我的总结，人类很早就意识到这个现象了罢？</p>
<p>孔老夫子在《礼记・学记》里就 “曰” 过：</p>
<blockquote>
<p>“学然后知不足，教然后知困。知不足，然后能自反也；知困，然后能自强也。故曰：教学相长也。”</p>
</blockquote>
<p>到了孔子三十二代孙，孔颖达，解读《兑命》中所提 “学学半” 时，说到：</p>
<blockquote>
<p>“学学半者，上学为教，下学者谓习也……”</p>
</blockquote>
<p>许嘉璐先生<a href="#fn2" name="fn2b"><sup>[2]</sup></a>有一本书，《未央续集》，提到这段解读的时候讲了个自己的例子：</p>
<blockquote>
<p>“我当了五十年的教师，经常遇到这种情况：</p>
<blockquote>
<p>备好课了，上讲台了，讲着讲着，突然发现有的地方疏漏了，某个字的读音没有查，文章前后的逻辑没有理清楚，下完课回去补救，下次就不会出现同样的情况了，这就是教学相长。”</p>
</blockquote>
</blockquote>
<p>所以，别说老师了，学生更是如此。</p>
<p>我经常讲我所观察到的班里的第一和第二的区别 —— 因为这是很好的例子。</p>
<p>第一总是很开放，乐于分享，别人问他问题，他会花时间耐心解答；第二总是很保守，不愿分享，不愿把时间 “浪费” 在帮助他人身上…… 注意，在 “浪费” 这个词上我加了引号 —— 这是有原因的。</p>
<p>我的观察是，这不是现象，这是原因：</p>
<blockquote>
<p>第一之所以比第二强，更可能是因为他开放、乐于分享，才成了第一。</p>
</blockquote>
<p>而不是因为他是第一，所以才开放，所以才乐于分享。</p>
<p>因为到最后，你会发现，第一并没有因为时间被占用而成绩退步，反而成绩更好。这是因为他总是在帮助其他同学的过程里，看到了自己也要避免的错误、发现了其它的解题思路、巩固了自己的知识点，所以他在社交的过程中学到了更多，同时还收获了同学们的友谊 —— 换言之，通过分享，通过反复讲解，他自己的 “全面程度” 得到了最快的提高。</p>
<p>而第二呢？第二其实有可能比第一更聪明呢 —— 他可是全靠自己走到那个地步的！可是，他没有用最狠的方式提高自己的全面程度，虽然排名第二，可他其实只不过是一个 “下学” 者，于是，他很吃力的 —— 虽然他实际上很聪明…… 于是，在这种感受下，他怎么肯愿意把那么吃力才获得的东西分享出去呢？</p>
<p>这真是个有趣且意味深长的现象。</p>
<p>另外一个有趣的现象是，“下学” 者永远等待 “上学” 者整理好的东西。之前在《<a href="Part.1.F.deal-with-forward-references.md">如何从容应对含有过多 “前置引用” 的知识？</a>》提到过一个对应策略：</p>
<blockquote>
<p>尽快开始整理归纳总结</p>
</blockquote>
<p>同时给出了建议：</p>
<blockquote>
<p>一定要自己动手去做……</p>
</blockquote>
<p>不仅如此，还描述了个我自己的例子，通过 “自己动手整理” 才发现自己之前竟然完全理解错了。</p>
<p>我这方面运气非常好，因为父母全都是大学教师，从小父母就鼓励我帮同学解答问题，这让我不知不觉在很早很早就开始了 “上学” 的阶段。</p>
<p>这一次写这本 “书” 的过程中，同样的 “奇迹” 再次发生在我身上。</p>
<p>说实话，正则表达式我一直没有完全掌握 —— 虽然偶尔用用，也都是边查边用。实在解决不了，就算了…… 现在回头想想，多少就是因为 “<a href="Part.3.D.indispensable-illusion.md">仅凭感觉，并没觉得那绝对是刚需</a>” <a href="#fn3" name="fn3b"><sup>[3]</sup></a> —— 当然，真正会了之后，马上开始时时刻刻都有可能使用，离开它简直活不下去 —— 写这书的后半程，有大量的重新组织的需要，很多文字替换，若是没有正则表达式，就干脆没法干……</p>
<p>我是如何完全掌握正则表达式的呢？就是因为写这本书。既然是写书，当然害怕自己在不经意中出错，此为其一。更为重要的是，必须先完整掌握之后才能有诸如 “为读者提供更好一点的理解起点”，“理解起来相对更简单直接的组织结构”，以及 “挖掘必须习得它的真正原因以便鼓励读者” 之类的畅销书卖点 —— 对作者来说，有什么比销量更重要的呢？</p>
<p>写一本好书，对我来讲，这个需求太刚了，刚到好像是<strong>钛钢</strong>的地步。</p>
<p>于是，本来就习惯于同一个话题多读好多本书的我，读了更多的书，翻了更多的教程，官方文档翻了更多遍，做了更多的笔记，每一章反复废掉原稿再次重写了很多遍…… 在这样的刺激下，“全面程度” 若是没有极速提高，那才怪了呢！</p>
<p>还有啊，我的英语，也是这么搞出来的。</p>
<p>所以，很多的时候，我这个人并不是 “好为人师”，细想想，貌似 “好为己师” 更为恰当一点。写书也好讲课也罢，其实自己的进步是最大的。</p>
<p>若是我没有在新东方教书七年，我连当前这个半吊子英文水准都不会有…… 为了在讲台上不犯错，多多少少都得多费一些功夫吧？我的经验和许嘉璐先生是一样的，无论备课多努力，后面还是会有纰漏…… 可是，这若只是做个 “下学” 者，岂不更惨？</p>
<p>哦，对了，其实所有的读者，都可以用这个简单的方法影响下一代：</p>
<blockquote>
<p>有同学问，你就一定要耐心讲讲 —— <strong>对自己有好处。</strong></p>
</blockquote>
<p>当然，最直接的方法是把自己变成 “上学” 者，保持开放，乐于分享，而孩子只需通过 “耳闻目染” 就可以了。</p>
<hr>
<p><strong>脚注</strong></p>
<p><a name="fn1">[1]</a>：一点八卦：Dive into Python 的作者是 <a href="https://en.wikipedia.org/wiki/Mark_Pilgrim" target="_blank" rel="noopener">Mark Pilgrim</a>；他是互联网上最著名的自绝于信息世界（<a href="https://www.urbandictionary.com/define.php?term=infosuicide" target="_blank" rel="noopener">infosuicide</a>）的三人之一。另外两位分别是比特币的作者 <a href="https://en.wikipedia.org/wiki/Satoshi_Nakamoto" target="_blank" rel="noopener">Satoshi Nakamoto</a>，和 <a href="https://whytheluckystiff.net/" target="_blank" rel="noopener">Why the lucky stiff</a> 的作者 <a href="https://en.wikipedia.org/wiki/Why_the_lucky_stiff" target="_blank" rel="noopener">Jonathan Gillette</a>。</p>
<p><a href="#fn1b"><small>↑Back to Content↑</small></a></p>
<p><a name="fn2">[2]</a>：许嘉璐，1998 年至 2000 年全国人大常委会副委员长，民进中央主席，国家语言文字工作委员会主任。</p>
<p><a href="#fn2b"><small>↑Back to Content↑</small></a></p>
<p><a name="fn3">[3]</a>：写完这一段，给霍炬看，他当场嘲笑我，“哈！当年我就说，你应该学学 Vim，是不是到现在你都没学？” 我无言以对，因为真的就没学…… 然后，我想了想，回复他说，“好吧，我决定写一个 Vim 教程出来，嗯。”</p>
<p><a href="#fn3b"><small>↑Back to Content↑</small></a></p>
<h1 id="自学者的社交"><a href="#自学者的社交" class="headerlink" title="自学者的社交"></a>自学者的社交</h1><p>很多人有莫名其妙的误解，以为 “自学”（self-teaching）就一定是 “自己独自学”（solo-learning），殊不知，自学也需要社交。也有另外一些人，因为 “专心” 到一定程度，觉得社交很累，所以开始抵触一切社交。这些都不是全面的看法。</p>
<p>事实上，在任何领域，社交都是必须的，只不过，很多人没有建立、打磨过自己的社交原则，所以才被各种无效社交所累。就算讨厌，讨厌的也不应该是社交，而是无效社交。</p>
<p>在自学的任何一个阶段，学、练、用、造，社交都可能存在。</p>
<p>哪怕是在最枯燥，看起来最不需要社交的 “练” 的阶段，社交也会起很大的作用 —— 在自己累了的时候，看到有人还在练，看到很多人都在练，看到很多人其实也挺累的但还在练…… 这些都是让自己感觉没那么费劲的好办法。</p>
<p>实际上，在最初 “学” 的阶段，社交也是极为重要的。</p>
<p>生活中，你遇到过这样的现象没有：“看见别人打针，自己先疼得受不了……” 这是因为我们的大脑中有一种神经元，叫做<strong>镜像神经元</strong>（Mirror Neuron），它会让我们 “感同身受”，当我们看到另外一个人正在做什么的时候，镜像神经元会尽力给我们足够的刺激，让我们 “体验” 那个人的感受。以前人们不知道为什么哈欠竟然会 “传染”，现在科学家们很清楚了 —— 那就是镜像神经元在起作用。</p>
<p>镜像神经元的存在，使得我们有模仿能力、有通感能力、有同情心、有同理心…… 这也是为什么人类天然有社交需求的重要原因，因为我们的大脑皮层上都有很多的镜像神经元。</p>
<p>一般来说，物品、书籍之类非人的东西，都不大可能激活镜像神经元。只有看到人的时候，镜像神经元才会被激发。所以，你送给小朋友一把吉他，他不会有什么兴趣的。可若是你在弹琴的时候被他看见，他的镜像神经元就会因为你的行为而被触发，进而对弹奏吉他感兴趣 —— 注意，不是对吉他本身感兴趣。若是你在弹琴的时候，带着某种能够打动他的情绪，那他更容易被影响，因为情绪更能激发镜像神经元。也就是说，一切的学习起初都基于模仿，一切的模仿，都源自于看到真人的行为 —— 哪怕是在电影里看到，虽然只不过是影像而已，并非真人，但毕竟是真人的影像。</p>
<p>所以，无论学什么技能，都要找到用那种技能的人，这样我们的镜像神经元才可能更容易被激发，学习效果才会好。若是能找到热爱那项技能，乃至于一使用那项技能就很开心（最好的情绪之一）的人，那就更好了。激情这东西，是少数幸运儿才长期持有的东西，大多数人小时候挺多，过了十五六岁之后就开始有意无意磨灭了激情，且并不自知。</p>
<p>之前提到，</p>
<blockquote>
<p>当我们看到另外一个人正在做什么的时候，镜像神经元会<strong>尽力</strong>给我们足够的刺激，让我们 “体验” 那个人的感受。</p>
</blockquote>
<p>这句话里有个词很重要，“尽力”。因为镜像神经元只能调用我们大脑里已有的信息去模拟对方的感受，所以，它最多也就是 “尽力”，无法做到 “确保正确”。今天的糖尿病患者使用的皮下注射针头，已经可以做到很细，细到让使用者 “无感” 的地步，所以，当一个糖尿病患者给自己注射胰岛素的时候，他自己并不觉得疼，可是看的人却能 “疼” 到紧皱眉头的地步，为什么？因为旁观者的大脑里没有实际用那么细的针头注射胰岛素的经验，所以镜像神经元在旁观者 “感同身受” 时所调用的，其实是过往旁观者自己打针的体验 —— 被很粗的针头做静脉注射的痛苦体验。</p>
<p>所以，很多人误以为他们眼里的成功者靠的是 “坚持”、靠的是 “毅力”，这完全是自己的镜像神经元 “尽力” 的结果，是 “调用自己过往经验去<strong>感同身受</strong>的结果”…… 事实上呢？那些 “成功者” 其实并不在意成功，因为到死之前成长不应该也不可能结束，因为那是他们的生活方式，学习、进步、探索、迂回，甚至折腾、挫败和迷茫，都是他们生活中必不可少的内容，这是最初不自觉的选择，谈不上什么 “坚持”，谈不上什么 “毅力”…… 说实话，对他们来说，不让折腾才真痛苦呢，不学习才需要坚持和毅力呢！</p>
<p>再进一步，这也是为什么要选择朋友的原因。人与人之间有很大的差异，最大的差异来自于性格养成，大多数人会沦为表现型人格，只有少数人才会在不断调整中保持、呵护、进一步培养 “进取型” 人格。他们自然而然地更为乐观，更有耐心，更有承受力，更有战斗力，更能生产更能体验学习与进步的乐趣。与这样的人在一起，学习会更容易 —— 只因为镜像神经元会更容易地被正确激发。说清楚了，道理其实挺简单的。</p>
<p>有一次朋友跟我聊起他苦于没办法培养自己孩子的正经兴趣爱好…… 我说，其实很简单，只不过是你方法错了。你不用告诉孩子 “应该学什么，应该对什么感兴趣”，而是，想尽一切办法让孩子见识到拥有那个技能的，令他产生<strong>羡慕情绪</strong>的人 —— 只要孩子羡慕那个人，他就自然而然地有 “我也想这样” 的想法，到最后，谁都拦不住。这就是镜像神经元的力量。进而，所谓的社交，还真不一定是非要跟人说话、聊天…… 见识到，也是社交的最主要组成部分。</p>
<p>你看，谁说社交不重要？</p>
<p>进而，想要把一门手艺搞到真正 “精湛” 的地步，最有效的方法就是尽早进入 “造” 的阶段 —— 所谓的 “造”，就是不断<strong>创造</strong>的 “造”。</p>
<p>自学这门手艺，很简单，就是不断地学：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">teach_yourself</span><span class="params">(anything)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> create():</span><br><span class="line">        learn()</span><br><span class="line">        practice()</span><br><span class="line">    <span class="keyword">return</span> teach_yourself(another)</span><br><span class="line"></span><br><span class="line">teach_yourself(coding)</span><br></pre></td></tr></table></figure>
<p>学上几个，自然就很精湛。而其它的用自学这门手艺习得的手艺，基本上都可以用 “是否做出了像样的作品” 作为检验自己的那门手艺是否达到了精湛的衡量指标。</p>
<p>硅谷有一家著名的孵化器，叫 Y-Combinator，现在的掌门人是个很年轻的人，Samuel H. Altman。他在那篇著名的文章《<a href="https://blog.samaltman.com/advice-for-ambitious-19-year-olds" target="_blank" rel="noopener">Advice for ambitious 19 year olds</a>》中有一个精彩的建议：</p>
<blockquote>
<p>No matter what you choose, build stuff and be around smart people. <br><br>无论你选择了什么，都要造出东西来，要与聪明人打交道。</p>
</blockquote>
<p>当然，对于 “聪明人” 这个概念，我和 Sam 的看法并不一致。在我看来，有好作品的人都很聪明，但还是那句话，那不是天分和智商，那分明是有效积累。</p>
<p>我个人最看重的个人品质之一，就是<strong>有没有像样的作品</strong>。</p>
<p>很少有人有像样的作品。人群中只有少数人最终能拿出完整的作品 —— 人与人之间的差异是如此之大，乃至于少数人有作品，更少数人有好的作品，只极少数极少数人才可能做出传世的作品；而与此同时，绝大多数人（万分之九千九百九十九的人）一辈子都没有像样的作品，他们连一篇作文都写不明白。于是，与有像样作品的人打交道，总是非常值得。</p>
<p>并且，跟他们打交道也不费劲，都是思考非常通透的人，通常沟通能力极强。哪怕沟通起来貌似费劲的那一小部分，事实上也不是难以沟通，那只不过是人家简单朴实而已。</p>
<p>我甚至经常建议我的合伙人们，在招人的时候，把这一点当作最靠谱的判断方式。少废话，少吹牛逼，给我看看你的作品。这个原则可以一下子过滤掉所有的不合格者。另外一个很自然的现象是，如果一个人能做出像样的东西来，那么他身边的聪明人密度无论如何都会比其他人的高出很多。</p>
<p>地球上有效社交密度最高的地方，是 <a href="https://github.com" target="_blank" rel="noopener">Github</a>。有些程序员们常开玩笑，说 Github 是全球最大的同性社交网站，事实上，他们不知道，女性程序员的比例正在逐步提高，而且女性在科学上，从来就没有屈居二线过<a href="#fn1" name="fn1b"><sup>[1]</sup></a>。</p>
<p>在 Github 上，找到自己感兴趣的项目，而后为那项目贡献一己之力，用自己的工作赢得社区的认同…… 这就是 Github 上的社交方式。若是自己做了有意义的项目，就会有更多人关注；若是那项目对很多人有用，那就不仅有很多人关注，更有很多人会像当初的你一样为这个项目做贡献…… 这就是程序员们的<strong>有效社交</strong>。</p>
<p>Github 能成为地球上最大的有效社交网络，没毛病，因为<strong>用作品社交肯定是最高效的。</strong></p>
<p>所以，无论学什么，都要想尽一切办法尽快做出自己的作品。做一个产品出来的过程中，会磨练另外一项自学者不可或缺的能力和素质：</p>
<blockquote>
<p><strong>完整</strong></p>
</blockquote>
<p>与之前提到的另外一项加起来，就构成了自学者的最基本素养：</p>
<blockquote>
<ul>
<li>学就学得<strong>全面</strong>；</li>
<li>做就做得<strong>完整</strong>。</li>
</ul>
</blockquote>
<p>无论多小的作品，都会让创作者感受到 “单一技能的必然无效性” —— 你试试就知道了。哪怕你想做个静态网站，你都会发现，仅仅学会 html/css 是不够的，因为部署到远端服务器上的时候，你无论如何都得学学 Linux 基本操作…… 而已然具备了自学者基本素养的你，自然会想办法 “全面掌握”，而不是糊弄一下而已。</p>
<p>更为重要的是，一旦你开始创作作品，你更大的 “发现” 就是，你肯定需要很多 “之前看起来并不相干的知识与技能”，而非 “只靠专业就够了”……</p>
<p>还是拿我出第一本书为例。那之前我没有写过书，若是出版了书放在书店，没有人知道李笑来是谁…… 于是，只有内容本身，并不保证那书能卖出去。除了把内容写出来之外，我必然要去学习很多之前完全没碰过的东西，比如 “如何才能做到系统持续地修订内容”；又比如，“如何与出版社编辑正常沟通”；再比如，“如何取一个好书名”…… 一个赛一个地 “与专业无关”。</p>
<p>所以，“做得完整”，从来都不是容易的事情。</p>
<p>从这个角度去理解，你就会明白那些高明的手艺人为什么总是做小东西 —— 那是因为在追求完整的过程中，你必然会发现，越小越容易完整。这也是为什么庸人总是好高骛远，因为他们不顾完整，所以就可以妄图建造海市蜃楼。</p>
<p>手艺人不怕做的事小。而且，“小” 无所谓，“完整” 才是关键。</p>
<p>有作品和没作品的人理解能力也不一样。做过作品的人，看到类似 MoSCoW Method 的做事原则，瞬间就能有所感悟，而没有作品的人，却不见得有一样的感受。</p>
<blockquote>
<p>顺带给你看个 Wikipedia 上的链接列表，在编程领域里，有无数可以借鉴到生活中的哲学、方法论：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/If_it_ain%27t_broke,_don%27t_fix_it" target="_blank" rel="noopener">If it ain’t broke, don’t fix it</a></li>
<li><a href="https://en.wikipedia.org/wiki/KISS_principle" target="_blank" rel="noopener">KISS principle</a></li>
<li><a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" target="_blank" rel="noopener">Don’t repeat yourself</a></li>
<li><a href="https://en.wikipedia.org/wiki/Feature_creep" target="_blank" rel="noopener">Feature creep</a></li>
<li><a href="https://en.wikipedia.org/wiki/List_of_software_development_philosophies" target="_blank" rel="noopener">List of software development philosophies</a></li>
<li><a href="https://en.wikipedia.org/wiki/Minimum_viable_product" target="_blank" rel="noopener">Minimum viable product</a></li>
<li><a href="https://en.wikipedia.org/wiki/MoSCoW_method" target="_blank" rel="noopener">MoSCoW method</a></li>
<li><a href="https://en.wikipedia.org/wiki/Overengineering" target="_blank" rel="noopener">Overengineering</a></li>
<li><a href="https://en.wikipedia.org/wiki/Worse_is_better" target="_blank" rel="noopener">Worse is better</a></li>
<li><a href="https://en.wikipedia.org/wiki/SOLID" target="_blank" rel="noopener">S.O.L.I.D.</a></li>
<li><a href="https://en.wikipedia.org/wiki/Unix_philosophy" target="_blank" rel="noopener">Unix philosophy</a></li>
</ul>
</blockquote>
<p>给自己足够长的时间去学；在充足 “预算” 之下耐心地练；不断找活干，以用代练；然后，最重要的是，一定要尽快尝试着做出属于自己的<strong>完整</strong>作品，无论大小。</p>
<p>只有这样，你才是个值得被交往的人。</p>
<hr>
<p><strong>脚注</strong></p>
<p><a name="fn1">[1]</a>：NPR：<a href="https://www.npr.org/2011/11/27/142664182/most-beautiful-woman-by-day-inventor-by-night" target="_blank" rel="noopener">Most Beautiful Woman’ By Day, Inventor By Night</a></p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/Lamarr_patent.png?raw=true" alt></p>
<p>上图是保存在美国专利局的一个存档文件（US Patent 2,292,387, Aug 11, 1942）截图。这项专利的发明者是 <a href="https://en.wikipedia.org/wiki/Hedy_Lamarr" target="_blank" rel="noopener">Hedy Lamarr</a>，人家长得是这样的：</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/hedy-lamarr-hero-getty.jpg?raw=true" alt></p>
<p>Hedy Lamarr 是好莱坞最知名的演员之一，并且，她也是自学高手：</p>
<blockquote>
<p>Although Lamarr had no formal training and was primarily self-taught, she worked in her spare time on various hobbies and inventions, which included an improved traffic stoplight and a tablet that would dissolve in water to create a carbonated drink. The beverage was unsuccessful; Lamarr herself said it tasted like Alka-Seltzer.</p>
</blockquote>
<p><a href="#fn1b"><small>↑Back to Content↑</small></a></p>
<h1 id="这是自学者的黄金时代"><a href="#这是自学者的黄金时代" class="headerlink" title="这是自学者的黄金时代"></a>这是自学者的黄金时代</h1><p>历史上，自学者从未像今天这样幸福。</p>
<p>以前不是这样的。比如，几乎每个中国人从小就听说过无数次那种 “为了拜师学艺一跪就几天甚至几个月也不一定被收下” 的故事。</p>
<p>在古代，拜师学艺的确是很难的事情。首先，真正的好老师确实难寻；其次，高手也没空当老师；再次，就算是肯收徒授艺的老师也总是时间精力极其有限…… 更为重要的是，那时候想自学也真不行 —— 根本就没有什么称得上是文献的东西可供阅读或检索，很多重要信息甚至干脆只存在于某些人的脑中，就算它们被落实成了文献，也相当有限，且散落深藏在各处 —— 就算凑齐了，也没有 <a href="https://www.google.com/ncr" target="_blank" rel="noopener">Google</a>！</p>
<p>对，最关键的是那时候没有 Google……</p>
<p>今天的互联网，已经不再是二十几年前刚出现的那样 “激进而简陋” 的东西了。经过多年的发展，互联网上的内容已经构成了真正意义上的 “全球唯一通用图书馆” —— 而针对它可用的检索工具中最好的，当然是 Google。</p>
<p>于是，今天，自学者在真正的意义上身处于一个黄金时代 —— <strong>没有什么是不能自学的</strong>。注意措辞，在这句话前面甚至根本不用加上 “几乎” 这样的限定以示准确 —— 你想学什么，就能学什么，而不是 “只有先拜师才能开始学艺”。</p>
<p>今天的你，想学什么就去问 Google；在学习中遇到什么问题，就直接问 Google —— 直接问它，通常总是比向某个人提问有效率得多。Google 就是这样，越用越离不开它……</p>
<p>其实很多人并不真的懂如何用好 Google 的，可是连这个它也能解决，因为你可以直接问它：</p>
<blockquote>
<p><a href="https://www.google.com/search?q=How+to+use+google+effectively" target="_blank" rel="noopener">How to use google effectively</a></p>
</blockquote>
<p>经过多年的发展，Google 的使用体验越来越好，2019 年的今天，你搜索以上语句返回的页面里，Google 甚至在众多搜索结果中选了一条它 “认为” 是 “最佳” 的搜索结果：</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/google-how-effectively.png?raw=true" alt="google-how-effectively"></p>
<p><a href="https://www.lifehack.org/articles/technology/20-tips-use-google-search-efficiently.html" target="_blank" rel="noopener">lifehack.com 上的这篇文章</a>也的的确确值得细读 —— 读过且真正理解之后，不夸张地讲，你的 “搜索技能” 已经足够灭掉整个人类当前活跃群体中的 99% 了…… 这个说法真的完全没有夸张，绝大多数人就是不会在搜索的过程中使用那些符号的，比如 <code>-</code> <code>*</code> <code>~</code> <code>@</code> <code>#</code> <code>:</code> <code>&quot;</code> <code>..</code> —— 还有很多其它技巧…… 话说，你在 Google 上用过 <code>Time *place*</code> 吗？</p>
<p>已经掌握了正则表达式以及 glob 的你，学习一下如何使用这种符号，实在是太小菜一碟了 —— 然而，这么简单的东西所能带来的未来收益是非常惊人的，不信走着瞧。</p>
<p>可实际上，还是得应用我们之前说过的原则：</p>
<blockquote>
<p>首选查询，肯定是官方文档。</p>
</blockquote>
<p>这么做的重要理由之一，是为了让你少受 “二手知识” 的蒙蔽和误导。这里有一个绝佳的例子让你理解二手知识的局限性：<a href="https://github.com/xiaolai/ji" target="_blank" rel="noopener">我写过的一本 “书”，发布在网上</a> —— 这本 “书” 的另外一个 “神” 之处，在于它能让你 “顿悟” 阅读的力量，不管你是男生还是女生…… 若是这个链接错过了，你竟然会错过整个生活！</p>
<p>Google Search 的官方文档在这里：</p>
<blockquote>
<p><a href="https://support.google.com/websearch" target="_blank" rel="noopener">https://support.google.com/websearch</a></p>
</blockquote>
<p>Google 还有更为强大的工具给你使用，叫做 Google Custom Search，官方文档在这里：</p>
<blockquote>
<p><a href="https://support.google.com/customsearch/" target="_blank" rel="noopener">https://support.google.com/customsearch/</a></p>
</blockquote>
<p>对编程工作来说，Google 当然格外地更为重要 —— 互联网上积累的最多最专业的信息，当然是计算机相关信息。所以，当你遇到什么错误提示的时候，不仅要问 Google，还要优先问问 <a href="https://stackoverflow.com" target="_blank" rel="noopener">Stackoverflow</a> —— 连 Google 自己都这么干。在 <a href="https://colab.research.google.com" target="_blank" rel="noopener">colab.research.google.com</a>（Google 为它的 TensorFlow 服务搭建的 Jupyterlab 环境）上，如果你运行什么代码出错了的话，那么，出错信息下面会出现一个按钮，上面写着：<code>SEARCH STACK OVERFLOW</code>，点击它就直接给你 <a href="https://stackoverflow.com" target="_blank" rel="noopener">Stackoverflow</a> 上的搜索结果…… 真够意思！</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/google-stackoverflow.png?raw=true" alt="google-stackoverflow"></p>
<p><a href="https://google.com" target="_blank" rel="noopener">Google</a>、<a href="https://stackoverflow.com" target="_blank" rel="noopener">Stackoverflow</a>、<a href="https://en.wikipedia.org" target="_blank" rel="noopener">Wikipedia</a>、<a href="https://youtube.com" target="_blank" rel="noopener">Youtube</a>，这些都是你经常要去搜索的好地方。</p>
<p>二十年前，Google 刚出现的时候，谁能想象它今天这个样子呢？以下是 1998 年 11 月 11 日 <a href="http://google.com" target="_blank" rel="noopener">http://google.com</a> 这个网址的截图：</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/google-homepage-1998.png?raw=true" alt="google-homepage-1998"></p>
<p>当时，网站还没有正式上线，第一个链接是一个原型设计，用一个二级域名发布在斯坦福的网站上：<a href="http://google.stanford.edu/：" target="_blank" rel="noopener">http://google.stanford.edu/：</a></p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/google-prototype-1998.png?raw=true" alt="google-prototype-1998"></p>
<p>那个时候，Google 还要向外人强调一下，他们已经有 2500 万页面可供检索！</p>
<p>事实上，到了 2008 年，Google 公告称，可供检索页面已经超过一万亿（One Trillion），到了 2016 年年底，这个数字已经超过 130 万亿……</p>
<p>换个角度看，这个数字同时也是互联网上信息的积累 —— 世界上再没有比互联网更大更全的 “书” 了。并且，由于 Google 的存在，互联网这本大书，是可检索的！</p>
<p>于是，<strong>有事先问 Google</strong> 就成了自学者的必备修养。</p>
<blockquote>
<p>能 Google 出答案的问题，就不需要去麻烦别人。</p>
</blockquote>
<p>这也是一个自学者的基本素养。</p>
<p>偶尔，也确实会遇到 Google 了很久，就是没有找到答案的情况…… 这样的时候，你可能需要想办法 “问人” 了。然而，最靠谱的通常并不见得是 “身边的人”，而是互联网上各种垂直社区里的其他用户……</p>
<p>向人问，也是有学问的 —— 很多人张口就问，结果呢？结果没人理。为什么呢？</p>
<p>作为一个有素养的自学者，有一篇文章必须精读：</p>
<blockquote>
<p><a href="https://github.com/selfteaching/How-To-Ask-Questions-The-Smart-Way" target="_blank" rel="noopener">How To Ask Questions The Smart Way</a></p>
</blockquote>
<p>这是大神 Eric S. Raymond 和 Rick Moen 于 2001 年在网上发布的文章，被人们奉为经典；迄今为止经历了很多次的修订，最后一次是在 2014 年，<code>Revision 3.10</code> —— 前后被翻译成了许多种语言。</p>
<p><strong>不认真使用 Google，你就错过了整个人类历史上自学者最黄金的时代。</strong></p>
<h1 id="避免注意力漂移"><a href="#避免注意力漂移" class="headerlink" title="避免注意力漂移"></a>避免注意力漂移</h1><p><strong>注意力漂移</strong>，是我杜撰的一个词，用来作为 “注意力集中” 的反义词 —— 因为更多的时候，我们并不是 “注意力不集中”，而是…… 而是更令人恼火的一个现象：</p>
<blockquote>
<p>“注意力所集中的焦点总是不断被自己偷偷换掉……”</p>
</blockquote>
<p>比如，你本来只不过就想着去 Google 一个编程错误信息的解读，结果不知道怎么就 “注意到” 了另外一个东西，比如，“某编辑器的皮肤”，然后你就 “顺手” 把它下载下来，然后 “很自然地顺手把它装上”，而后又看了看，觉得有点必要于是 “顺手做了点定制”…… 然后欣赏了一会儿，并自我得意一番之后 “突然发现” 自己还没有解决两小时之前要解决的问题！</p>
<p>说这种现象 “令人恼火”，是因为那注意力所集中的焦点，是被<strong>自己</strong>偷偷换掉的！</p>
<p>好奇心越重的人，越是容易被注意力漂移所拖累。</p>
<p>好奇心是好东西，而且是必须认真呵护的东西 —— 几乎最重要、最强劲的自学动力，都混合着好奇心出现并持续。</p>
<p>在我成长的那个年代里，很多孩子本来是可以成为自学专家的，结果，99.99% 都被父母给毁了 —— 而且还是不经意地毁的。那些父母毁掉自己孩子的方法简单直接又粗暴、且毫不犹豫。</p>
<p>刚开始图好玩，小孩子问啥都回答…… 当然，最初的时候，小孩子问的问题也很容易回答；就算不容易，也很容易糊弄过去。没多久，父母就开始应付不过来了，一方面自己也没那么多耐心了，另外一方面是更为严重的问题 —— 自己的脑力不够。再加上那时候也没有 Google，所以，父母的反应惊人地一致：“去去去，赶紧睡觉！怎么就你事这么多？！”</p>
<p>一个个小朋友就这样被毁掉了，他们的好奇心就这样成了他们自己要主动避免的东西 —— 否则就会挨骂，谁愿意动不动就被一通数落呢？</p>
<p>好奇心是驱动一个人不断进步的最重要动力之一。所以必须不断呵护，呵护到老才对。</p>
<p>然而，就是这个如此金贵的东西，也会成为拖累；而且，若是真的被它拖累，那么最终真的会感觉非常遗憾，被好东西拖累 —— 太可惜了。</p>
<p>刚才所描述的，还只不过是两个小时而已的 “损失”。事实上，被注意力漂移所拖累的人，损失肯定远不止如此。在做 “工程” 或者 “项目” 的时候 —— 尤其是那种非实物类的工程或项目，比如，写个书，写个软件之类的 —— 注意力漂移导致的结果就是：</p>
<blockquote>
<p>时间不断流逝，可是工程却永远没有结果。</p>
</blockquote>
<p>这种损失，完全是任何正常人都没办法承受的…… 这话其实并不准，因为事实上据我观察，绝大多数人受到这种拖累的结果，自己其实无法想象 —— 因为永远没有完成过什么项目，永远没有完成过什么工程，又如何知道自己损失的究竟是什么呢？</p>
<p>到今天为止，我自己依然还是个需要不断与 “注意力漂移” 争斗的人 —— 许多年前，我注意到这个现象的时候，经过思考，就接受了一个事实：</p>
<blockquote>
<p>注意力漂移不是能杜绝的现象，但必须在关键时刻有所应对……</p>
</blockquote>
<p>如果当年的我没认真想过这事，没思索出对策，那么后来的我也不可能写那么多书，转行那么多次，自学那么多大大小小的技能…… 当然，各位读者也完全看不到现在正在阅读的文字 —— 因为它们不可能被完整地写出来，甚至干脆就不应该存在。</p>
<p>在罗列并比较众多策略之后，我选了一个看起来最不相干，却最本质的策略：</p>
<blockquote>
<p><strong>把 “全面完整” 放到最高优先级。</strong></p>
</blockquote>
<p>而后，这些年全靠这个策略挺了过来……</p>
<p>当我想做什么事的时候，或者想学什么东西的时候，我会投入一定的时间去琢磨，这个事或者这个东西，要做得全面完整，或者要学得全面完整，那都应该做什么呢？在思考如此严肃的问题的时候，我还是习惯用纸和笔，写写画画 —— 迄今为止没有找到合适的电子设备和软件替代。</p>
<p>我买笔记本，不是为了记笔记的，因为记笔记这个东西，实在是在电脑上做更方便，许多年前开始就是如此了。我的笔记本主要用来做一件事：</p>
<blockquote>
<p>罗列整理那些为了做到 “全面完整” 而必须优先做的事。</p>
</blockquote>
<p>用列表也好、或者用图表也罢，反正都是要不断整理修订的，而它的存在，给了我一个优先级：</p>
<blockquote>
<p>除了这上面罗列的这些东西之外，在当前时间段，别的都不如它们重要。</p>
</blockquote>
<p>一旦发现自己的注意力没有集中在这上面的关键之时，一旦发现自己的注意力已经漂移到其它当前并不重要的事项上，就马上纠正。</p>
<p>谁都知道应该先做重要且紧急的事情，可问题在于，如何判断 “是否重要” 呢？<strong>全面完整</strong>这四个字就会给我指引。</p>
<p>一方面，是用全面完整来保持自己对重要事情的关注，另外一方面，还需要提高对抗<strong>不相关完美诱惑</strong>的能力。十年前，我写《<a href="https://github.com/xiaolai/time-as-a-friend" target="_blank" rel="noopener">把时间当作朋友</a>》的时候，还把这东西叫做 “脆弱的完美主义倾向”，现在我已经把这个概念升级了 —— 因为更准确地讲，那不是 “完美主义者的脆弱”，那是 “能力不及格者” 的 “轻重不分”。</p>
<p>早些年，我跟很多人一样痴迷于电脑这个东西，也跟很多人那样，用 Windows 惯出来了坏毛病 —— 动不动就重装系统…… 重装系统很浪费时间的，但那时也不知道为什么总是忍不住去干那事，哪怕有些小毛病，马上就受不了，弄的好像重装一个干净的操作系统会让自己的世界焕然一新一样。</p>
<p>再后来就明白了，这绝对就是<strong>自己的毛病 —— 做事不分轻重</strong>。</p>
<p>说实话，这也不是自己想明白的 —— 我没那么聪明。是因为遇到了一个高人。他的电脑桌面上，乱七八糟摆满了各种图标，从不整理。我问他这不影响效率吗？他说，明明有搜索你不用，到底是谁效率低下？我被问愣了，无言以对。</p>
<p>我又发现他根本没有装杀毒软件…… 我问为什么？他说，“养几个虫子玩玩也没什么不好……” 不过，他转念又告诉了我他的思考。他说，只要平时习惯好，病毒进来了也没啥可偷的，但更为关键的是，他用电脑是干活的，而不是干杀毒的活的…… 脑子如此清楚，让我自愧不如。</p>
<p>但学到了。</p>
<p>虽然我还是做不到桌面上图标很乱，虽然我是因为改用了 Mac OS，所以不装杀毒软件，但注意力要放到应该放的地方，这事我记住了，牢牢记住，从此之后许多年，从未忘过。每次发现自己轻重不分的时候，就会想起他，然后就改过自新。</p>
<h1 id="如何成为优秀沟通者"><a href="#如何成为优秀沟通者" class="headerlink" title="如何成为优秀沟通者"></a>如何成为优秀沟通者</h1><p>一般认为，“手艺人” 的普遍特征之一就是缺乏沟通能力，或者沟通能力差 —— 也许是因为平时把所有的时间精力都投入到磨练手艺上去了罢。</p>
<p>但这肯定不是最主要的原因。你看手艺不怎么样的人沟通能力更差；手艺顶级的人却常常反过来沟通能力很强很强…… 为什么呢？</p>
<p>所以，最核心的理由，应该是一个人最基本的选择而已：</p>
<blockquote>
<p>看一个人是否重视沟通能力。</p>
</blockquote>
<p>因为若是一个人重视沟通能力，那么，他就自然而然地会想办法去进行刻意练习。如果他本人并不重视沟通能力，那么，自然就没有任何时间精力投入在这方面，结果就非常自然而然了。</p>
<p>非常遗憾，绝大多数人对沟通能力的重视远远不够 —— 他们也不是不重视，就是重视的程度实际上太差了。别说双向沟通了，即便是单向沟通，向别人问个问题这么 “简单” 的事，其实也需要 “学” 与 “练” —— <a href="Part.3.G.the-golden-age-and-google.md">之前提到过</a>的文章，事实上一定有读者并没有去认真阅读：</p>
<blockquote>
<p>…… 作为一个有素养的自学者，有一篇文章必须精读：</p>
<blockquote>
<p><a href="https://github.com/selfteaching/How-To-Ask-Questions-The-Smart-Way" target="_blank" rel="noopener">How To Ask Questions The Smart Way</a></p>
</blockquote>
<p>这里还有 John Gordon（王渊源）同学录制的英文朗读版：</p>
<blockquote>
<p><a href="https://github.com/selfteaching/How-To-Ask-Questions-The-Smart-Way" target="_blank" rel="noopener">https://github.com/selfteaching/How-To-Ask-Questions-The-Smart-Way</a></p>
</blockquote>
</blockquote>
<p>经过多次尝试就知道了，连 “描述清楚自己的问题” 都不是一件很容易做得足够清楚、足够好的事呢。</p>
<p>对沟通能力进行 “刻意练习” 的最佳方式是什么呢？其实还是<a href="Part.3.E.to-be-thorough.md">你已经知道的</a>：</p>
<blockquote>
<p><strong>教是最好的学习方法</strong></p>
</blockquote>
<p>讲课、写教程，甚至写书 —— 这是最高效的提升沟通能力的刻意练习手段。</p>
<p>人们常说，“杀鸡焉用宰牛刀”…… 在我看来，既然如此，备上一把宰牛刀挺好的，平时宰牛就用宰牛刀，备不住哪天需要杀鸡的时候，并不需要非得换把刀才行，依然可以用那把宰牛刀……</p>
<p>讲演能力、写作能力，其实同样也是手艺而已，但它们也确实是很必要的手艺。尤其是，具备这两项手艺的人，在现在这样的社会里收入一定不差，不信你就观察一下身边的世界、你的眼界可以触达的人群。</p>
<p>这两个手艺若比作宰牛刀的话，则日常生活里与单人沟通，只不过是杀鸡而已 —— 哈，这个类比真是不能说给沟通对象听，实在有太大的误会可能性。然而，说正经的，其实这也是为什么 “教师” 这个行业的人有不少能够跑出来成为优秀创业者、优秀投资人的原因之一。</p>
<p>当然，绝大多数连一门手艺都没有弄明白的初学者，阅读以下内容时，会觉得 “与当前的自己没关系”…… 不过，请注意，这绝对是 “<a href="Part.3.D.indispensable-illusion.md">刚需幻觉</a>”，千万不要被它误导。</p>
<p>已经说了无数遍了：绝大多数手艺都是这样的：</p>
<blockquote>
<p>原理很简单，精湛与否取决于重复的次数。</p>
</blockquote>
<p>哼，这句话不就是卖油翁说的吗？“无他，唯手熟尔” —— 是哦，卖油翁如是说。</p>
<p>以下，让我从入门开始讲起，而后步入进阶，最后到达高级……</p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="内容第一"><a href="#内容第一" class="headerlink" title="内容第一"></a>内容第一</h3><p>无论是平日里讲话、还是台上讲课，抑或是写篇文章、写本书，永远都是内容第一，至于形式，并非不重要，但绝对不能喧宾夺主。</p>
<p>通常，我们用 “干货” 来描述内容的重要性。第一步就是准备干货，至于修辞啊、笑点啊、酷炫幻灯片啊等等等等，都必须是次要的，否则就是喧宾夺主。干货不够好，其它的做得越多、越好，最终越是容易露怯 —— 这很可怕。</p>
<p>所以，在你还没有确定自己值得讲、别人值得听的内容的情况下，就去学习如何制作幻灯片，在我看来完全是浪费时间。</p>
<p>使用工具的技巧之一，就是用最朴素的方法使用最好的工具，这样成本最低效果最好。所以，我在讲课、讲演的时候，通常就只用最简单的模版，空白、单色背景那种，而后一页里只写一句话 —— 就是接下来三五分钟里我要讲的重点（甚至干脆只是标题）…… 这样的幻灯片，我只需要几分钟就能做完。而后，我的所有时间精力都放在精心准备内容上去了。高效、低成本。</p>
<p><a href="Part.3.H.prevent-focus-drifting.md">做事不分轻重</a>，这不对。</p>
<h3 id="内容质量"><a href="#内容质量" class="headerlink" title="内容质量"></a>内容质量</h3><p>内容第一，就决定了另外一个事实：</p>
<blockquote>
<p>不要讲或写你并不擅长的事。</p>
</blockquote>
<p>换句话说，不要分享你做得不够好、做得不够精的手艺。讲课也好、写书也罢，都是分享。分享的意思是说，你有别人想要的东西 —— 别人想要的，就是他们学不好、做不好的东西…… 若是你自己手艺不强，手艺不精，其实就没什么可分享的，就算你想 “分享”，别人也不要。</p>
<p>你值得讲，别人值得听的，一定是你做得比别人更好的东西，就这么简单。</p>
<p>所以，在自己磨练手艺的时候，可以同时磨练沟通能力；然而，一旦需要讲，需要写，那么就说明，你自己确信自己做得比别人更好、比别人更精，所以，你值得讲，所以，人家值得听。</p>
<p>一旦你确定自己有值得讲、人家值得听的东西，那么，内容质量的第一要素已经完成了，接下来要注意哪些呢？只需要关注最重要的三个方面就可以了：</p>
<blockquote>
<ul>
<li>重点突出</li>
<li>例证生动</li>
<li>消除歧义</li>
</ul>
</blockquote>
<p>首先，“重点突出”，是最简单朴素、成本最低的 “优秀结构”。</p>
<p>既然是沟通，就要了解对方。在绝大多数情况下，对方想要的才是重点。</p>
<p>可问题在于，我们平日里面对单个人的时候都觉得 “了解对方很困难”，我们又如何判断 “一个群体” 呢？与很多人想象得相反，判断群体远比判断个体容易得多…… 因为你可以用粗暴分类，比如，你把听众或读者划分为 “小白” 和 “专家”，那你就知道了，你面对的群体中，更可能 “大部分是小白，小部分是专家”。于是，你就可以思考，“小白们最想知道的是什么？”，“专家们最重视的是什么？”，于是，你就可以在脑子里对所谓的 “重点” 有应对策略。</p>
<p>再比如说，你可以 “粗暴” 地把群体分为友善者和刺儿头两种。有经验的老师，都会专门准备 “针对刺儿头” 的内容，因为，人群中永远存在刺儿头 —— 至少一个，所以，在现场，必须要有应对他们的策略。比如，当一个刺儿头说了一句蛮不讲理却引发哄堂大笑的话，你怎么办？每个人的策略不同，但你必须找到属于你的最佳策略。</p>
<p>进而，在找到重点之后，紧接着必须要做到的一步就是 “例证生动”。寻找好例子，是需要很多时间精力的事情 —— 从来就没有任何 “信手拈来” 的生动例子。信手拈来，是读者或者听众的感觉而已，对你来说，肯定是举重若轻的 —— 你明明是在举重，却被认为 “如若举轻”。在第一部分，<a href="Part.1.E.7.files.md">讲文件的那一章</a>里，我举了个 “我自己费尽心机找好例子” 的例子，相信你读过之后，一定有所感触。</p>
<p>最后一步，就是在前两步都完成之后，反复确认一件事情，消除<strong>一切</strong>歧义。这是真功夫，因为这东西很难把自己关在屋子里自顾自练成。并且，每个人有自己的 “容易引发误解” 的特殊属性，大家各不相同 —— 于是，只能靠自己探索。</p>
<p>无论如何都不能骂听众读者傻逼，他们的所有看起来傻逼的反应，都是你所说、你所写引发的 —— 这是百分之百清楚无误的事实。当年我写博客的时候，决不删除任何留言。其中最大的一个理由就是，无论那留言显得多么荒谬，甚至干脆是谩骂，都值得我认真思考：</p>
<blockquote>
<p>我到底说什么了？居然引来这种反应？！</p>
</blockquote>
<p>看多了，思考多了，你就有你自己的策略了。</p>
<h3 id="内容组织"><a href="#内容组织" class="headerlink" title="内容组织"></a>内容组织</h3><p>只有一个重点的时候，其实并不需要组织；但若是有一个以上的重点，那么这些重点之间会产生逻辑关系：</p>
<blockquote>
<ul>
<li>并列</li>
<li>递进</li>
<li>转折</li>
</ul>
</blockquote>
<p>这是上中学的时候，所有人在语文课上都学习并掌握了的知识 —— 现在终于需要 “活学活用” 了。</p>
<p>在讲演、讲课、写教程、写非小说类书籍的时候，最有效的组织方式竟然是最简单的，并且只有一个：</p>
<blockquote>
<p><strong>层层递进</strong></p>
</blockquote>
<p>你有两个重点需要分享，那么把更重要的那个重点放在后面；你有三个重点要分享，那么就把最重要的放在最后面…… 无论你有多少个重点，都按这种方式排列，准没错！</p>
<p>并且，另外一个建议是：</p>
<blockquote>
<p><code>3</code> 是重点数量的极限</p>
</blockquote>
<p>如果你必须有 <code>11</code> 个重点，那怎么办？那就把它们分到最多 3 个分组中，比如，像当前文章这样，“入门”、“进阶”、“高级”……</p>
<p>另外一个策略，是与 “递进” 的逻辑关系组合使用的 —— 你要区分针对你所谓的重点，对方的已知状态。大家都知道的，何必当作重点？于是，未知程度最高的，放在未知程度不那么高的重点后面。</p>
<p>这都是听起来无比简单，甚至好像 “无需讲述” 的 “重点”，但若是你多观察一下周遭的世界，你就明白了，很多人可能并不是不知道这些方法，但不知道为什么，他们就是不去应用这么简单有效的方法，也是怪得很！</p>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>当入门的手段都已经熟练了，就可以做很多所谓 “锦上添花” 的事情。锦上添花据说有很多种手段，比如，制造笑点啊，使用炫酷的幻灯片啊等等…… 但我只想给你讲一个学会了就够用，却也是最简单、最直接，然而又最有效的手段：</p>
<blockquote>
<p><strong>输送价值观</strong></p>
</blockquote>
<p>事实上，你可以把当前这本 “书” 当作一个巨大且又生动的例子：</p>
<blockquote>
<p>你把李笑来想象成一位在某个学校里为学生讲编程课的老师。那么，你就可以把当前这本书当作 “李笑来的讲义”…… 也许我和学生手里都拿着另外一本更著名的计算机专家所著的编程入门书籍，然而，我的讲义，就是按照我的顺序、我的内容编排来讲述的。</p>
</blockquote>
<p>事实上我在写这本书的时候，从某个层面上来看，真的写的就是 “Python 官方文档” 以及 “Python 官方教程” 的辅助讲义，写作目标如此，写作方式亦如是。</p>
<p>那我做了什么最重要的事情呢？</p>
<blockquote>
<p>我向我的群体输送了我觉得更有意义的价值观：</p>
<blockquote>
<p>自学是门手艺……</p>
</blockquote>
</blockquote>
<p>当年我在学校里讲英语课的时候，除了讲英语本身之外，我输送的价值观是：</p>
<blockquote>
<p>能管理好自己的时间的人，学英语学起来更容易……</p>
</blockquote>
<p>后来，这一部分单独被提取出来，在我离开那所学校之后，写成了长销书，《<a href="https://github.com/xiaolai/time-as-a-friend" target="_blank" rel="noopener">把时间当作朋友</a>》—— 你看，是一样的道理。</p>
<p>而所谓的价值观，定义很简单：</p>
<blockquote>
<p>你的价值观，就是你认为什么比什么<strong>更重要</strong>。</p>
</blockquote>
<p>价值观可大可小。大到集体利益与个人利益之间的比较，小到自学中 “全面” 压倒一切…… 然而，这世界总有独立于任何人存在的 “客观的价值比较”，只不过，每个人的 “价值观” 是自己的 “观点”。而我们每个人都希望自己的观点尽量摆脱自己的主观，尽量靠近那个 “客观的价值比较”…… 而一旦我们确定自己比原来的自己，甚至相对于其他人更进一步的时候，就很可能值得认真分享。</p>
<p>这个方法着实简单，然而却非常有效。这有点像什么呢？这有点像人家弹个吉他是 “蹦单音”，可你弹的却是 “曲调与和弦” 相辅相成的音乐…… 给你看一个 Youtube 上的《一生所爱》—— 这首曲子是我最喜欢的指弹版本 —— 这种弹法，不仅有旋律，还有和弦，并且还有打击乐器效果 “伴奏”：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> IFrame</span><br><span class="line"></span><br><span class="line">IFrame(<span class="string">'https://www.youtube.com/embed/AjWTop5O5jo?'</span>, width=<span class="string">'800'</span>, height=<span class="string">'450'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>&lt;iframe
    width=&quot;800&quot;
    height=&quot;450&quot;
    src=&quot;https://www.youtube.com/embed/AjWTop5O5jo?&quot;
    frameborder=&quot;0&quot;
    allowfullscreen
&gt;&lt;/iframe&gt;
</code></pre><p>最初的时候，有个看起来很难以跨越的障碍：</p>
<blockquote>
<p>感觉总是需要为自己塑造权威感 —— 否则就害怕没人听、没人看、没人信……</p>
</blockquote>
<p>这是很多人掉进去的坑。刚开始的时候，自己就不是权威啊！无论怎么装神弄鬼，事实上就不是么！</p>
<p>很多人没想明白，因为害怕没人听、害怕没人看、害怕没人信，所以就开始各种作弊，包括各种装神弄鬼，各种欺世盗名…… 这么做，暂时管用，长期来看，肯定是吃亏的。</p>
<p>因为作弊其实并不难，装神弄鬼其实并不难，欺世盗名其实并不难 —— 真正难的是长期作弊…… 长期欺骗有多难呢？难到根本不可能的地步。尤其是在寿命越来越久的今天。《庄子》里说，“寿则多辱”，今天有了新解释 —— 大家都寿命很长，所以别骗人，因为早晚会露馅……</p>
<p>花那么长时间作弊什么的，还不如花那么长时间磨练手艺，你想想看是不是这个道理？</p>
<p>给你看一段视频，加州伯克利大学的 Brian Harvey 在课堂上告诉学生，“为什么不要作弊” 的真正原因：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> IFrame</span><br><span class="line"></span><br><span class="line">IFrame(<span class="string">'https://www.youtube.com/embed/hMloyp6NI4E?'</span>, width=<span class="string">'800'</span>, height=<span class="string">'450'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>&lt;iframe
    width=&quot;800&quot;
    height=&quot;450&quot;
    src=&quot;https://www.youtube.com/embed/hMloyp6NI4E?&quot;
    frameborder=&quot;0&quot;
    allowfullscreen
&gt;&lt;/iframe&gt;
</code></pre><p>于是，千万别扭曲了自己，是什么样就是什么样，该怎么做就怎么做。而另外一件事是确定的：</p>
<blockquote>
<p>分享多了，就自然进步了……</p>
</blockquote>
<p>在求知的领域里，分享得越多，进步越快，且社交有效性提高得更多。</p>
<h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><p>无论什么手艺，大多数人都可以入门、少数人可以进阶…… 再往后，就通常被认为是个人 “造化” 了。</p>
<p>可这所谓的 “造化” 究竟指的是什么呢？</p>
<p>我觉得通过这本书，我可以向绝大多数普通人解释这个 “玄学词汇” 了……</p>
<blockquote>
<p>这里所谓的 “造化”，指的应该是一个人的 “融会贯通的能力” —— 有 “造化” 的人，不过是把大量其他领域里的技能、技巧、甚至手艺学来而后应用到自己的手艺之中……</p>
</blockquote>
<p>就这么简单。</p>
<p>有个特别好玩的例子。</p>
<p>现在大家已经熟悉了的吉他演奏中的 “指弹”（Percussive Guitar），可这种玩法在没有 Youtube 的时代里并不多见 —— 在我长大的年代里，甚至 “前所未闻”。不知道是谁，把打击乐器的手法融合到吉他演奏手法中去了，于是，在 Youtube 这样的视频工具出现之后，人们的 “见识” 成本降低了（过去也许要 “去西天取经才行”），很快就有人模仿，很快就有人更为擅长……</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> IFrame</span><br><span class="line"></span><br><span class="line">IFrame(<span class="string">'https://www.youtube.com/embed/nY7GnAq6Znw?'</span>, width=<span class="string">'800'</span>, height=<span class="string">'450'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>&lt;iframe
    width=&quot;800&quot;
    height=&quot;450&quot;
    src=&quot;https://www.youtube.com/embed/nY7GnAq6Znw?&quot;
    frameborder=&quot;0&quot;
    allowfullscreen
&gt;&lt;/iframe&gt;
</code></pre><p>有这种能力的人，普遍有两个特征：</p>
<blockquote>
<ul>
<li>他们自学很多看起来不相干的手艺</li>
<li>他们对自己的手艺充满尊重与热爱</li>
</ul>
</blockquote>
<p>我也只能猜个大概。这其中的第二个特征，很可能是第一个特征的根源，因为他们对自己的手艺充满了尊重与热爱，所以，他们追求全面，他们刻意练习，他们还刻意思考…… 由此引发了对一切可能与自己的手艺相关的东西都感兴趣 —— 虽然在外界看来那两样东西可能全无联系。于是，他们利用已经在自己的手艺中练就的自学能力，不断自学新的东西，不断 “发现” 所谓的 “新大陆”，不断用他们的所见所闻回过来锤炼或更新自己的手艺……</p>
<p>所以，弹钢琴或者弹吉他的也去学了打击乐器；讲课的人会去听相声专场，学习相声演员是如何抖包袱的；写书的人可能会像我琢磨 “取名” 的艺术 —— 甚至不惜去研究一下自己并不屑于相信的易经八卦；学会计的去研究了物理或者经济学；学编程的也去学了设计，学设计的也去学了编程；做前端的去学了后端，做后端的也学会了前端；做统计的学会了数据可视化…… 搞来搞去，计算机行业里有个著名的词汇诞生：全栈工程师。</p>
<p>其实，所有精湛的手艺人，都是<strong>全栈</strong>，不信你就仔细观察一下。</p>
<p>于是，所有在入门、进阶之后走得更远的手艺人，都明白且认同这个道理：</p>
<blockquote>
<p><strong>学无止境</strong></p>
</blockquote>
<p>于是，最后一个重要技巧，不仅仅是 “不断磨练当前的手艺”，还有就是<strong>不断向所有的手艺人学习</strong>。</p>
<p>再进一步，技巧没用了…… 想再进一步，靠的是另外一个层次的东西 —— 那就是尊重与热爱。</p>
<p>这么多年来，在互联网上我最喜爱的老师，是麻省理工大学的 Walter Lewin 教授。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.display <span class="keyword">import</span> IFrame</span><br><span class="line"></span><br><span class="line">IFrame(<span class="string">'https://www.youtube.com/embed/sJG-rXBbmCc?'</span>, width=<span class="string">'800'</span>, height=<span class="string">'450'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>&lt;iframe
    width=&quot;800&quot;
    height=&quot;450&quot;
    src=&quot;https://www.youtube.com/embed/sJG-rXBbmCc?&quot;
    frameborder=&quot;0&quot;
    allowfullscreen
&gt;&lt;/iframe&gt;
</code></pre><p>十多年前，MIT 出了一套 Open Course，在线的免费课程。授课老师绝大多数都是本校的著名教授 —— 在那么多课程里，我一下子就爱上了这位教授。建议你有时间把他的所有课程看完，虽然你可能觉得物理这东西你并不感兴趣 —— 可事实上，看完你就知道了，你只不过是运气不好，你从来没遇到过这么可爱牛逼的教授而已…… 在他身上，你可以学到无数，甚至是 “不可言说” 的技巧、秘密和手艺。</p>
<p>关键在于，你一定会非常生动地、深刻地体会到他对物理、他对授课的<strong>尊重和热爱</strong>。看过之后，你一定会跟我有一样的慨叹：“是哦，<strong>Love is the power.</strong>”</p>
<p>没有什么比 “热爱” 和 “尊重” 更为高级的了。就这样。</p>
<h1 id="自学者的终点"><a href="#自学者的终点" class="headerlink" title="自学者的终点"></a>自学者的终点</h1><p>…… 磨练自学手艺的你，早晚会遇到这种情况：</p>
<blockquote>
<p>必须学会一个没人教、没人带，甚至没有书可参考的技能。</p>
</blockquote>
<p>这也许是我自己能够想象到的自学者所能经历的最高境界吧，因为那么多年过去之后的我也只不过走到这个地方而已…… 许多年过去，我通过自学习得的没有人教、没有人带、甚至没有书可参考的技能，很拿得出手的只有两个而已：</p>
<blockquote>
<ul>
<li>制作长销书</li>
<li>区块链投资</li>
</ul>
</blockquote>
<p>先说说区块链投资。</p>
<p>2011 年，我开始投资比特币的时候，不像现在。现在你能在 Amazon 上找到一大堆书，给你讲区块链技术、区块链投资…… 2011 年的时候，互联网这本大书上，连篇像样的文章都几乎没有。</p>
<p>在这样的领域里成为专家，其实比外界想象得容易 —— 当然，无论什么，外界总是觉得很难。为什么比外界想象得更容易呢？因为大家都不懂，仅此而已。</p>
<p>所以，剩下的事情很简单：</p>
<blockquote>
<p>谁能持续研究谁就可能更先成为专家。</p>
</blockquote>
<p>到最后，还是一样的，决定因素在于有效时间投入，再次仅此而已。</p>
<p>了解我的人都知道，在知识技能的分享方面，我从来都没有 “藏着掖着” 的习惯。我说 “仅此而已” 的时候，那就是 “仅此而已”，没有任何其它保留。</p>
<p>说研读比特币白皮书，就真的研读，反复研读，每年都要重复若干遍 —— 有人问了，有那个必要吗？是哦，对我有没有那个必要，我自己说了算。并且，就算真有，告诉别人有什么用？对吧？</p>
<blockquote>
<p>这里是<a href="https://github.com/xiaolai/bitcoin-whitepaper-chinese-translation" target="_blank" rel="noopener">《比特币白皮书》我翻译的版本</a>。</p>
</blockquote>
<p>说投资就真的投资，不是 “买两个试试”、“买几个玩玩” —— 我的做法是<strong>重仓</strong>。持仓之后继续研究，和两袖清风地读书研读肯定不一样。有一个与我极端相反的例子。此人大名鼎鼎，是《精通比特币》（<a href="https://www.amazon.com/Mastering-Bitcoin-Programming-Open-Blockchain/dp/1491954388/" target="_blank" rel="noopener">Mastering Bitcoin</a>）的作者，Andreas M. Antonopoulos，与我同岁，也是 1972 年生人。</p>
<p>他也是国外公认的比特币专家，但他不是投资人 —— 他几乎没有比特币。2017 年牛市的时候，人们听说大神 Andreas M. Antonopoulos 竟然几乎没有比特币，大为惊讶，向他捐款总计 102 个比特币左右 —— 千万不要误会我，我没有任何鄙视他的意思。这不是我说说而已，我是用行动支持他的人。他的书，《精通比特币》的中文版，还是我组织人翻译的。</p>
<p>我只是说，我和他不一样的地方在于，在某些方面我比他更实在，这也是事实。我相信我在实际投资后，对比特币也好区块链也罢，理解力会更深一些，因为驱动力不一样么，多简单的道理。</p>
<p>然而，仅仅 “谁能持续研究谁就更可能先成为专家” 这一条，其实并不够完成 “学会一个没人教、没人带，甚至没有书可参考的技能”。</p>
<p>这么多年来，我能够 “学会一些没人教、没人带，甚至没有书可参考的技能”（比如赚钱这事就是如此），更多的时候仰仗的是一个我已经告诉过你的 “秘密”…… 也许你想不起来了，但我一说你就能 “发现” 其实你真的<a href="Part.2.D.deliberate-thinking.md">已经听我说过</a>：</p>
<blockquote>
<p><strong>刻意思考</strong>：这东西我<strong>还</strong>能用在哪儿呢？</p>
</blockquote>
<p>并且，我还讲过在自学编程的过程中，见识到的 MoSCoW Method 给我在写书方式上的影响。</p>
<blockquote>
<p>我写书就是这样的。在准备的过程中 —— 这个过程比绝大多数人想象得长很多 —— 我会罗列所有我能想到的相关话题…… 等我觉得已经再也没有什么可补充的时候，再为这些话题写上几句话构成的大纲…… 这时候就会发现很多话题其实应该是同一个话题。如此这般，一次扩张，一次收缩之后，就会进行下一步，应用 MoSCoW 原则，给这些话题打上标签 —— 在这过程中，总是发现很多之前感觉必要的话题，其实可以打上 <code>Won&#39;t have</code> 的标签，于是，把它们剔除，然后从 <code>Must have</code> 开始写起，直到 <code>Should have</code>，至于 <code>Could have</code> 看时间是否允许，看情况，比如，看有没有最后期限限制……</p>
<p>在写书这事上，我总是给人感觉很快，事实上也是，因为有方法论 —— 但显然，那方法论不是从某一本 “如何写书” 的书里获得的，而是从另外一个看起来完全不相关的领域里习得后琢磨到的……</p>
</blockquote>
<p>你看，把另外一个领域里的知识拿过来用，是在一个 “没人教、也没人带，甚至没有书籍可供参考” 的领域中，最基本的生存技巧。</p>
<p>再进一步，当我们在最开始的时候说，“尽量只靠阅读习得一项新技能” 的时候，有一个重点现在终于在之前的很多解释与讲解之后能说清楚了：</p>
<blockquote>
<p>我们并不是不要老师这个角色了，准确地讲，我们只不过是不再需要 “传统意义上的老师” 了而已。</p>
</blockquote>
<p>首先，我们把自己当作老师 —— 英文中，Self-teaching 这个词特别好，它描述得太准确了。很多的时候，想在身边找到好老师是很难的，甚至是不可能的。在这种情况下，我们没有别的选择，<strong>我们只能把自己当作老师去教自己</strong>。</p>
<p>其次，就算我们 100% 只依靠阅读，那内容不还是别人写的吗？写那内容的人，实际上就是老师。没错，书本，是历史上最早的远程教育形式，即便到今天也依然是最重要最有效的远程教学形式。阅读的好处在于，对老师的要求中没有地理位置的限制，若是能自由阅读英文，那就连国界限制都没有。“<strong>书中自有颜如玉</strong>” 这句话，显然是并不好色的人说的，因为他更爱书…… 这句话的意思其实是说：</p>
<blockquote>
<p>各路牛人都在书里……</p>
</blockquote>
<p>反正，写书的人群中，牛人比例相对较高，这是事实 —— 古今中外都一样。</p>
<p>进而，更为重要的是，一旦你把整个互联网当作一本大 “书”，把 Google 当作入口，实际发生的效果是：</p>
<blockquote>
<p>你把 “老师” 这个角色<strong>去中心化</strong>了……</p>
</blockquote>
<p>一方面 “老师” 这个角色的负担降低了，他们不用管你是谁，也不用管你怎么样了，他们该干嘛就干嘛；而另外一方面则对你更重要 —— 你学不同的东西，就可以找不同的老师；即便是相同的东西，你也可以找很多老师；对于任何一个老师，你都可以 “弱水三千只取一瓢”，也就是说，只挑他最厉害的部分去学…… 不就是多买几本书吗？不就是多搜索几次、多读一些文档吗？</p>
<p>最后，你竟然还有最厉害的一个小招数：</p>
<blockquote>
<p>无论学会什么，都要进一步<strong>刻意思考</strong>：这东西我<strong>还</strong>能用在哪儿呢？</p>
</blockquote>
<p>于是，你 “一下子” 就升级了 —— 用这样的方式，相对于别人，你最可能 “学会几乎任何一个没人教、没人带，甚至没有书可参考的技能”……</p>
<p>你看看自己的路径罢：从 “不得不把自己当作老师去教自己” 开始 —— 虽然起步是<strong>不得不</strong>，但这个 “不得不”，恰好是后来你变得更为强大的原因和起点…… 这就解释了为什么历史上有很多牛人的很多成就其实都是这样 “被迫” 获得的。</p>
<p>于是，我们终于可以好好总结一下了：</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/seflteaching-model.png?raw=true" alt></p>
<blockquote>
<ul>
<li>你一定要想办法启动自学，否则你没有未来；</li>
<li>你把自学当作一门手艺，长期反复磨练它；</li>
<li>你懂得学、练、用、造各个阶段之间的不同，以及针对每个阶段的对应策略；</li>
<li>面对 “过早引用” 过多的世界，你有你的应对方式；</li>
<li>你会 “囫囵吞枣”，你会 “重复重复再重复”，你深刻理解 “读书百遍其义自见”；</li>
<li>以后你最擅长的技能之一就是拆解拆解再拆解；</li>
<li>你用你的拆解手艺把所有遇到的难点都拆解成能搞定的小任务；</li>
<li>自学任何一门手艺之前你都不会去问 “有什么用”，而是清楚地知道，无论是什么只要学会了就只能也必然天天去用；</li>
<li>你没有刚需幻觉，你也没有时间幻觉，你更没有困难幻觉，反正你就是相对更清醒；</li>
<li>不管你新学什么手艺，你都知道只要假以时日你就肯定能做好，因为所有的手艺精湛，靠的只不过是充足的预算；</li>
<li>你知道如何不浪费生命，因为只要不是在刻意练习、不是在刻意思考，那就是在 “混时间”；</li>
<li>你总是在琢磨你能做个什么新作品；</li>
<li>你刻意地使用你的作品作为有效社交工具，也用作品去过滤无效社交；</li>
<li>你乐于分享，乐于阅读也更乐于写作 —— 因为这世界怎么帮助你的，你就想着要怎样回报；</li>
<li>你把全面和完整当作最高衡量标准，也用这个标准去克制、应对自己的注意力漂移；</li>
<li>你会不断自学新的手艺，因为你越来越理解单一技能的脆弱，越来越理解多项技能的综合威力；</li>
<li>你越来越依赖互联网，它是你最喜欢的 “书”，而 Google 是你最好的朋友 —— 他总是能帮你找到更好的老师；</li>
<li>偶尔，你会学会没人教、没人带、甚至没书可参考的手艺，别人都说你 “悟性” 高，可你自己清楚地知道那其实是怎么回事；</li>
<li>你越来越明白，其实没什么 “秘密”，越简单、越朴素的道理越值得重视；</li>
<li>你发现你用来思考的时间越来越多 —— 准确地讲，是 “琢磨”…… 只不过是因为你真会琢磨了 —— 你很清楚你应该花时间琢磨的是什么。</li>
</ul>
</blockquote>
<p>没有人教过我怎么写一本长销书（而不仅仅是畅销书），这显然是我通过自学习得的能力 —— 我也只能把自己当作老师教自己，这是不得已。然而，不得不的选择同样常常能给我带来好运…… 甚至，它也不是我通过阅读哪本书习得的能力 —— 因为这方面还真的没什么靠谱的书籍。然而，我竟然学会了 —— 靠什么？靠的就是上面说的那点事而已。</p>
<p>“秘密” 是什么？说出来后，你听起来肯定是感觉 “太简单了” 乃至于 “有点不像真的”…… 每次，我都很认真的问自己以下几个问题：</p>
<blockquote>
<ul>
<li>我要写的内容，的确是正确的吗？</li>
<li>我要写的内容，确实会对读者有用吗？</li>
<li>有什么内容是必须有的、应该有的？</li>
<li>我写的这个内容，十年后人们再看，还会觉得跟新的一样有用嘛？</li>
<li>我的书名，就那么放在那里，会直接让买家产生不由自主购买的吸引力吗？</li>
</ul>
</blockquote>
<p>一旦这几个问题我有了清楚的答案，我就知道，我有能力制作一本新的长销书了 —— 真的没有什么别的 “秘密”。</p>
<p>在《通往财富自由之路》中，我分享过以下内容：</p>
<blockquote>
<p>我认为一个人的自学能力（当时还在用 “学习能力” 这个词）分为三个层次：</p>
<ol>
<li>学会有人手把手教授的技能</li>
<li>学会书本上所教授的技能</li>
<li>学会没有人能教授的技能</li>
</ol>
</blockquote>
<p>这一次，我无非是把后两个层面用一个特大号的实例掰开了揉碎了讲清楚而已。</p>
<p>到最后，<strong>没什么不能自学的，反正都只不过是手艺</strong> —— 只不过，我们每个人都受限于自己的时间精力而已。所以，若是你正在读高一，正在读大一，那就好好珍惜自己有机会可以<strong>随意设置充裕预算</strong>的时光罢。若是你已为人父母，那就想办法用自己的行动影响下一代罢。然而，其实更为重要的是，无论什么时候，都要这么想：</p>
<blockquote>
<p>若是还有很长的未来，现在真不算晚……</p>
</blockquote>
<p>自学不过是一门手艺，而且还是谁都能掌握的。不要 “试试” 而已，而是 “直接开干” —— 这样才好。</p>
<p>最后还有个需要补充的是：很多人崇尚 “刻苦”，并且刻意强调其中的 “苦” —— 古训中所谓的 “吃得苦中苦，方为人上人” —— 这一点我并不认同，而且还是深刻地不认同。</p>
<p>我的观察是，所谓的 “苦”，是那些完全不会自学的人对自学者的所作所为的错误理解。</p>
<p>自学一点都不苦，道理也很简单：</p>
<blockquote>
<p>因为自学者是自发去学的，<strong>原动力在于自己</strong>。而不像其他人，是被动地学，原动力并非在于自己。</p>
</blockquote>
<p>由于原动力在于自己，遇到困难时，当然同样苦恼；可不一样的是，有持续的原动力去克服那些困难，于是，总是在不断克服困难之后获得更大的愉悦、更大的满足感。</p>
<p>所以，“刻”，我们很认同，刻意地练习、刻意地思考，刻意地保持好奇心，刻意地去学习一些看起来与当前所掌握的手艺完全不相干的知识…… 至于 “苦” 么，那是别人的误解，我们自己开心着呢 —— 无所不在、无处诉说的幸福。</p>
<p><strong>人生苦长，无需惊慌。</strong></p>
<p>祝你好运！</p>
<p style="text-align: right"><strong>李笑来</strong></p><br><p style="text-align: right">初稿完成于 <em>2019</em> 年 <em>2</em> 月 <em>27</em> 日</p>

<h1 id="the-craft-of-selfteaching"><a href="#the-craft-of-selfteaching" class="headerlink" title="the-craft-of-selfteaching"></a>the-craft-of-selfteaching</h1><blockquote>
<p>One has no future if one couldn’t teach themself<a href="#fn1" name="fn1b"><sup>[1]</sup></a>.</p>
</blockquote>
<h1 id="自学是门手艺-1"><a href="#自学是门手艺-1" class="headerlink" title="自学是门手艺"></a>自学是门手艺</h1><blockquote>
<p>没有自学能力的人没有未来</p>
</blockquote>
<p><strong>作者：李笑来</strong></p>
<p>特别感谢<strong>霍炬</strong>（<a href="https://github.com/virushuo" target="_blank" rel="noopener">@virushuo</a>）、<strong>洪强宁</strong>（<a href="https://github.com/hongqn" target="_blank" rel="noopener">@hongqn</a>) 两位良师诤友在此书写作过程中给予我的巨大帮助！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pseudo-code of selfteaching in Python</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">teach_yourself</span><span class="params">(anything)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> create():</span><br><span class="line">        learn()</span><br><span class="line">        practice()</span><br><span class="line">    <span class="keyword">return</span> teach_yourself(another)</span><br><span class="line"></span><br><span class="line">teach_yourself(coding)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有兴趣帮忙的朋友，请先行阅读 <a href="02.proof-of-work.md">如何使用 Pull Request 为这本书校对</a>。</p>
</blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><blockquote>
<ul>
<li><a href="01.preface.md">01.preface（<strong>前言</strong>）</a></li>
<li><a href="02.proof-of-work.md">02.proof-of-work（<strong>如何证明你真的读过这本书？</strong>）</a></li>
<li><a href="Part.1.A.better.teachyourself.md">Part.1.A.better.teachyourself（<strong>为什么一定要掌握自学能力？</strong>）</a></li>
<li><a href="Part.1.B.why.start.from.learning.coding.md">Part.1.B.why.start.from.learning.coding（<strong>为什么把编程当作自学的入口？</strong>）</a></li>
<li><a href="Part.1.C.must.learn.sth.only.by.reading.md">Part.1.C.must.learn.sth.only.by.reading（<strong>只靠阅读习得新技能</strong>）</a></li>
<li><a href="Part.1.D.preparation.for.reading.md">Part.1.D.preparation.for.reading（<strong>开始阅读前的一些准备</strong>）</a></li>
<li><a href="Part.1.E.1.entrance.md">Part.1.E.1.entrance（<strong>入口</strong>）</a></li>
<li><a href="Part.1.E.2.values-and-their-operators.md">Part.1.E.2.values-and-their-operators（<strong>值及其相应的运算</strong>）</a></li>
<li><a href="Part.1.E.3.controlflow.md">Part.1.E.3.controlflow（<strong>流程控制</strong>）</a></li>
<li><a href="Part.1.E.4.functions.md">Part.1.E.4.functions（<strong>函数</strong>）</a></li>
<li><a href="Part.1.E.5.strings.md">Part.1.E.5.strings（<strong>字符串</strong>）</a></li>
<li><a href="Part.1.E.6.containers.md">Part.1.E.6.containers（<strong>数据容器</strong>）</a></li>
<li><a href="Part.1.E.7.files.md">Part.1.E.7.files（<strong>文件</strong>）</a></li>
<li><a href="Part.1.F.deal-with-forward-references.md">Part.1.F.deal-with-forward-references（<strong>如何从容应对含有过多 “过早引用” 的知识？</strong>）</a></li>
<li><a href="Part.1.G.The-Python-Tutorial-local.md">Part.1.G.The-Python-Tutorial-local（<strong>官方教程：The Python Tutorial</strong>）</a></li>
<li><a href="Part.2.A.clumsy-and-patience.md">Part.2.A.clumsy-and-patience（<strong>笨拙与耐心</strong>）</a></li>
<li><a href="Part.2.B.deliberate-practicing.md">Part.2.B.deliberate-practicing（<strong>刻意练习</strong>）</a></li>
<li><a href="Part.2.C.why-start-from-writing-functions.md">Part.2.C.why-start-from-writing-functions（<strong>为什么从函数开始？</strong>）</a></li>
<li><a href="Part.2.D.1-args.md">Part.2.D.1-args（<strong>关于参数（上）</strong>）</a></li>
<li><a href="Part.2.D.2-aargs.md">Part.2.D.2-aargs（<strong>关于参数（下）</strong>）</a></li>
<li><a href="Part.2.D.3-lambda.md">Part.2.D.3-lambda（<strong>化名与匿名</strong>）</a></li>
<li><a href="Part.2.D.4-recursion.md">Part.2.D.4-recursion（<strong>递归函数</strong>）</a></li>
<li><a href="Part.2.D.5-docstrings.md">Part.2.D.5-docstrings（<strong>函数的文档</strong>）</a></li>
<li><a href="Part.2.D.6-modules.md">Part.2.D.6-modules（<strong>保存到文件的函数</strong>）</a></li>
<li><a href="Part.2.D.7-tdd.md">Part.2.D.7-tdd（<strong>测试驱动的开发</strong>）</a></li>
<li><a href="Part.2.D.8-main.md">Part.2.D.8-main（<strong>可执行的 Python 文件</strong>）</a></li>
<li><a href="Part.2.E.deliberate-thinking.md">Part.2.E.deliberate-thinking（<strong>刻意思考</strong>）</a></li>
<li><a href="Part.3.A.conquering-difficulties.md">Part.3.A.conquering-difficulties（<strong>战胜难点</strong>）</a></li>
<li><a href="Part.3.B.1.classes-1.md">Part.3.B.1.classes-1（<strong>类 —— 面向对象编程</strong>）</a></li>
<li><a href="Part.3.B.2.classes-2.md">Part.3.B.2.classes-2（<strong>类 —— Python 的实现</strong>）</a></li>
<li><a href="Part.3.B.3.decorator-iterator-generator.md">Part.3.B.3.decorator-iterator-generator（<strong>函数工具</strong>）</a></li>
<li><a href="Part.3.B.4.regex.md">Part.3.B.4.regex（<strong>正则表达式</strong>）</a></li>
<li><a href="Part.3.B.5.bnf-ebnf-pebnf.md">Part.3.B.5.bnf-ebnf-pebnf（<strong>BNF 以及 EBNF</strong>）</a></li>
<li><a href="Part.3.C.breaking-good-and-bad.md">Part.3.C.breaking-good-and-bad（<strong>拆解</strong>）</a></li>
<li><a href="Part.3.D.indispensable-illusion.md">Part.3.D.indispensable-illusion（<strong>刚需幻觉</strong>）</a></li>
<li><a href="Part.3.E.to-be-thorough.md">Part.3.E.to-be-thorough（<strong>全面 —— 自学的境界</strong>）</a></li>
<li><a href="Part.3.F.social-selfteaching.md">Part.3.F.social-selfteaching（<strong>自学者的社交</strong>）</a></li>
<li><a href="Part.3.G.the-golden-age-and-google.md">Part.3.G.the-golden-age-and-google（<strong>这是自学者的黄金时代</strong>）</a></li>
<li><a href="Part.3.H.prevent-focus-drifting.md">Part.3.H.prevent-focus-drifting（<strong>避免注意力漂移</strong>）</a></li>
<li><a href="Q.good-communiation.md">Q.good-communiation（<strong>如何成为优秀沟通者</strong>）</a></li>
<li><a href="R.finale.md">R.finale（<strong>自学者的终点</strong>）</a></li>
<li><a href="S.whats-next.md">S.whats-next（<strong>下一步干什么？</strong>）</a></li>
<li><a href="T-appendix.editor.vscode.md">T-appendix.editor.vscode（<strong>Visual Studio Code 的安装与配置</strong>）</a></li>
<li><a href="T-appendix.git-introduction.md">T-appendix.git-introduction（<strong>Git 简介</strong>）</a></li>
<li><a href="T-appendix.jupyter-installation-and-setup.md">T-appendix.jupyter-installation-and-setup（<strong>Jupyterlab 的安装与配置</strong>）</a></li>
<li><a href="T-appendix.symbols.md">T-appendix.symbols（<strong>这些符号都代表什么？</strong>）</a></li>
</ul>
</blockquote>
<h2 id="关于"><a href="#关于" class="headerlink" title="关于 "></a>关于 <figure class="highlight plain"><figcaption><span>文件转换为 ```.md``` 文件的备注：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```bash</span><br><span class="line"># 需提前安装 nbconvert 插件，Terminal 下执行：</span><br><span class="line">$ jupyter nbconvert --to markdown *.ipynb</span><br><span class="line"></span><br><span class="line">而后将所有 `.md` 文件移到 `markdown/` 目录之下 —— 除 `README.md` 文件之外</span><br><span class="line"></span><br><span class="line">`README.md` 文件复制一份到 `markdown/` 目录之下，而后编辑为当前文件</span><br><span class="line"></span><br><span class="line"># 需使用 VSCode 批量 Find and Replace:</span><br><span class="line">将所有 (https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/ 替换为 (https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/</span><br><span class="line">将所有 (Part.1.A.better.teachyourself_files/ 替换为 (https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/</span><br><span class="line">将所有 (Part.1.E.6.containers_files/ 替换为 (https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/</span><br><span class="line">将所有 ```\n\n 替换为 ```\n</span><br><span class="line">将所有	\n\n```	替换为 \n</span><br></pre></td></tr></table></figure></h2><p>将所有 .ipynb) 替换为 .md)</p>
<p><code>Part.1.E.3.controlflow.md</code> 文件中有过长的 output 需要编辑<br><code>Part.1.E.7.files.md</code> 文件中有过长的 output 需要编辑<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-----</span><br><span class="line"></span><br><span class="line">推荐读者在自己的浏览器上安装 [Stylus](https://github.com/openstyles/stylus) 这类终端 CSS 定制插件，Chrome/Firefox/Opera 都支持 Stylus 插件。以便拥有更好的阅读体验。以下 gif 图片展示的是使用自定义 css 前后的效果：</span><br><span class="line"></span><br><span class="line">&gt; ![](https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/github-markdown-style.gif?raw=true)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">我用的 Stylus 定制 CSS（针对 github.com）是这样的：</span><br><span class="line"></span><br><span class="line">```css</span><br><span class="line">.markdown-body &#123;font-family: &quot;PingFang SC&quot;;&#125;</span><br><span class="line">strong &#123;color:#6392BF;&#125;</span><br><span class="line">em &#123;color: #A9312A; font-style: normal !important;&#125;</span><br><span class="line">table &#123;font-size: 95% !important;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.CodeMirror, pre &#123;font-size: 90%;&#125;</span><br><span class="line">pre &#123;</span><br><span class="line">    padding: 10px 25px;</span><br><span class="line">    background-color: #fafafa;</span><br><span class="line">    border-left: 4px solid #dadada;</span><br><span class="line">    border-radius: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pre code &#123;</span><br><span class="line">    background-color: #fafafa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h1 code,</span><br><span class="line">h2 code,</span><br><span class="line">h3 code,</span><br><span class="line">h4 code,</span><br><span class="line">p code, </span><br><span class="line">li code,</span><br><span class="line">blockquote p code, </span><br><span class="line">blockquote li code,</span><br><span class="line">td code &#123;</span><br><span class="line">    background-color: #f6f6f6;</span><br><span class="line">    font-size: 90%;</span><br><span class="line">    color:#2e2e2e;</span><br><span class="line">    padding: 4px 4px;</span><br><span class="line">    margin: 0 8px;</span><br><span class="line">    box-shadow: 0px 1px 2px 0px rgba(0,0,0,0.2);</span><br><span class="line">    border-radius: 4px;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我写的内容里，为了重点突出，特别定制了 <code>strong</code> 和 <code>em</code> 两个元素的显示，让它们以不同的颜色展示；又因为中文并不适合斜体展示，所以，把 <code>em</code> 的 <code>font-style</code> 设定为 <code>normal</code>……</p>
<hr>
<p>本书的版权协议为 <a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">CC-BY-NC-ND license</a>。</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/CC-BY-NC-ND.png?raw=true" alt="CC-BY-NC-ND"></p>
<hr>
<p><strong>脚注</strong></p>
<p><a name="fn1">[1]</a>：<a href="https://en.oxforddictionaries.com/usage/themselves-or-themself" target="_blank" rel="noopener">‘Themselves’ or ‘themself’?– Oxford Dictionary</a></p>
<p><a href="#fn1b"><small>↑Back to Content↑</small></a></p>
<h1 id="下一步干什么？"><a href="#下一步干什么？" class="headerlink" title="下一步干什么？"></a>下一步干什么？</h1><p>理论上，下一步你的选择很多。自学是门手艺，你可以用它去学任何你想要掌握的其它手艺。如果，你有意在编程这个领域继续深入，那么，以下就是一些不错的线索。</p>
<p>当然，最先应当做的是，去检查一下自己的 “突击” 的结果，去 Pythonbasics.org 做做练习：</p>
<blockquote>
<p><a href="https://pythonbasics.org/Exercises/" target="_blank" rel="noopener">https://pythonbasics.org/Exercises/</a></p>
</blockquote>
<p>除了我在这里介绍的之外，请移步 The Hitchhiker’s Guide to Python，它更为全面：</p>
<blockquote>
<p><a href="https://docs.python-guide.org/" target="_blank" rel="noopener">https://docs.python-guide.org/</a></p>
</blockquote>
<h2 id="Python-必读书籍"><a href="#Python-必读书籍" class="headerlink" title="Python 必读书籍"></a>Python 必读书籍</h2><p>无论学什么，一本书肯定不够，以下是学习 Python 的基本必读书籍：</p>
<blockquote>
<ul>
<li><a href="https://docs.python.org/3/tutorial/" target="_blank" rel="noopener">The Python Tutorial</a></li>
<li><a href="https://docs.python-guide.org/" target="_blank" rel="noopener">The Hitchhiker’s Guide to Python!</a></li>
<li><a href="http://greenteapress.com/wp/think-python-2e/" target="_blank" rel="noopener">Think Python: How to think like a computer scientist</a></li>
<li><a href="https://automatetheboringstuff.com" target="_blank" rel="noopener">Automate the Boring Stuff with Python</a></li>
<li><a href="https://effectivepython.com" target="_blank" rel="noopener">Effective Python</a></li>
<li><a href="https://www.amazon.com/Python-Cookbook-Recipes-Mastering-ebook/dp/B00DQV4GGY" target="_blank" rel="noopener">Python Cookbook</a></li>
<li><a href="https://www.amazon.com/Fluent-Python-Concise-Effective-Programming-ebook/dp/B0131L3PW4" target="_blank" rel="noopener">Fluent Python</a></li>
<li><a href="http://interactivepython.org/runestone/static/pythonds/index.html" target="_blank" rel="noopener">Problem Solving with Algorithms and Data Structures using Python</a></li>
<li><a href="https://www.amazon.com/dp/B00JVQ14UO/ref=dp-kindle-redirect?_encoding=UTF8&amp;btkr=1" target="_blank" rel="noopener">Mastering Object-oriented Python - Transform Your Approach to Python Programming</a></li>
</ul>
</blockquote>
<p>更多 Python 书籍：</p>
<blockquote>
<p><a href="https://pythonbooks.revolunet.com" target="_blank" rel="noopener">https://pythonbooks.revolunet.com</a></p>
</blockquote>
<p>千万别觉得多，只要真的全面掌握，后面再学别的，速度上都会因此快出很多很多……</p>
<h2 id="Python-Cheatsheet"><a href="#Python-Cheatsheet" class="headerlink" title="Python Cheatsheet"></a>Python Cheatsheet</h2><p>你已经知道了，这种东西，肯定是自己整理的才对自己真的很有用…… 不过，你也可以把别人整理的东西当作 “用来检查自己是否有所遗漏” 的工具。</p>
<p>网上有无数 Python Cheatsheets，以下是 3 个我个人认为相当不错的：</p>
<blockquote>
<ul>
<li><a href="https://gto76.github.io/python-cheatsheet/" target="_blank" rel="noopener">Comprehensive Python Cheatsheet</a></li>
<li><a href="https://github.com/ehmatthes/pcc/tree/master/cheat_sheets" target="_blank" rel="noopener">Python Crash Course - Cheat Sheets</a></li>
<li><a href="https://www.pythonsheets.com/" target="_blank" rel="noopener">Pysheeet</a></li>
</ul>
</blockquote>
<h2 id="Awesome-Python"><a href="#Awesome-Python" class="headerlink" title="Awesome Python"></a>Awesome Python</h2><p>Github 上的 “居民” 现在已经养成了一个惯例，无论什么好东西，他们都会为其制作一个 “Awesome …” 的页面，在里面齐心协力搜集相关资源。比如，你想学 Golang，那你去 Google 搜索 <a href="https://www.google.com/search?q=awesome+go" target="_blank" rel="noopener"><code>Awesome Go</code></a>，一定会给你指向到一个 Github 上的 “Awesome Go” 的页面……</p>
<p>以下是 Awesome Python 的链接：</p>
<blockquote>
<p><a href="https://github.com/vinta/awesome-python" target="_blank" rel="noopener">https://github.com/vinta/awesome-python</a></p>
</blockquote>
<h2 id="CS-专业的人都在学什么？"><a href="#CS-专业的人都在学什么？" class="headerlink" title="CS 专业的人都在学什么？"></a>CS 专业的人都在学什么？</h2><p>如果你真有兴趣把这门手艺学精，不妨看看 Computer Science 专业的人都在学什么……</p>
<p>下面这个链接值得认真阅读：</p>
<blockquote>
<p><a href="http://matt.might.net/articles/what-cs-majors-should-know/" target="_blank" rel="noopener">http://matt.might.net/articles/what-cs-majors-should-know/</a></p>
</blockquote>
<h2 id="全栈工程师路径图"><a href="#全栈工程师路径图" class="headerlink" title="全栈工程师路径图"></a>全栈工程师路径图</h2><p>既然学了，就肯定不止 Python —— 在扎实的基础之上，学得越多学得越快。以下是一个 “全栈工程师路径图”，作者是位迪拜的帅哥 <a href="https://github.com/kamranahmedse" target="_blank" rel="noopener">Kamran Ahmed</a>：</p>
<blockquote>
<p><a href="https://github.com/kamranahmedse/developer-roadmap" target="_blank" rel="noopener">https://github.com/kamranahmedse/developer-roadmap</a></p>
<p>Below you find a set of charts demonstrating the paths that you can take and the technologies that you would want to adopt in order to become a frontend, backend or a devops. I made these charts for an old professor of mine who wanted something to share with his college students to give them a perspective; sharing them here to help the community.</p>
<p>Check out my blog and say “hi” on Twitter.</p>
<p><strong>Disclaimer</strong></p>
<p>The purpose of these roadmaps is to give you an idea about the landscape and to guide you if you are confused about what to learn next and not to encourage you to pick what is hip and trendy. You should grow some understanding of why one tool would better suited for some cases than the other and remember hip and trendy never means best suited for the job</p>
</blockquote>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/intro.png?raw=true" alt="Web Developer Roadmap Introduction"></p>
<h2 id="Frontend-Roadmap"><a href="#Frontend-Roadmap" class="headerlink" title="Frontend Roadmap"></a>Frontend Roadmap</h2><p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/frontend.png?raw=true" alt="Frontend Roadmap"></p>
<h2 id="Back-end-Roadmap"><a href="#Back-end-Roadmap" class="headerlink" title="Back-end Roadmap"></a>Back-end Roadmap</h2><p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/backend.png?raw=true" alt="Back-end Roadmap"></p>
<h2 id="DevOps-Roadmap"><a href="#DevOps-Roadmap" class="headerlink" title="DevOps Roadmap"></a>DevOps Roadmap</h2><p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/devops.png?raw=true" alt="DevOps Roadmap"></p>
<p>路漫漫其修远兮……</p>
<p>但多有意思啊？这完全就是一场闯关游戏。</p>
<h1 id="Visual-Studio-Code-的安装与配置"><a href="#Visual-Studio-Code-的安装与配置" class="headerlink" title="Visual Studio Code 的安装与配置"></a>Visual Studio Code 的安装与配置</h1><p>官方文档请查询：</p>
<blockquote>
<p><a href="https://code.visualstudio.com/docs" target="_blank" rel="noopener">https://code.visualstudio.com/docs</a></p>
</blockquote>
<h2 id="允许命令行启动-VS-Code"><a href="#允许命令行启动-VS-Code" class="headerlink" title="允许命令行启动 VS Code"></a>允许命令行启动 VS Code</h2><p>使用快捷键 <code>⇧⌘p</code> 呼出 Command Palette，在其中输入 <code>shell command</code>，而后选中 <code>Install &#39;code&#39; command in PATH</code>。此后，就可以在 Terminal 命令行中使用 <code>code</code> 命令了。(Windows 系统安装 VS Code 时会自动配置好，并不需要此步骤）</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/vscode-shell.png?raw=true" alt></p>
<h2 id="选择-Python-解析器版本"><a href="#选择-Python-解析器版本" class="headerlink" title="选择 Python 解析器版本"></a>选择 Python 解析器版本</h2><p>使用快捷键 <code>⇧⌘p</code> 呼出 Command Palette，在其中输入 <code>select interpreter</code>，而后选中 <code>Python: Select Interpreter</code>。</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/vscode-select-python-version1.png?raw=true" alt></p>
<p>而后，在系统中已安装的若干个版本中选择你需要的那一个。MacOS 系统自带一个 Python 2.7，而我们安装的 Anaconda 为系统另外安装了一个 Python 3.7。</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/vscode-select-python-version2.png?raw=true" alt></p>
<h2 id="安装扩展"><a href="#安装扩展" class="headerlink" title="安装扩展"></a>安装扩展</h2><p>使用快捷键 <code>⇧⌘x</code> 呼出扩展面板。安装 anaconda 扩展，它会连带装上 python 扩展：</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/vscode-extensions.png?raw=true" alt></p>
<p>另外，为了输入方便，有两个扩展可选安装：</p>
<blockquote>
<ul>
<li>Tabout 有它之后，可以使用 TAB 键跳出光标后的括号、引号等等；</li>
<li>Sublime Text Keymap and Settings Importer 有它之后，可以在 VS Code 中使用 SublimeText 的快捷键，最重要的当属多光标编辑 <code>⇧⌘l</code>……</li>
</ul>
</blockquote>
<h2 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h2><p>专业编辑器最重要的功能之一，就是能够在你输入的时候它帮你做到 “自动补全”，通常使用的快捷键是 TAB 键 <code>⇥</code>。</p>
<p>TAB 键 <code>⇥</code> 触发的自动补全有两种：</p>
<blockquote>
<ul>
<li>当前文件中已有的字符串。比如，之前你输入过 <code>sum_of_word</code>；那么，之后，你就可以输入 <code>su</code> 或者干脆 <code>sow</code> 而后按 TAB 键 <code>⇥</code>，“自动补全” 功能会帮你完成输入 <code>sum_of_word</code></li>
<li>已有的 Snippets。比如，当你需要输入 <code>if ...: ...</code> 的时候，实际上当你输入 <code>if</code> 或者甚至 <code>i</code> 之后，你就可以用 TAB 键 <code>⇥</code>，“自动补全” 功能会为你 “自动完成” 语句块的输入。</li>
</ul>
</blockquote>
<p>字符串自动补全，使用的是所谓的 Fuzzy Match。输入 <code>sum_of_word</code> 中所包含的任意字符的任意组合（按顺序），它都会尽量去匹配；所以，<code>su</code> 和 <code>sow</code> 都可以匹配 <code>sum_of_word</code>，再比如，<code>rst</code> 可以匹配 <code>result</code>。</p>
<p>在 Snippet 自动补全的过程中，常常有若干个 “TAB Stop”，即，有若干个位置可以使用 TAB 键 <code>⇥</code>（或者，<code>Shift + ⇥</code>）来回切换；这时，第一种字符串自动补全的功能就失效了，如果需要使用字符串自动补全，那么需要按快捷键 ESC <code>⎋</code> 退出 Snippet 自动补全模式。</p>
<p>以下的 gif 文件演示的是以下代码的输入过程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_of_word</span><span class="params">(word)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> word:</span><br><span class="line">        sum += ord(char) - <span class="number">96</span></span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'results.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> results:</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'words_alpha.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> file:</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> file.readlines():</span><br><span class="line">            <span class="keyword">if</span> sum_of_word(word.strip()) == <span class="number">100</span>:</span><br><span class="line">                results.write(word)</span><br></pre></td></tr></table></figure>
<p>因为有这样的功能，所以你在输入程序的时候其实是非常从容的，可以很慢输入，边思考边输入…… 可实际上，完成速度却很快。</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/vscodedemo.gif?raw=true" alt></p>
<p>另外，SublimeText 的多光标输入是很多程序员爱不释手的功能，于是，各种编辑器里都有第三方写的 SublimeText Keymap 插件，连 Jupyterlab 都有：</p>
<blockquote>
<p><a href="https://github.com/ryantam626/jupyterlab_sublime" target="_blank" rel="noopener">https://github.com/ryantam626/jupyterlab_sublime</a></p>
</blockquote>
<h1 id="Git-简介"><a href="#Git-简介" class="headerlink" title="Git 简介"></a>Git 简介</h1><p>— You should’ve learned Git yesterday.</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/git-time-machine-cover.png?raw=true" alt></p>
<h2 id="内容目标"><a href="#内容目标" class="headerlink" title="内容目标"></a>内容目标</h2><p>再一次，这一篇内容的目标，依然不是 “教程”，而是 “教程” 的 “图例” —— 如果我们把真正的教程比喻成 “地图” 的话。最全面的 Git 教程在网上，<strong>Pro Git</strong>，是免费的 —— 把它反复阅读若干遍，理解完整：</p>
<blockquote>
<p><a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">https://git-scm.com/book/en/v2</a></p>
</blockquote>
<p>并且还有各种语言的翻译版本 —— 也包括中文。</p>
<h2 id="为什么你必须学会使用-Git？"><a href="#为什么你必须学会使用-Git？" class="headerlink" title="为什么你必须学会使用 Git？"></a>为什么你必须学会使用 Git？</h2><p>Git 是一个分布式版本控制软件 —— 听起来也许跟你没关系，但<strong>无论是谁</strong>，都会因为能够使用 Git 而节约时间、提高效率。进而，如果你居然没有一个活跃的 <a href="https://github.com" target="_blank" rel="noopener">Github</a> 账户，那么你正在错过人类史上前所未有的共同协作时代 —— 半点都没有夸张。同样提供 Git 工具云服务的还有 <a href="https://gitlab.com" target="_blank" rel="noopener">Gitlab</a>, <a href="https://bitbucket.org" target="_blank" rel="noopener">Bitbucket</a> 等等。</p>
<p>并且，<a href="https://github.com" target="_blank" rel="noopener">Github</a> 很可能是地球上第一个给人们提供 “<a href="Part.3.F.social-selfteaching.md">用作品社交</a>” 方式的平台，你若是不能参与其中，实在是太可惜了！</p>
<h2 id="从逻辑上理顺-Git-基本命令"><a href="#从逻辑上理顺-Git-基本命令" class="headerlink" title="从逻辑上理顺 Git 基本命令"></a>从逻辑上理顺 Git 基本命令</h2><p>Git 的作用，基本上可以被划分为三部分：</p>
<blockquote>
<ul>
<li>备份文件</li>
<li>跟踪文件变化</li>
<li>与他人协作共同操作文件</li>
</ul>
</blockquote>
<p>在一个 git 仓库中，总计有四个 “抽象层”，它们分别是：</p>
<blockquote>
<ul>
<li>upstream repository 保存在云端的仓库</li>
<li>local repository 本地仓库</li>
<li>staging area 缓存区</li>
<li>working directory 工作区</li>
</ul>
</blockquote>
<p>其中，<code>local repository</code> 和 <code>staging area</code> 这两个抽象层的数据，保存在 <code>working directory</code> 根目录下的一个隐藏目录 <code>.git/</code> 下；需要使用 <code>ls -a</code> 才能看到。</p>
<p>当你使用 <code>git init</code> 命令将一个本地文件夹 <code>working directory</code> 初始化为 <code>local repository</code> 的之后，该文件夹内部的结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">└── .git</span><br><span class="line">    ├── HEAD</span><br><span class="line">    ├── config</span><br><span class="line">    ├── description</span><br><span class="line">    ├── hooks</span><br><span class="line">    │   ├── applypatch-msg.sample</span><br><span class="line">    │   ├── commit-msg.sample</span><br><span class="line">    │   ├── fsmonitor-watchman.sample</span><br><span class="line">    │   ├── post-update.sample</span><br><span class="line">    │   ├── pre-applypatch.sample</span><br><span class="line">    │   ├── pre-commit.sample</span><br><span class="line">    │   ├── pre-push.sample</span><br><span class="line">    │   ├── pre-rebase.sample</span><br><span class="line">    │   ├── pre-receive.sample</span><br><span class="line">    │   ├── prepare-commit-msg.sample</span><br><span class="line">    │   └── update.sample</span><br><span class="line">    ├── info</span><br><span class="line">    │   └── exclude</span><br><span class="line">    ├── objects</span><br><span class="line">    │   ├── info</span><br><span class="line">    │   └── pack</span><br><span class="line">    └── refs</span><br><span class="line">        ├── heads</span><br><span class="line">        └── tags</span><br></pre></td></tr></table></figure>
<p>以下示意图中仅包含最基本的 Git 命令 —— 并且基本上都是独自使用 Git 时的常用命令。</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/git-command-relationships.png?raw=true" alt></p>
<p>在工作区 <code>working directory</code> 这个抽象层中，你完成各种日常工作，创建、编辑、删除…… 你可能需要用某个编辑器去修改文件，你也可能频繁使用各种 Bash 命令，如，<code>rm</code> <code>mkdir</code> <code>cp</code> <code>mv</code> 等等。</p>
<p>时不时，你可能会把一些处理完的文件 “加入缓存区”；等一个阶段的工作完成之后，你可能会把那些已经放入缓存区的文件<strong>提交</strong>到（commit）本地仓库；而后继续工作…… 根据情况，你也会将本地仓库的文件<strong>推到</strong>（push）云端，即，远端仓库。如果，你正在与他人协作，你也可能经常需要从云端<strong>下拉</strong>（pull）最新版本到本地。</p>
<h2 id="Git-的安装"><a href="#Git-的安装" class="headerlink" title="Git 的安装"></a>Git 的安装</h2><h3 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h3><p>Mac 的操作系统 Mavericks (10.9) 以上版本中都内建有 Git，你可以在 Terminal 中通过以下命令查看是否有 Git：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br><span class="line"><span class="built_in">which</span> git</span><br></pre></td></tr></table></figure>
<p>也可以通过 Homebrew 安装最新版本的 Git：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ruby -e <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span><br><span class="line">brew doctor</span><br><span class="line">brew install git</span><br></pre></td></tr></table></figure>
<p>还可以通过 Conda 安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install -c anaconda git</span><br></pre></td></tr></table></figure>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>前往 <a href="https://gitforwindows.org" target="_blank" rel="noopener">https://gitforwindows.org</a> 下载并安装 Git for Windows。</p>
<p>此外，它还会提供 Git Bash —— 在 Windows 操作系统中使用与 *Nix 操作系统一样的 Bash 命令行工具。</p>
<p>另外，在 Windows 操作系统中推荐使用 Git Bash 或者 PowerShell，而非 CMD 作为命令行工具。</p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>大多数 Linux 操作系统要么基于 Debain，要么基于 Red-Hat —— 请自行查看 <a href="https://en.wikipedia.org/wiki/List_of_Linux_distributions" target="_blank" rel="noopener">List of Linux distributions</a>，确定自己的 Linux 发行版究竟基于哪一个。</p>
<p>基于 Debian 的 Linux 发行版：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure>
<p>基于 Red-Hat 的 Linux 发行版：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum upgrade</span><br><span class="line">sudo yum install git</span><br></pre></td></tr></table></figure>
<h3 id="Git-本地配置"><a href="#Git-本地配置" class="headerlink" title="Git 本地配置"></a>Git 本地配置</h3><p>在命令行工具中执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"&lt;your_name&gt;"</span></span><br><span class="line">git config --global user.email &lt;your_email_address&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Git-GUI"><a href="#Git-GUI" class="headerlink" title="Git GUI"></a>Git GUI</h3><p>Git 的图形化版本客户端，有很多种选择，以下几个跨平台的客户端最受欢迎：</p>
<blockquote>
<ul>
<li><a href="https://desktop.github.com" target="_blank" rel="noopener">Github Desktop</a></li>
<li><a href="https://gitahead.github.io/gitahead.com/" target="_blank" rel="noopener">GitAhead</a></li>
<li><a href="https://git-fork.com" target="_blank" rel="noopener">Fork</a></li>
<li><a href="https://www.gitkraken.com" target="_blank" rel="noopener">GitKraken</a></li>
</ul>
</blockquote>
<p>更多选择，请移步查看 <a href="https://git-scm.com/downloads/guis/" target="_blank" rel="noopener">git-scm.com 上的 Git GUI Clients 列表</a>。</p>
<h3 id="需要了解的-Bash-基本命令"><a href="#需要了解的-Bash-基本命令" class="headerlink" title="需要了解的 Bash 基本命令"></a>需要了解的 Bash 基本命令</h3><p>虽然 Git 也有图形化版本，但无论如何你都会接触到命令行工具。并且，谁都一样，早晚会遇到非使用命令行不可的情况。</p>
<p>以下是常用 Bash 命令的简要说明：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>简要说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cd</code></td>
<td>Change Directory 的缩写；转到指定目录</td>
</tr>
<tr>
<td><code>ls</code></td>
<td>List 的缩写；列出当前目录中的内容</td>
</tr>
<tr>
<td><code>mkdir</code></td>
<td>Make Directory 的缩写；在当前目录中创建一个新的目录</td>
</tr>
<tr>
<td><code>pwd</code></td>
<td>Present Working Directory 的缩写；显示当前工作目录</td>
</tr>
<tr>
<td><code>touch</code></td>
<td>创建一个指定名称的空新文件</td>
</tr>
<tr>
<td><code>rm</code></td>
<td>Remove 的缩写；删除指定文件</td>
</tr>
<tr>
<td><code>rmdir</code></td>
<td>Remove Directory 的缩写；删除指定目录</td>
</tr>
<tr>
<td><code>cp</code></td>
<td>Copy 的缩写；拷贝指定文件</td>
</tr>
<tr>
<td><code>mv</code></td>
<td>Move 的缩写；移动指定文件</td>
</tr>
<tr>
<td><code>cat</code></td>
<td>Concatenate 的缩写；在屏幕中显示文件内容</td>
</tr>
<tr>
<td><code>chmod</code></td>
<td>Change Mode 的缩写；改变文件的权限</td>
</tr>
<tr>
<td><code>man</code></td>
<td>Manual 的缩写；显示指定命令的使用说明</td>
</tr>
</tbody>
</table>
<p>其中，<code>chmod</code> 最常用的 4 个权限分别是：</p>
<table>
<thead>
<tr>
<th>文件权限模式</th>
<th>简要说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>777</code></td>
<td>任何人都可以读、写、执行该文件</td>
</tr>
<tr>
<td><code>755</code></td>
<td>任何人都可以读、执行该文件，但只有所有者可以修改</td>
</tr>
<tr>
<td><code>700</code></td>
<td>只有所有者才能进行读、写、执行操作</td>
</tr>
<tr>
<td><code>+x</code></td>
<td>将文件设置为可执行</td>
</tr>
</tbody>
</table>
<p>在使用 <code>man</code> 命令时，系统会使用 vim 文本编辑工具以只读模式打开帮助文件，常用键盘命令如下：</p>
<table>
<thead>
<tr>
<th>键盘命令</th>
<th>简要说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>f</code></td>
<td>向后翻屏</td>
</tr>
<tr>
<td><code>b</code></td>
<td>向前翻屏</td>
</tr>
<tr>
<td><code>d</code></td>
<td>向后翻半屏</td>
</tr>
<tr>
<td><code>u</code></td>
<td>向前翻半屏</td>
</tr>
<tr>
<td><code>j</code></td>
<td>向后翻一行</td>
</tr>
<tr>
<td><code>k</code></td>
<td>向前翻一行</td>
</tr>
<tr>
<td><code>h</code></td>
<td>查看 vim 帮助</td>
</tr>
<tr>
<td><code>q</code></td>
<td>退出</td>
</tr>
</tbody>
</table>
<h2 id="一些不错的-Git-教程"><a href="#一些不错的-Git-教程" class="headerlink" title="一些不错的 Git 教程"></a>一些不错的 Git 教程</h2><p>除了 Pro Git 这本书之外，还有很多值得去看：</p>
<blockquote>
<ul>
<li><a href="http://ndpsoftware.com/git-cheatsheet.html" target="_blank" rel="noopener">GIT CHEATSHEET – an interaction from nop software</a></li>
<li><a href="https://learngitbranching.js.org/" target="_blank" rel="noopener">Learn Git Branching</a></li>
<li><a href="https://livebook.manning.com/#!/book/learn-git-in-a-month-of-lunches/about-this-book/" target="_blank" rel="noopener">Learn Git in a Month of Lunches</a></li>
<li><a href="https://githowto.com/" target="_blank" rel="noopener">Git How To</a></li>
<li><a href="http://justinhileman.info/article/git-pretty/" target="_blank" rel="noopener">Git pretty - Solve Git Mess</a></li>
<li><a href="http://onlywei.github.io/explain-git-with-d3/" target="_blank" rel="noopener">Visualizing Git Concepts with D3</a></li>
</ul>
</blockquote>
<p>当然，你肯定早晚会去 Github 上找 “Awesome Git”：</p>
<blockquote>
<p><a href="https://github.com/dictcp/awesome-git" target="_blank" rel="noopener">https://github.com/dictcp/awesome-git</a></p>
</blockquote>
<h1 id="Jupyterlab-的安装与配置"><a href="#Jupyterlab-的安装与配置" class="headerlink" title="Jupyterlab 的安装与配置"></a>Jupyterlab 的安装与配置</h1><h2 id="下载并安装-Anaconda"><a href="#下载并安装-Anaconda" class="headerlink" title="下载并安装 Anaconda"></a>下载并安装 Anaconda</h2><p><a href="https://www.anaconda.com" target="_blank" rel="noopener">Anaconda</a> 是目前最方便的 Python 发行版，搭载了很多我们终将必用的软件包，除了 Python 之外，还有 <a href="https://www.r-project.org/" target="_blank" rel="noopener">R 语言</a>，还包括 <a href="https://pandoc.org/" target="_blank" rel="noopener">Pandoc</a>，<a href="http://www.numpy.org/" target="_blank" rel="noopener">NumPy</a>，<a href="https://www.scipy.org/" target="_blank" rel="noopener">SciPy</a>，<a href="https://matplotlib.org/" target="_blank" rel="noopener">Matplotlib</a>…… 等等。</p>
<p>无论是图形化界面安装，还是命令行界面安装，建议都把 Anaconda 安装在本地用户目录内，<code>~/</code>。请下载并安装 Python 3.x 的版本。</p>
<p>图形化界面安装的教程，官方的很详细，各个操作平台的说明都有：</p>
<blockquote>
<p><a href="https://docs.anaconda.com/anaconda/install/" target="_blank" rel="noopener">https://docs.anaconda.com/anaconda/install/</a></p>
</blockquote>
<p>在 MacOS 的 Terminal 命令行下，可以直接下载并安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/Downloads/</span><br><span class="line">wget https://repo.anaconda.com/archive/Anaconda3-2018.12-MacOSX-x86_64.sh</span><br><span class="line">chmod +x Anaconda3-2018.12-MacOSX-x86_64.sh</span><br><span class="line">./Anaconda3-2018.12-MacOSX-x86_64.sh</span><br></pre></td></tr></table></figure>
<p>安装到最后一步，会问你是否要安装微软出品的 <a href="https://code.visualstudio.com" target="_blank" rel="noopener">Visual Studio Code</a>，选择 <code>yes</code> —— 反正以后你的电脑上会不止一个文本编辑器…… 以后你可能还会安装的文本编辑器包括 <a href="https://www.sublimetext.com" target="_blank" rel="noopener">SublimeText</a>, <a href="https://atom.io" target="_blank" rel="noopener">Atom</a> 等等。</p>
<p>安装完毕之后，打开 Terminal(Windows 系统需要打开之前安装的 Anaconda Prompt 输入），继续安装几个组件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conda update conda</span><br><span class="line">conda update anaconda</span><br><span class="line">conda install -c conda-forge nodejs</span><br><span class="line">conda install -c conda-forge jupyterlab <span class="comment"># 这是用来升级 jupyter lab 到最新版的方法</span></span><br></pre></td></tr></table></figure>
<p>安装完毕之后，可以看看各个你将要用到的可执行命令都在什么地方，用 <code>which</code> 命令（windows下用 <code>where</code> 命令）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> python</span><br><span class="line">python --version</span><br><span class="line"><span class="built_in">which</span> node</span><br><span class="line">node -v</span><br><span class="line"><span class="built_in">which</span> jupyter</span><br><span class="line">jupyter lab --version</span><br><span class="line">jupyter notebook --version</span><br><span class="line"><span class="built_in">which</span> pip</span><br><span class="line">pip --version</span><br></pre></td></tr></table></figure>
<h2 id="第一次启动-Jupyter-lab"><a href="#第一次启动-Jupyter-lab" class="headerlink" title="第一次启动 Jupyter lab"></a>第一次启动 Jupyter lab</h2><p>打开 Terminal，<code>cd</code> 到你想打开 Jupyter lab 的目录（就是你保存 <code>ipynb</code> 文件的地方，以便在 Jupyter lab 中打开、浏览、编辑 <code>ipynb</code> 文件），在这里以用户根目录为例 <code>~/</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">jupyter lab</span><br></pre></td></tr></table></figure>
<p>此时的 Terminal 窗口不能关闭，否则 Jupyter lab 就停止运行了 —— 就将它放在那里。</p>
<p>随后会有个浏览器打开，指向 <a href="http://localhost:8888/lab?" target="_blank" rel="noopener">http://localhost:8888/lab?</a> —— 你就看到 Jupyter lab 的操作界面了。</p>
<p>目前，Jupyter lab 和 Jupyter notebook 是并存的，虽然前者是后者的下一步替代者。如果你依然习惯于使用 Jupyter notebook，那么，在浏览器中指向 <a href="http://localhost:8888/tree?" target="_blank" rel="noopener">http://localhost:8888/tree?</a> 看到的就是 Jupyter notebook.</p>
<h2 id="配置-Jupyter-lab"><a href="#配置-Jupyter-lab" class="headerlink" title="配置 Jupyter lab"></a>配置 Jupyter lab</h2><p>打开 Terminal，输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter lab --generate-config</span><br></pre></td></tr></table></figure>
<p>这会在 <code>~/.jupyter/</code> 目录下生成一个 <code>jupyter_notebook_config.py</code> 文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.jupyter</span><br><span class="line">code jupyter_notebook_config.py</span><br></pre></td></tr></table></figure>
<p>上面的 code 命令，需要你已经安装 Visual Studio Code，并且在已经在其中设置了 <code>Install &#39;code&#39; command in PATH</code>。参见附录 <a href="T-appendix.editor.vscode.md">Visual Studio Code 的安装与配置</a></p>
<p>事实上，你可以用你喜欢的任何编辑器打开 <code>~/.jupyter/jupyter_notebook_config.py</code> 文件。</p>
<p>文件内容很长，有空可以仔细看。可以直接将以下内容拷贝粘贴到文件底部，根据需求修改：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#c.NotebookApp.token = ''</span><br><span class="line">#c.NotebookApp.open_browser = False</span><br><span class="line">#c.NotebookApp.notebook_dir = '~/'</span><br><span class="line">#c.NotebookApp.default_url = '/tree'</span><br></pre></td></tr></table></figure>
<p>逐条解释一下：</p>
<blockquote>
<p><code>c.NotebookApp.token = &#39;&#39;</code></p>
</blockquote>
<p>每次打开 jupyter，它都会给你生成一个新的 Token —— 这是安全策略。但是，如果你只是在自己的电脑上使用，那么，这就给你制造了麻烦，因为若是你想同时用另外一个浏览器打开它，那你就需要从 Terminal 里拷贝那个 Token 出来。所以，你可以在配置文件里直接把它设置为空。</p>
<blockquote>
<p><code>c.NotebookApp.open_browser = False</code></p>
</blockquote>
<p>每次你执行 <code>jupyter lab</code> 或者 <code>jupyter notebook</code> 命令的时候，它都会使用系统默认浏览器。</p>
<p>每个人的习惯不一样。比如我，会想到用一个平时不怎么用的浏览器专门用在 Jupyter 上，这样会防止自己在关闭其它网页的时候不小心把 Jupyter 关掉…… 那我就会把这项设定为 <code>False</code>。</p>
<blockquote>
<p><code>c.NotebookApp.notebook_dir = &#39;~/&#39;</code></p>
</blockquote>
<p>在 Terminal 中执行 <code>jupyter</code> 命令的时候，它默认是在你当前所在的工作目录打开 <code>jupyter</code>，这同样是出于安全考虑。但是，如果你只是在自己的电脑上使用，且只有自己在使用，那么莫不如直接把它设置成 <code>~/</code>，即，你的用户根目录，这样会很方便地访问各种地方的文件……</p>
<blockquote>
<p><code>c.NotebookApp.default_url = &#39;/tree&#39;</code></p>
</blockquote>
<p>这一项留给那些依然习惯于使用 jupyter notebook 的人，这样设置之后，即便是输入 <code>jupyter lab</code> 命令，打开的还是 jupyter notebook。</p>
<p>在 Terminal 里常用的与 Jupyter 有关的命令有：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jupyter lab</span><br><span class="line">jupyter lab --version</span><br><span class="line">conda install -c conda-forge jupyterlab <span class="comment"># 这是用来升级 jupyter lab 到最新版的方法</span></span><br><span class="line">jupyter notebook list                   <span class="comment"># 查看正在运行的 jupyter lab/notebook</span></span><br><span class="line">jupyter notebook stop                   <span class="comment"># 停止 jupyter lab/notebook 服务</span></span><br></pre></td></tr></table></figure>
<h2 id="将-Jupyter-lab-配置成系统服务"><a href="#将-Jupyter-lab-配置成系统服务" class="headerlink" title="将 Jupyter lab 配置成系统服务"></a>将 Jupyter lab 配置成系统服务</h2><p>如果，你厌烦每次都要跑到 Terminal 里启动 Jupyter lab，可以把它配置成系统服务，每次开机启动它就自动运行。而你需要做的只不过是直接从浏览器中访问 <a href="http://localhost:8888/" target="_blank" rel="noopener">http://localhost:8888/</a>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code ~/Library/LaunchAgents/com.jupyter.lab.plist</span><br></pre></td></tr></table></figure>
<p>这条命令会让 Visual Studio Code 创建 <code>~/Library/LaunchAgents/com.jupyter.lab.plist</code> 文件并打开。</p>
<p>在其中拷贝粘贴以下内容，注意，要把其中的 <code>your_username</code> 修改为你的用户名：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">plist</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//Apple//DTD PLIST 1.0//EN"</span> <span class="meta-string">"http://www.apple.com/DTDs/PropertyList-1.0.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>Label<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>local.job<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>ProgramArguments<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">string</span>&gt;</span>/Users/your_username/anaconda3/bin/jupyter<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">string</span>&gt;</span>lab<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">string</span>&gt;</span>--no-browser<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">string</span>&gt;</span>--notebook-dir=/Users/your_username/<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>RunAtLoad<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>StandardErrorPath<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>/tmp/local.job.err<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>StandardOutPath<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>/tmp/local.job.out<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果之前在 <code>jupyter_notebook_config.py</code> 文件里已经设置过</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c.NotebookApp.open_browser = False</span><br><span class="line">c.NotebookApp.notebook_dir = '~/'</span><br></pre></td></tr></table></figure>
<p>那么这两行就可以不要了：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>--no-browser<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>--notebook-dir=/Users/your_username/<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>而后在 Terminal 里执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">launchctl load ~/Library/LaunchAgents/com.jupyter.lab.plist</span><br></pre></td></tr></table></figure>
<p>如果你想重新启动这个服务，那么执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">launchctl unload ~/Library/LaunchAgents/com.jupyter.lab.plist</span><br><span class="line">launchctl load ~/Library/LaunchAgents/com.jupyter.lab.plist</span><br></pre></td></tr></table></figure>
<h2 id="关于-Jupyter-lab-themes"><a href="#关于-Jupyter-lab-themes" class="headerlink" title="关于 Jupyter lab themes"></a>关于 Jupyter lab themes</h2><p>对中文用户来说，Jupyter 的默认字号有点过小，阅读起来不是很舒适。但最佳的方案不是去寻找合适的 themes，而是直接使用支持 <a href="https://github.com/openstyles/stylus" target="_blank" rel="noopener">Stylus</a> 这类终端 CSS 定制插件的浏览器，Chrome/Firefox/Opera 都支持 Stylus 插件。</p>
<p>我用的 Stylus 定制 CSS 是这样的：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;<span class="attribute">color</span>: <span class="number">#2456A4</span> <span class="meta">!important</span>;&#125;</span><br><span class="line"><span class="selector-tag">strong</span> &#123;<span class="attribute">color</span>:<span class="number">#6392BF</span>;&#125;</span><br><span class="line"><span class="selector-tag">em</span> &#123;<span class="attribute">color</span>: <span class="number">#A9312A</span>; <span class="attribute">font-style</span>: normal <span class="meta">!important</span>;&#125;</span><br><span class="line"><span class="selector-tag">table</span> &#123;<span class="attribute">font-size</span>: <span class="number">90%</span> <span class="meta">!important</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#jp-main-dock-panel</span> &#123;<span class="attribute">background-color</span>: <span class="number">#f9f9f9</span>;&#125;</span><br><span class="line"><span class="selector-class">.jp-RenderedHTMLCommon</span> &#123;<span class="attribute">font-family</span>: <span class="string">"Yuanti SC"</span>; <span class="attribute">font-size</span>: <span class="number">100%</span>;&#125;</span><br><span class="line"><span class="selector-class">.jp-Notebook</span> &#123;<span class="attribute">background-color</span>: <span class="number">#fbfafa</span>;&#125;</span><br><span class="line"><span class="selector-class">.CodeMirror</span>, <span class="selector-class">.jp-RenderedHTMLCommon</span> <span class="selector-tag">pre</span> &#123;<span class="attribute">font-size</span>: <span class="number">90%</span>;&#125;</span><br><span class="line"><span class="selector-class">.jp-RenderedHTMLCommon</span> <span class="selector-tag">pre</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fafafa</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">4px</span> solid <span class="number">#dadada</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.jp-RenderedHTMLCommon</span> <span class="selector-tag">pre</span> <span class="selector-tag">code</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fafafa</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.jp-RenderedHTMLCommon</span> <span class="selector-tag">h1</span> <span class="selector-tag">code</span>,</span><br><span class="line"><span class="selector-class">.jp-RenderedHTMLCommon</span> <span class="selector-tag">h2</span> <span class="selector-tag">code</span>,</span><br><span class="line"><span class="selector-class">.jp-RenderedHTMLCommon</span> <span class="selector-tag">h3</span> <span class="selector-tag">code</span>,</span><br><span class="line"><span class="selector-class">.jp-RenderedHTMLCommon</span> <span class="selector-tag">h4</span> <span class="selector-tag">code</span>,</span><br><span class="line"><span class="selector-class">.jp-RenderedHTMLCommon</span> <span class="selector-tag">p</span> <span class="selector-tag">code</span>,</span><br><span class="line"><span class="selector-class">.jp-RenderedHTMLCommon</span> <span class="selector-tag">li</span> <span class="selector-tag">code</span>,</span><br><span class="line"><span class="selector-class">.jp-RenderedHTMLCommon</span> <span class="selector-tag">blockquote</span> <span class="selector-tag">p</span> <span class="selector-tag">code</span>,</span><br><span class="line"><span class="selector-class">.jp-RenderedHTMLCommon</span> <span class="selector-tag">blockquote</span> <span class="selector-tag">li</span> <span class="selector-tag">code</span>,</span><br><span class="line"><span class="selector-class">.jp-RenderedHTMLCommon</span> <span class="selector-tag">td</span> <span class="selector-tag">code</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#f6f6f6</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">90%</span>;</span><br><span class="line">    <span class="attribute">color</span>:<span class="number">#2e2e2e</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">4px</span> <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">8px</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">1px</span> <span class="number">2px</span> <span class="number">0px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.2</span>);</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就相当于我把 JupyterLab Light 这个 Theme 稍微 Tweak 了一下。</p>
<p>另，我写的内容里，为了重点突出，特别定制了 <code>strong</code> 和 <code>em</code> 两个元素的显示，让它们以不同的颜色展示；又因为中文并不适合斜体展示，所以，把 <code>em</code> 的 <code>font-style</code> 设定为 <code>normal</code>……</p>
<h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>Jupyter notebook 经过很多年的发展，现在有很多扩展插件，但也有其中一些并不兼容最新的 Jupyter lab。不过，刚开始的时候用不着那么多插件，你只用其中的两个就足够开始了：</p>
<blockquote>
<ul>
<li><a href="https://github.com/jupyterlab/jupyterlab-toc" target="_blank" rel="noopener">@jupyterlab/toc</a></li>
<li><a href="https://github.com/ryantam626/jupyterlab_sublime" target="_blank" rel="noopener">ryantam626/jupyterlab_sublime</a></li>
</ul>
</blockquote>
<p>首先在用快捷键 <code>⌘ ,</code> 打开 jupyter lab 的 Advanced Settings，在 Extension Manager 中，添加 User Overrides：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"enabled"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而后在 Terminal 执行以下命令安装插件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jupyter labextension install @jupyterlab/toc</span><br><span class="line">jupyter labextension install @ryantam626/jupyterlab_sublime</span><br><span class="line">jupyter lab build</span><br></pre></td></tr></table></figure>
<p>toc 插件，自动将 ipynb 文件中的标题转换成目录。</p>
<p><img data-src="https://github.com/jupyterlab/jupyterlab-toc/raw/master/toc.gif" alt></p>
<p>jupyterlab_sublime 则可以让你在 Jupyter lab 的 cell 中，使用跟 SublimeText 一样的快捷键，比如 <code>⌘ D</code> 能够多选其它与当前选中内容一样的内容；比如 <code>⌘</code> 加鼠标点击，可以生成多个可编辑点……</p>
<p><img data-src="http://blog.rtwilson.com/wp-content/uploads/2016/03/IPyNbSublime.gif" alt></p>
<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><p>以下是 MacOS 下 Jupyter lab 最常用的快捷键。快捷键在两种模式下执行，进入编辑模式用 <code>⏎</code>，回到命令模式用 <code>⎋</code>（ESC）。</p>
<p>另外，代码编辑过程中需要安装 Jupyterlab 插件 <a href="https://github.com/ryantam626/jupyterlab_sublime" target="_blank" rel="noopener">@ryantam626/jupyterlab_sublime</a> 之后才能使用 “多行同时编辑功能”。</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>说明</th>
<th>模式</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ESC</code></td>
<td>从编辑模式回到命令模式</td>
<td>命令</td>
</tr>
<tr>
<td><code>A</code></td>
<td>在当前 Cell 之前插入一个 Cell</td>
<td></td>
</tr>
<tr>
<td><code>B</code></td>
<td>在当前 Cell 之后插入一个 Cell</td>
<td></td>
</tr>
<tr>
<td><code>D</code>, <code>D</code></td>
<td>连续按两次 <code>d</code> 键，删除当前 Cell</td>
<td></td>
</tr>
<tr>
<td><code>Y</code></td>
<td>将当前 Cell 设置为 Code Cell</td>
<td></td>
</tr>
<tr>
<td><code>M</code></td>
<td>将当前 Cell 设置为 Markdown Cell</td>
<td></td>
</tr>
<tr>
<td><code>^ ⇧ -</code></td>
<td>将当前 Cell 拆分为两个</td>
<td>编辑</td>
</tr>
<tr>
<td><code>⇧ M</code></td>
<td>合并选中的 Cells</td>
<td></td>
</tr>
<tr>
<td><code>⇧ J</code> or <code>⇧ ↓</code></td>
<td>连续向下选中 Cells</td>
<td></td>
</tr>
<tr>
<td><code>⇧ K</code> or <code>⇧ ↑</code></td>
<td>连续向上选中 Cells</td>
<td></td>
</tr>
<tr>
<td><code>⇧ ⏎</code> or <code>^ ⏎</code></td>
<td>运行当前 Cell 中的代码</td>
<td></td>
</tr>
<tr>
<td><code>⇧ L</code></td>
<td>显示/隐藏代码行号</td>
<td></td>
</tr>
<tr>
<td><code>⏎</code></td>
<td>当前 Cell 进入编辑模式</td>
<td>编辑</td>
</tr>
<tr>
<td><code>⇥</code></td>
<td>自动补全代码</td>
<td></td>
</tr>
<tr>
<td><code>⇧ ⇥</code></td>
<td>呼出当前光标下词汇的 Docstring</td>
<td></td>
</tr>
<tr>
<td><code>⌘ D</code></td>
<td>Sublime Keymap: 选中下一个相同字符串</td>
<td></td>
</tr>
<tr>
<td><code>⇧ ⌘ L</code></td>
<td>Sublime Keymap: 在选中的行内启动多行同时编辑</td>
<td></td>
</tr>
<tr>
<td><code>⌘ + Mouse Click</code></td>
<td>生成下一个可同时编辑的光标点</td>
</tr>
</tbody>
</table>
<h2 id="增加一些必要的快捷键"><a href="#增加一些必要的快捷键" class="headerlink" title="增加一些必要的快捷键"></a>增加一些必要的快捷键</h2><p>在 Settings &gt; Keyboard Shortcuts 中，可以设定一些常用但系统并未给出的快捷键：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"notebook:move-cells-down-down"</span>: &#123;</span><br><span class="line">		<span class="attr">"command"</span>: <span class="string">"notebook:move-cell-down"</span>,</span><br><span class="line">		<span class="attr">"keys"</span>: [</span><br><span class="line">		<span class="string">"Alt J"</span></span><br><span class="line">		],</span><br><span class="line">		<span class="attr">"selector"</span>: <span class="string">".jp-Notebook:focus"</span>,</span><br><span class="line">		<span class="attr">"title"</span>: <span class="string">"Move Cells Down"</span>,</span><br><span class="line">		<span class="attr">"category"</span>: <span class="string">"Notebook Cell Operations"</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">"notebook:move-cells-down-up"</span>: &#123;</span><br><span class="line">		<span class="attr">"command"</span>: <span class="string">"notebook:move-cell-up"</span>,</span><br><span class="line">		<span class="attr">"keys"</span>: [</span><br><span class="line">		<span class="string">"Alt K"</span></span><br><span class="line">		],</span><br><span class="line">		<span class="attr">"selector"</span>: <span class="string">".jp-Notebook:focus"</span>,</span><br><span class="line">		<span class="attr">"title"</span>: <span class="string">"Move Cells Down"</span>,</span><br><span class="line">		<span class="attr">"category"</span>: <span class="string">"Notebook Cell Operations"</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">"notebook:enable-output-scrolling"</span>: &#123;</span><br><span class="line">		<span class="attr">"command"</span>: <span class="string">"notebook:enable-output-scrolling"</span>,</span><br><span class="line">		<span class="attr">"keys"</span>: [</span><br><span class="line">		<span class="string">"S"</span></span><br><span class="line">		],</span><br><span class="line">		<span class="attr">"selector"</span>: <span class="string">".jp-Notebook:focus"</span>,</span><br><span class="line">		<span class="attr">"title"</span>: <span class="string">"Enable output scrolling"</span>,</span><br><span class="line">		<span class="attr">"category"</span>: <span class="string">"Notebook Cell Operations"</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="attr">"notebook:disable-output-scrolling"</span>: &#123;</span><br><span class="line">		<span class="attr">"command"</span>: <span class="string">"notebook:disable-output-scrolling"</span>,</span><br><span class="line">		<span class="attr">"keys"</span>: [</span><br><span class="line">		<span class="string">"Alt S"</span></span><br><span class="line">		],</span><br><span class="line">		<span class="attr">"selector"</span>: <span class="string">".jp-Notebook:focus"</span>,</span><br><span class="line">		<span class="attr">"title"</span>: <span class="string">"Enable output scrolling"</span>,</span><br><span class="line">		<span class="attr">"category"</span>: <span class="string">"Notebook Cell Operations"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就添加了 4 个快捷键：</p>
<blockquote>
<ul>
<li><code>⌥ J</code>: Move selected cells down</li>
<li><code>⌥ K</code>: Move selected cells up</li>
<li><code>S</code>: Enable output scrolling</li>
<li><code>⌥ S</code>: Disable output scrolling</li>
</ul>
</blockquote>
<p>比如 Move Selected cells up：</p>
<p><img data-src="https://user-images.githubusercontent.com/86304/37438938-b5bc4994-27b2-11e8-8f58-184a58b33ba4.gif" alt></p>
<h2 id="输出所有变量内容"><a href="#输出所有变量内容" class="headerlink" title="输出所有变量内容"></a>输出所有变量内容</h2><p>默认情况下，Code Cell 只输出最后一个可以被 evaluate 的值，用 <code>_</code> 代表之前刚刚被 evaluate 的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<pre><code>[1, 2, 3]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_ <span class="comment"># 执行完上面的 Cell，试试这个 Cell; 而后执行完下面的 Cell 之后再重新执行一次当前这个 Cell</span></span><br></pre></td></tr></table></figure>
<pre><code>[1, 2, 3]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<pre><code>{1, 2, 3}
</code></pre><p>于是，为了显示最近 evaluate 的多个值，我们总是不得不使用很多的 <code>print()</code>……</p>
<p>如果觉得这事比较烦的话，可以在 Cell 最上面写上：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br></pre></td></tr></table></figure>
<p>如果还想更省事一点，就把这个设置写入配置文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c.InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</span><br><span class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<pre><code>(1, 2, 3)

{1, 2, 3}
</code></pre><h2 id="魔法函数"><a href="#魔法函数" class="headerlink" title="魔法函数"></a>魔法函数</h2><p>在 Code Cell 里，可以运行一些 “魔法函数”（Magic Functions），这是秉承了 IPython 的特性。绝大多数在 IPython 里能够使用的魔法函数在 Jupyterlab 里都可以直接使用。完整的 IPython 魔法函数请参照：</p>
<blockquote>
<p><a href="https://ipython.readthedocs.io/en/stable/interactive/magics.html" target="_blank" rel="noopener">https://ipython.readthedocs.io/en/stable/interactive/magics.html</a></p>
</blockquote>
<p>Jupyterlab 里较为常用的魔法函数整理如下：</p>
<table>
<thead>
<tr>
<th>魔法函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>%lsmagic</code></td>
<td>列出所有可被使用的 Jupyter lab 魔法函数</td>
</tr>
<tr>
<td><code>%run</code></td>
<td>在 Cell 中运行 <code>.py</code> 文件：<code>%run file_name</code></td>
</tr>
<tr>
<td><code>%who</code></td>
<td>列出所有当前 Global Scope 中的变量；类似的还有：<code>%who df</code>，<code>%whos</code></td>
</tr>
<tr>
<td><code>%env</code></td>
<td>列出当前的环境变量</td>
</tr>
<tr>
<td><code>%load</code></td>
<td>将其他文件内容导入 Cell，<code>%load source</code>，<code>source</code> 可以是文件名，也可以是 URL。</td>
</tr>
<tr>
<td><code>%time</code></td>
<td>返回 Cell 内代码执行的时间，相关的还有 <code>%timeit</code></td>
</tr>
<tr>
<td><code>%writefile</code></td>
<td>把 Cell 的内容写入文件，<code>%write file_name</code>；%write -a file_name，<code>-a</code> 是追加</td>
</tr>
<tr>
<td><code>%matplotlib inline</code></td>
<td>行内展示 matplotlib 的结果</td>
</tr>
<tr>
<td><code>%%bash</code></td>
<td>运行随后的 shell 命令，比如 %%bash ls；与之类似的还有 <code>%%HTML</code>，<code>%%python2</code>，<code>%%python3</code>，<code>%%ruby</code>，<code>%%perl</code>……</td>
</tr>
</tbody>
</table>
<h2 id="桌面版-Jupyter-App"><a href="#桌面版-Jupyter-App" class="headerlink" title="桌面版 Jupyter App"></a>桌面版 Jupyter App</h2><h3 id="Nteract"><a href="#Nteract" class="headerlink" title="Nteract"></a>Nteract</h3><p>支持各个操作系统，很好看、很好用。有一个小缺点是，不支持 <code>input()</code> 函数的调用。</p>
<blockquote>
<p><a href="https://nteract.io/desktop" target="_blank" rel="noopener">https://nteract.io/desktop</a></p>
</blockquote>
<p><img data-src="https://cloud.githubusercontent.com/assets/836375/18421299/d95ad398-783b-11e6-8b23-d54cf7caad1e.png" alt="https://cloud.githubusercontent.com/assets/836375/18421299/d95ad398-783b-11e6-8b23-d54cf7caad1e.png"></p>
<h3 id="Pineapple"><a href="#Pineapple" class="headerlink" title="Pineapple"></a>Pineapple</h3><p>只支持 MacOS，也很好用 —— 缺点就是很难看……</p>
<blockquote>
<p><a href="https://nwhitehead.github.io/pineapple/" target="_blank" rel="noopener">https://nwhitehead.github.io/pineapple/</a></p>
</blockquote>
<p><img data-src="https://nwhitehead.github.io/pineapple//images/sshots.png?raw=true" alt="https://nwhitehead.github.io/pineapple//images/sshots.png"></p>
<h1 id="这些符号都代表什么？"><a href="#这些符号都代表什么？" class="headerlink" title="这些符号都代表什么？"></a>这些符号都代表什么？</h1><p>以下的表格你可以用很多次 —— 每次学一门新语言的时候，都可以拿它整理一遍思路……</p>
<p>最初的时候，人们能向计算机输入的只能是 ASCII 码表中的字符。于是从一开始，计算机科学家们就绞尽脑汁去琢磨怎么把这些符号用好、用足……</p>
<p>于是，ASCII 码表中的字符常常在不同的地方有不同的用处。比如，<code>.</code>，在操作系统中，常常当作文件名和扩展名之间的分隔符；在很多编程语言中，都被当作调用 Class Attributes 和 Class Methods 的符号；在正则表达式中，<code>.</code> 代表除 <code>\r</code> <code>\n</code> 之外的任意字符……</p>
<p>把下面的表格打印出来，整理一下，在表格里填写每个符号在 Python 中都是用来做什么的？<a href="#fn1" name="fn1b"><sup>[1]</sup></a></p>
<blockquote>
<p>当前文件夹之中，有 <code>symbols.numbers</code> 文件，是用来打印以下表格的……</p>
</blockquote>
<p>以后不管学什么语言，就拿这个表格过一遍，到时候只有一个感觉：越学越简单！</p>
<p>很多人最初的时候学不进去，就是因为 “一些符号的用法太多了，经常混淆，于是就觉得累了、烦了……” 然而，只要多重复几次多在脑子里过几遍就熟悉了 —— 若是真的熟悉了、若是真的掌握了，你就会觉得：真的没什么啊！哪儿有那么难啊？！</p>
<p><img data-src="https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/symbols.png?raw=true" alt></p>
<p>学编程的一个好玩之处就是：</p>
<blockquote>
<p>但凡你学会了任何一门编程语言，你就会发现你的键盘上的每一个键你都用得上……</p>
</blockquote>
<p>可是在此之前，你跟人家花了同样的价钱买来的硬件设备，你竟然有那么多根本就没用过的东西！</p>
<p>普通人花同样价钱买来的是台机器而已；可是你却不一样 —— 用同样的价钱买来的是一个特别听话的机器人，一个可以替你不分昼夜不辞辛苦干活的机器人 —— 这感觉非常神奇。</p>
<hr>
<p><strong>脚注</strong></p>
<p><a name="fn1">[1]</a>：Python 语法，请参阅 The Python Language Reference <a href="https://docs.python.org/3/reference/lexical_analysis.html#operators" target="_blank" rel="noopener">2. Lexical analysis</a></p>
<p><a href="#fn1b"><small>↑Back to Content↑</small></a></p>
<h2 id="自学是门艺术"><a href="#自学是门艺术" class="headerlink" title="自学是门艺术"></a>自学是门艺术</h2><ul>
<li><a href="01.preface.md">01 前言</a></li>
<li><a href="02.proof-of-work.md">02 如何证明你真的读过这本书？</a></li>
</ul>
<h2 id="PART-1"><a href="#PART-1" class="headerlink" title="PART 1"></a>PART 1</h2><ul>
<li><a href="Part.1.A.better.teachyourself.md">Part.1.A 为什么一定要掌握自学能力？</a></li>
<li><a href="Part.1.B.why.start.from.learning.coding.md">Part.1.B 为什么把编程当作自学的入口？</a></li>
<li><a href="Part.1.C.must.learn.sth.only.by.reading.md">Part.1.C 只靠阅读习得新技能</a></li>
<li><a href="Part.1.D.preparation.for.reading.md">Part.1.D 开始阅读前的一些准备</a></li>
<li><a href="Part.1.E.1.entrance.md">Part.1.E.1 入口</a></li>
<li><a href="Part.1.E.2.values-and-their-operators.md">Part.1.E.2 值及其相应的运算</a></li>
<li><a href="Part.1.E.3.controlflow.md">Part.1.E.3 流程控制</a></li>
<li><a href="Part.1.E.4.functions.md">Part.1.E.4 函数</a></li>
<li><a href="Part.1.E.5.strings.md">Part.1.E.5 字符串</a></li>
<li><a href="Part.1.E.6.containers.md">Part.1.E.6 数据容器</a></li>
<li><a href="Part.1.E.7.files.md">Part.1.E.7 文件</a></li>
<li><a href="Part.1.F.deal-with-forward-references.md">Part.1.F 如何从容应对含有过多 “过早引用” 的知识？</a></li>
<li><a href="Part.1.G.The-Python-Tutorial-local.md">Part.1.G 官方教程：The Python Tutorial</a></li>
</ul>
<h2 id="PART-2"><a href="#PART-2" class="headerlink" title="PART 2"></a>PART 2</h2><ul>
<li><a href="Part.2.A.clumsy-and-patience.md">Part.2.A 笨拙与耐心</a></li>
<li><a href="Part.2.B.deliberate-practicing.md">Part.2.B 刻意练习</a></li>
<li><a href="Part.2.C.why-start-from-writing-functions.md">Part.2.C 为什么从函数开始？</a></li>
<li><a href="Part.2.D.1-args.md">Part.2.D.1 关于参数（上）</a></li>
<li><a href="Part.2.D.2-aargs.md">Part.2.D.2 关于参数（下）</a></li>
<li><a href="Part.2.D.3-lambda.md">Part.2.D.3 化名与匿名</a></li>
<li><a href="Part.2.D.4-recursion.md">Part.2.D.4 递归函数</a></li>
<li><a href="Part.2.D.5-docstrings.md">Part.2.D.5 函数的文档</a></li>
<li><a href="Part.2.D.6-modules.md">Part.2.D.6 保存到文件的函数</a></li>
<li><a href="Part.2.D.7-tdd.md">Part.2.D.7 测试驱动的开发</a></li>
<li><a href="Part.2.D.8-main.md">Part.2.D.8 可执行的 Python 文件</a></li>
<li><a href="Part.2.E.deliberate-thinking.md">Part.2.E 刻意思考</a></li>
</ul>
<h2 id="PART-3"><a href="#PART-3" class="headerlink" title="PART 3"></a>PART 3</h2><ul>
<li><a href="Part.3.A.conquering-difficulties.md">Part.3.A 战胜难点</a></li>
<li><a href="Part.3.B.1.classes-1.md">Part.3.B.1 类 —— 面向对象编程</a></li>
<li><a href="Part.3.B.2.classes-2.md">Part.3.B.2 类 —— Python 的实现</a></li>
<li><a href="Part.3.B.3.decorator-iterator-generator.md">Part.3.B.3 函数工具</a></li>
<li><a href="Part.3.B.4.regex.md">Part.3.B.4 正则表达式</a></li>
<li><a href="Part.3.B.5.bnf-ebnf-pebnf.md">Part.3.B.5 BNF 以及 EBNF</a></li>
<li><a href="Part.3.C.breaking-good-and-bad.md">Part.3.C 拆解</a></li>
<li><a href="Part.3.D.indispensable-illusion.md">Part.3.D 刚需幻觉</a></li>
<li><a href="Part.3.E.to-be-thorough.md">Part.3.E 全面 —— 自学的境界</a></li>
<li><a href="Part.3.F.social-selfteaching.md">Part.3.F 自学者的社交</a></li>
<li><a href="Part.3.G.the-golden-age-and-google.md">Part.3.G 这是自学者的黄金时代</a></li>
<li><a href="Part.3.H.prevent-focus-drifting.md">Part.3.H 避免注意力漂移</a></li>
</ul>
<h2 id="附章"><a href="#附章" class="headerlink" title="附章"></a>附章</h2><ul>
<li><a href="Q.good-communiation.md">Q 如何成为优秀沟通者</a></li>
<li><a href="R.finale.md">R 自学者的终点</a></li>
<li><a href="S.whats-next.md">S 下一步干什么？</a></li>
</ul>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ul>
<li><a href="T-appendix.editor.vscode.md">Appendix A: Visual Studio Code 的安装与配置</a></li>
<li><a href="T-appendix.git-introduction.md">Appendix B: Git 简介</a></li>
<li><a href="T-appendix.jupyter-installation-and-setup.md">Appendix C: Jupyterlab 的安装与配置</a></li>
<li><a href="T-appendix.symbols.md">Appendix D: 这些符号都代表什么？</a></li>
</ul>
<h1 id="IPCreator’s-View-of-Coding"><a href="#IPCreator’s-View-of-Coding" class="headerlink" title="IPCreator’s View of Coding"></a>IPCreator’s View of Coding</h1><p>作者：<a href="http://ipcreator.me" target="_blank" rel="noopener">IPCreator</a></p>
<h2 id="Skill-is-acquired-through-correct-and-repetitive-practice-and-practice-makes-perfect"><a href="#Skill-is-acquired-through-correct-and-repetitive-practice-and-practice-makes-perfect" class="headerlink" title="Skill is acquired through correct and repetitive practice, and practice makes perfect."></a>Skill is acquired through correct and repetitive practice, and practice makes perfect.</h2><p>阅读整合–&gt;<br>代码片段–&gt;<br>实践项目–&gt;<br>博客总结–&gt;</p>
 <!-- more -->
<blockquote>
<ol>
<li>不放过任何一个err，每成功解决一个error就意味着自己的经验库又append一个案例；</li>
<li>理不顺想不通的时候，成长的时刻到了，坚持、坚持再坚持，成就感与困难度成正比；</li>
<li>官网+stackflow+github+google还解决不了的时候，暂时放一放，持续关注思考，直至惊喜发生；</li>
<li>换位常识思考，如果你是设计者，你会怎么设计，为什么这样设计？</li>
<li>尽量不要复制粘贴，要逐字阅读，逐个输入，对开发而言，thinking与coding相辅相成，缺一不可；</li>
<li>知其然还要知其所以然，不要浮于表面，浅尝则止，运行/部署成功不等于你掌握了每个环节的原理；</li>
<li>慢工出细活，慢就是快，防火胜于救火，先打好基础（概念、框架、原理等），高手都重视内功；</li>
<li>专而精，精而深，通过一个突破口（语言、框架、平台），抓住本质量（通俗易懂，能重建和迁移），再融会贯通，一通百通；</li>
<li>coding只是解决问题的一种方式，不要重复发明轮子，要open和share，不要敝扫自珍，因为每个人都能掌握相应的技能，只是时间早晚而已；</li>
<li>创新整合也是一种行之有效的商业途径，不要为了技术而技术，为了创新而创新，商业思维很重要；</li>
<li>从战略上来说，我们大部分都只是用别人开发出来的工具（类似于厨具）开发产品（类似于菜品）而已；</li>
<li>阅读代码（类似于品尝他人菜品）、模仿创新（借鉴改造）、原创分享（晋级高级厨师）；</li>
<li>道理都懂，为什么难以坚持？没有尝到甜头或者没有吃到苦头，又或者只是懒惰；</li>
<li>35岁以后能否再编程？取决于：以前的编程模式是否健康可持续？是否为自己实现创新产品和服务(而不只是为了挣钱)；</li>
<li>程序员人生的梦想和快乐简单易实现，成为其中一员才能真正感同身受…</li>
<li>有劲、有趣和有用，正常可持续，Kick-off &amp; Keep-going</li>
</ol>
</blockquote>
<blockquote>
<p>Dreams cann’t measured by S/A/B/C/D degree、money and position.<br>Great mind thinks alike.<br>RTFC Read the fucking code.<br>RTFM Read the fucking manual.<br>STFW Search the fucking Web.<br>Read  the article word by word.<br>Code can talk, let the code talk.<br>A good name tells the truth.<br>Keep code  simple and reusable.<br>Keep hungry, Keep foolish.<br>Keep healthy and sustainable.<br>Less  is  more, slow is quick.<br>Don’t Reinvent the Wheel.<br>Use is the best way of learning English , so is programming.<br>Master the essence of  things, including languages (English/C/C++/JAVA/PYTHON/JS…)，<br>platforms(Arena/Android/Tensor…)，tools(gcc/make/gradle/git…),etc<br>We make good habits first, then habits make us.<br>Success is a habit, so is happiness.</p>
</blockquote>
<p><strong>Hello World Program in Java</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class HelloWorld</span><br><span class="line">&#123;  </span><br><span class="line">        public static void main(String args[])</span><br><span class="line">        &#123;</span><br><span class="line">           System.out.println(“Hello World”);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Hello World Program in C</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    printf(“Hello World”);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Hello World Program in C++</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; “Hello, world”;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Hello World Program in Javascript</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">window.onload = function()</span><br><span class="line">&#123;</span><br><span class="line">     document.getElementById(‘result’).innerHTML = “Hello World”;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;div id=”result&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>Hello World Program in HTML</strong><br><code>&lt;p&gt;Hello World&lt;/p&gt;</code></p>
<p><strong>Hello World Program in Python</strong><br><code>print “Hello World</code></p>
<p><strong>Hello World Program in Perl</strong><br><code>print “Hello World</code></p>
<p><strong>Hello World Program in Ruby</strong><br><code>puts “Hello World</code></p>
<p>Source: <a href="http://blog.learntoprogram.tv/hello-world-eight-languages/" target="_blank" rel="noopener">http://blog.learntoprogram.tv/hello-world-eight-languages/</a></p>
<h1 id="太用力的人跑不远"><a href="#太用力的人跑不远" class="headerlink" title="太用力的人跑不远"></a><a href="http://blog.csdn.net/jdsjlzx/article/details/51034003" target="_blank" rel="noopener">太用力的人跑不远</a></h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>有阶段的自己，会用蛮力去学习一些东西，就是这东西不管是否适合目前自己的知识体系， 觉得学了之后会更牛逼就去学，但是这样的东西往往学了记不住。 学习的过程越用力反而显得越吃力， 太吃力的事情，自然就无法有恒心， 这就是很多人会觉得自己做事总是无法持之以恒的原因。</p>
<blockquote>
<p>努力不应该是某种需要被时常觉知的东西，意志力是短期内会用完的精神能量。<br>真正坚持到最后的人靠的不是激情，而是恰到好处的喜欢和投入。</p>
</blockquote>
<p>太用力的人更容易产生期望落差，更不愿接受自己找错了方向的事实——没有什么比这样的“失落”更能让人心寒的了，太用力的人大多都因心累而倒在了半途中。</p>
<p>精神上的用力并不会让你跑得更快，但是精神上的疲惫却可以让你停下。</p>
<p>人越用力，就会越想要得到及时的良好刺激。越用力的人对于正刺激的需求就越高，越不能忍受暂时的负反馈。遗憾的是，人生常常是没有下文的考卷，这种刺激来得太慢、太不稳定。</p>
<blockquote>
<p>真正的坚持归于平静，靠的是温和的发力，而不是时时刻刻的刺激。</p>
</blockquote>
<blockquote>
<p>太用力的人增加了执行的功耗。纠结，是太用力的一种表现，造成内部的运转处于空转的状态——意识与行动的主观脱节；从心所欲，就是把运转效率最大化后的结果——所想即所为。执行阶段最大的敌人，是纠结，是埋怨，是内心的冲突——太用力，就是心理额外动作太多。想好之后就只管去做。</p>
</blockquote>
<p>我一直告诫自己不要用力过猛，以保持自己对困难的顿感和不顺的接受程度。<br>短期的过度用力极容易造成身体和心理上的挫伤。哪怕你在做的事情非常重要，也要保证基本的休息和放松。</p>
<p>不论是以后的工作还是将来的创业，都要保持一颗平常心。你需要更多的“寸劲”而不是“用力感”。在找到受力点“all in”之前，一切都要顺势而行，自然随和。</p>
<p>人在学习的过程会经历一系列的过程，先是笨拙期，再是熟练期——这两个过程他虽然能运用出技能，但是头脑中仍然能感受到使用时的提取感。这两个阶段都需要用力，但是用力的程度却大幅度减小。</p>
<p>技能掌握的最后阶段是运用自如期，就是张三丰把太极拳的形态全部都忘了的阶段。这个时候头脑中已经能下意识地去进行活动，达到了能耗最低的理想阶段。</p>
<p>从用力感，到毫无感觉，是一种技能掌握上的纯熟。年轻的时候太认真是件好事，或许只有用力过了，才能体会从心所欲、顺其自然的难得。</p>
<h2 id="IT人员怎么用力"><a href="#IT人员怎么用力" class="headerlink" title="IT人员怎么用力"></a>IT人员怎么用力</h2><p>总有在校的学生问我现在 X,Y,Z… 技术很火热，应该学哪个？ 我看他列出的那些准备学习的选项中，其实前景和热门程度都差不多。 这让他陷入了选择焦虑症，不管做什么决定都怕「一失足成千古恨」。</p>
<p>对技术发展趋势关心是好事，就像之前那篇「不要总是选择困难模式」里面说的那样。 但是其实在「不要总是选择困难模式」里面忽略了很重要的一点，就是你个人的兴趣。 比如有的人对苹果的东西有天生的热爱，所以选择「iOS开发」对他来说就更容易做好。 尽可能选择会让自己 Enjoy 的技术方向，路还很长，不享受过程的话容易半途而废。</p>
<h2 id="太用力的人跑不远-1"><a href="#太用力的人跑不远-1" class="headerlink" title="太用力的人跑不远"></a>太用力的人跑不远</h2><p>记得之前本科的时候喜欢和舍友一起打Dota，打Dota开局之前一般要等人齐， 等人的这段时间我有时候会切出来写写代码，叫舍友开局了告诉我一声。 然后别人看到我在打Dota间隙都在写代码，就觉得我有多努力多努力，给人了一种非常「刻苦」的印象。 以至于上次和一个本科同学吃饭他还说起这个事情，觉得我能做到这样非常「牛逼」。</p>
<p>但是其实这样的事情，如果对于真的对写代码有经历过热爱的人，是不会觉得有多么刻苦的事情。 这是自然而然的事情，甚至其实有些代码，那种满足好奇心的快感，是比打游戏有意思的多， 是件很Enjoy的事情，而不是所谓的「刻苦」。</p>
<h2 id="就像跑步，「太用力的人跑不远」。"><a href="#就像跑步，「太用力的人跑不远」。" class="headerlink" title="就像跑步，「太用力的人跑不远」。"></a>就像跑步，「太用力的人跑不远」。</h2><p>不要用蛮力去学编程</p>
<p>记得当年初学 C++ 的同学，听别人说 C++ 很基础也很重要的一个知识点就是STL， 然后听说要学好 STL 就应该去看看侯捷的「STL源码剖析」。 然后就买了书硬啃，然后没啃几天就放弃了，觉得太讳莫如深了没法理解。</p>
<p>但是如果换个学习的方式， 先假设现在没有STL这个标准库， 让你用已有的C++语法知识去自己写一个仿造STL标准库的功能， 哪怕是最最简单的 vector 。 你在编写的时候就会自然而然得体会到内存动态扩展的一些缺点和潜在的坑。 会知道为什么适当使用 reserve 和 swap 能非常明显的提高性能。</p>
<p>然后在自己思考的过程中会提出很多相关的疑惑， 带着疑惑再去翻看「STL源码剖析」， 就会让你对一个个数据结构恍然大悟知根知底。 自然而然你的看书体验会非常的 Enjoy， 而不是觉得苦涩难咽。</p>
<p><strong>编程和求知本身是一件愉悦身心的事情， 如果只是为了高薪，而用蛮力去写代码，只会让自己疲惫不堪。</strong></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>希望对在学习编程的路上很挣扎的朋友有所帮助。 毕竟工作是生活的很大一部分， 如果工作不开心，生活怎么办。</p>
<h1 id="不是人人都懂的学习要点"><a href="#不是人人都懂的学习要点" class="headerlink" title="不是人人都懂的学习要点"></a>不是人人都懂的学习要点</h1><p>学习是一种基础性的能力。然而，“吾生也有涯，而知也无涯。”，如果学习不注意方法，则会“以有涯随无涯，殆矣”。</p>
<h2 id="一．学习也是一种能力"><a href="#一．学习也是一种能力" class="headerlink" title="一．学习也是一种能力"></a>一．学习也是一种能力</h2><p>看到这个标题，有人会说：“学习，谁不会？”的确，学习就像吃饭睡觉一样，是人的一种本能，人人都有学习的能力。我们在刚出生的时候，什么也不知道，是一张真正的白纸，我们靠学习的本能，学会了走路、说话、穿衣服…后来，我们上学了，老师把书本上的知识一点一点灌输到我们的脑子里，我们掌握的知识越来越多，与此同时，我们学习能力却好像越来越差了，习惯了被别人喂饱，似乎忘记了怎么来喂自己了。</p>
<p>学习本来只是一种本能，算不上什么能力，然而，经过二十多年的不断学习，学习反而成为了一种真正的能力，因为我们慢慢失去了它，它就更显得珍贵。</p>
<p>在学校里我们基本上被动式学习，然而走出了象牙塔之后，不会再有人对你负责，不会有人主动教你，我们需要主动的学习。所谓的学习能力，其实就是自主学习的能力。</p>
<p>几年前，曾有一本风靡管理界的书，叫《第五项修炼》，这本书倡导建立学习型组织，因为从长远来看，一个组织唯一可持续的竞争优秀，就是比竞争对手更快更好的学习能力。</p>
<p>一个公司如此，一个人又何尝不是如此？众所周知现在是一个知识爆炸的时候代，知识更新非常快。据说，一个大学毕业生所学习到的知识，在毕业之后的2年内，有效的不过剩下5%，更何况我们的学校与社会需要严重脱轨。我们赖以立足的，不在于我们现在掌握了多少知识，而是我们有多强的学习能力！</p>
<p>学习不但是一种能力，而且是一种至关重要的能力，而这种能力的核心，就是学习的方法和心态。</p>
<h2 id="二．买书是最划算的投资"><a href="#二．买书是最划算的投资" class="headerlink" title="二．买书是最划算的投资"></a>二．买书是最划算的投资</h2><p>古人云：“书中自有黄金屋，书中自有颜如玉。”这说明先贤们早就认识到，买书是最划算的投资了。</p>
<p>当我刚出道的时候，拿着非常微薄的工资，有一次我向主管抱怨道：“现在的书真贵啊，这点工资连饭都吃不起，更别说买书了！”主管对我说：“不要吝惜买书的钱，宁可忍着不吃饭，也不要忍着不买书，因为买书是回报率的最高的投资了。”</p>
<p>主管的话让我非常震动。后来，我看到喜欢的书时，再有没有手软过。我不断的学习，开发能力也不断的提高，工资水平也获得了大幅度的提高。一年后，我一个月工资的涨幅，就足够买两年的书了。你说，还有比这更划算的投资吗?</p>
<p>一本书，哪怕只有一页纸是有用的，它将所产生的潜在价值，也会远远超过书本身的价格。当然，书不在多，能踏踏实实消化掉一本好书，可能比泛泛而读10本普通书，要更有价值得多。</p>
<h2 id="三．多读经典书"><a href="#三．多读经典书" class="headerlink" title="三．多读经典书"></a>三．多读经典书</h2><p>十年前，我刚进入IT行业的时候，真是求知渴，每星期都要往购书中心跑，可惜的是，那时给程序员看的书不像现在这么多，高质量的书就更少了。当时我印象中比较经典的书籍就是《Windows程序设计》、《COM本质论》、《Java编程思想》，还有就是谭浩强的《C语言程序设计》。其它充斥书架的，就是类似于《21天精通XXX》、《XXX从入门到精通》、《XX宝典》这样的书籍。</p>
<p>回首往昔，令我比较郁闷的一件事就是在我最有学习动力的时候，看的高质量的书籍太少，就好像是在长身体的时候，天天吃的是没营养的泡面。当然，这跟没有人指导也有很大的关系，独自一个人学习，让我走了很多的弯路。</p>
<p>软件开发方面的书籍，我大致将其分为三类：</p>
<p>（1）浅显的入门类书籍。</p>
<p>这类书的标题往往是《XX天精通XXX》、《XXX从入门到精通》、《XX开发实战》等，这类书往往从软件的安装讲起，喜欢翻译帮助文件。有人批评这类书为烂书、毫无价值，这并不公平。至少我本人，也曾从这些书中学到一些东西。即使是21天系列书，也有适合看的人群，只不过，它一般也就只能看21天而已，过后就可以扔到垃圾堆。这类书只适于还没有入门的初学者，从中学到一些入门的招式。这种书在刚起步的时候一般买上一本就可以了。如果你善于使用搜索引擎，这一本书也可以省了。</p>
<p>（2）国内外高手写的实战类书籍。</p>
<p>这类书实战性很强，把技术及原理讲得很透彻。比如《windows环境下32位汇编语言程序设计》、《深入解析MFC》、《Delphi深度探索》、《深入浅出WPF》、《深入剖析Asp.NET组件设计》等。以前这类书都是从国外翻译或从台湾引进，现在国内高手越来越多，出自国内作者的也越来越多。这类书如果在你学习的每个方向看个两三本，并且通过实践消化掉，那么毫无疑问，你会成为一个优秀的程序员。</p>
<p>（3）国外大牛写的、揭露本质、有丰富思想的书。</p>
<p>这类书就是所谓的经典书了，例如《代码大全》、《编程珠玑》、《设计模式》、《重构》、《代码整洁之道》等。经典书就像一个有深度、有思想的朋友，他会给你启发、每次阅读都会有新的收获，这类书具有真正的收藏价值。看经典书永远是正确的选择，它绝不会浪费你的时间，因为经典书是无数人沙里淘金、帮你挑选过的结果。</p>
<p>然而，阅读这类书并不是一件容易的事情，读者需要有丰富的开发经验，才能与作者产生共鸣。真正能消化经典书的人其实不多，这就好像饮酒，一个新手无论如何也品不出葡萄美酒的醇香。在酒桌上，人人都把杯中酒一饮而尽，当有人点评“这个酒不错”的时候，我只能无奈的苦笑一番，真的是甘苦自知。</p>
<p>如果一本经典书你看得很辛苦，很有可能就是因为你功力未够，这种情况下不要着急，慢点来，不妨先将其先束之高阁，多看看第二类实战型书籍，过一段时间再回头来看，也许你会有新的惊喜。</p>
<h2 id="四．不要在上班时间看书"><a href="#四．不要在上班时间看书" class="headerlink" title="四．不要在上班时间看书"></a>四．不要在上班时间看书</h2><p>一个善于学习的人，首先要善于利用一切时间来学习。不知是伟大的雷锋叔叔还是鲁迅爷爷曾经说过：“时间就像海绵里的水，只要愿挤，总还是有的。”然而，当我们从上班时间中挤时间学习时，就千万要注意了，不要在上班时间看书！</p>
<p>上班时间看书不但是一件很敏感的事情，而且非常吸引眼球，很快就会引起周遭的不爽。首先老板心里不爽，他想：“我给你钱是让你来工作的，不是来学习的！”；其次同事们也不爽：“我们工作都做不完，瞧，这小子真闲哪！”用不了多久，你就会成为被众人排斥的异类。</p>
<p> 当然，你可能会说，“我工作已经做完了，经理没有安排，当然可以学习了”，其实不然。你完成了一件事情，不等于所有的事情都完成了。一个优秀的员工，应该是主动要工作，而不是被动的等工作。工作完成以后，你至少还可以：</p>
<p>（1）主动汇报给你的经理，请他来检查你的成果，并安排新的任务；<br>（2）如果公司这一段时间确实比较闲，没有什么具体的任务，可以进行代码重构、优化；<br>（3）你还可以主动请缨，承担额外的工作或更艰巨的任务。<br>（4）如果一定要学习，也只能对着电脑屏幕来学习，纸质书最多只能拿来翻阅一下，而不能一直捧着，以免影响到其他人的情绪。</p>
<h2 id="五、只学习与工作相关的东西"><a href="#五、只学习与工作相关的东西" class="headerlink" title="五、只学习与工作相关的东西"></a>五、只学习与工作相关的东西</h2><p>我曾发现不少程序员在学习方面找不到方向，一会学学C#，一会学学Java，看了最新的编程语言排行榜，又觉得该学C++。这样左抓抓，右挠挠，只会让你觉得更痒。</p>
<p>学习最忌三心二意。俗话说：“伤其十指不如断其一指”，每门都学一点，还不如专心学好一个方向。这个道理谁都懂，可是又该学哪个方向呢？难道只能跟着感觉走吗？</p>
<p>不！最实际的方向，应该跟着工作走，工作需要什么，我们就学什么，把工作需要的技能熟练掌握。我们为什么要学习和工作弱相关的东西呢？是为了转行或跳槽吗？可是，如果我们连现在本职工作都不能做好，又怎么能保证到新的岗位、用新学的技能就可以做得更好呢？</p>
<p>学习与工作需要的的东西，有很多好处：</p>
<p>首先，可以集中精力，在某一方面钻研得更加深入。所谓“百招会不如一招绝”，有了绝招，你还怕不能在“武林”立足吗？《天龙八部》中的慕容复武功博学无比，最后还不是被只会一招六脉神剑的段誉打得落花流水？</p>
<p>其次，可以学得更快、更深入，因为学习更具有针对性，而且可以立即在工作中运用，可以马上检验出学习的效果，对存在的问题可以进行深入的研究，因此掌握的知识也会更加的牢固。</p>
<p>第三，学习与工作结合在一起，工作时间也就成了学习时间，这样突破了三个8小时的限制。有人说，我们每天所有拥有的时间可以分为三个8小时，工作8小时，睡觉8小时，另外还有8小时自己可以自由支配的时间。工作和睡觉的两个8小时大家都一样，决定人生高度的是另外这个8小时。当我们把学习的焦点放到与工作相关的知识上时，工作时间中的很大一部分，同时也就成了宝贵的学习时间，这真是一举两得的美事啊。</p>
<h2 id="六．织网式的学习"><a href="#六．织网式的学习" class="headerlink" title="六．织网式的学习"></a>六．织网式的学习</h2><p>知识的广度和深度都很重要。作为一个程序员，深入把握技术细节，是写出优质代码的保证。但对于一个项目经理而言，知识的广度更显重要。项目中碰到的问题往往是综合性的，只有具有广博的知识，才能快速的对问题进行分析和定位。在程序员通往项目经理的道路上，我们必须有意识的扩大自己的知识面，形成更完善的知识体系。</p>
<p>每个人的知识体系就好比是一张网，我们学习其实就是要织这样一张网。 我曾看过渔网的编织过程，渔网虽大，也是一个结点起步，一个点一个点的编出来的，编织的过程中，始终只有一根主线。</p>
<p>学习又何尝不是这样，知识体系的大网也是由许多小的结点组成，要结这样一张网，只能由一个点起步。牵住一条主线，织出一个个的点，由点带出面，最后才能形成这张大网。</p>
<p>我曾经编写过一个网络信息采集软件，这个软件可以从具有列表页网站中按字段设置采集信息，支持自定义字段、页面多级关联、下载附件、支持多种数据库、可视化定义等特性。刚开始时，觉得这个软件也是一个比较大的功能点而已，后来发现这个不起眼的功能关联着大量的知识点，在开发过程中， 我顺藤摸瓜，各个击破，对很多知识点进行了细致的学习研究，软件开发完成后，个人的知识体系网也进一步得到了补充和完善。</p>
<p><img data-src="http://images.cnblogs.com/cnblogs_com/watsonyin/416065/%E7%9F%A5%E8%AF%86%E7%BD%91.png" alt><br>图1 由知识点形成知识网</p>
<h2 id="七．问题是最好的学习机会"><a href="#七．问题是最好的学习机会" class="headerlink" title="七．问题是最好的学习机会"></a>七．问题是最好的学习机会</h2><p>日本经营之神松下幸之助曾经说过：“工作就是不断发现问题、分析问题、最终解决问题的一个过程，晋升之门将永远为那些随时解决问题的人敞开着。”可见，工作过程中有问题是正常，没有问题那才是真正的问题。在发生问题能时，能勇于面对问题、解决问题的人，才是公司真正的核心骨干。</p>
<p>现实中，很多人总是千方百计回避问题，当上司安排一项艰巨的任务时，也是想尽办法推托。殊不知，对于个人而言，其实问题是最好的学习机会。往往那些愿意接受困难工作的人，能力会变得越来越强，那就是因为他们在克服困难的过程中取得了巨大的进步。</p>
<p>有一次，一位项目经理对我说：“有一个问题，客户有一台HP服务器要装磁盘阵列，没人会做，怎么办啊？”</p>
<p>“可以学啊，没有人愿意去吗？”</p>
<p>“我都问了，没人想去。”</p>
<p>“哦，正好明天我有时间，我也没装过磁盘阵列，那我明天去学着弄一下。”我说的是真心话。</p>
<p>第二天早上，当我准备出发时，项目经理告诉我不用我去了，因为项目组好几个同事都想去“学着弄一下”。</p>
<p>结果服务器很快就装好了，远远没有之前大家想像的那么困难嘛。更重要的是，在解决这个问题的过程中，大家都学会了怎么装磁盘阵列。</p>
<p><strong>碰到困难时，迎难而上吧，千万不要拒绝这个最好的学习机会！</strong></p>
<h2 id="八．经常思考总结"><a href="#八．经常思考总结" class="headerlink" title="八．经常思考总结"></a>八．经常思考总结</h2><p>子曰：“学而不思则罔”。只学习不思考，就会迷惑，难以把握事情的本质。这就好比一个学武之人，只习得其形，而未得其神，难以成为真正的高手。</p>
<p>一个程序员从入门，到成为高手的过程中，往往要经过几次顿悟。顿悟会让你跳出知识的丛林，一切豁然开朗，仿佛打通了全身的奇经八脉一般奇妙。记得我有一次，顿悟到了一个很简单的结论：“原来高级编程语言中的类库是封装了Windows API来实现的。”后来碰到一些自带类库无法实现的功能时，我就会想到，其实可以通过调用Windows API来实现。利用这个思路，我解决了一些看起来很难的问题，得到老板的赏识，从而很快获得提升。</p>
<p>顿悟非常可贵，然而它不是随便发生的，而是经过一次次苦苦思索之后、灵光闪现的结果。思考的过程，其实就是将外在的知识内化为自己的知识的过程，而顿悟，则是批量的实现这种内化，将无数个知识点连接在一起，达到融会贯通的境界。</p>
<h2 id="九、克服“高原现象”"><a href="#九、克服“高原现象”" class="headerlink" title="九、克服“高原现象”"></a>九、克服“高原现象”</h2><p>爱学习的人都会有这样的经历，学习持续了一段时间之后，往往会有一个瓶颈期，长时间似乎很久没有什么进步，于是内心非常着急。</p>
<p>这种情况实际上这是由人的学习规律决定的一种“高原现象”。据研究，学习者在刚开始进步快，随后有一个明显的或长或短的进步停顿期，后期进步慢，中间的停顿期叫高原期。</p>
<p> <img data-src="http://images.cnblogs.com/cnblogs_com/watsonyin/416065/%E9%AB%98%E5%8E%9F%E6%9C%9F.png" alt><br>图2 技能学习练习曲线</p>
<p>在我看来，<strong>高原期实质是一个消化期，由于前期的学习积累了太多的知识点，这些知识点在大脑中乱作一团，还没有形成一个知识体系。这时需要一定的时间来消化它，将它融会贯通，经常思考总结可以快速帮你跨过高原期。</strong></p>
<p>在处于高原期的时候，还可以换一个相关的方向来学习，例如编程语言学不下去了，你可以学习一下设计模式，设计模式也学不下去了，再换成数据库。通过学习这些相关的知识，不但补齐了知识体系中的短板，而且各个知识点之间可以互相启发，帮助你实现顿悟，跨过高原期。</p>
<h2 id="十、学习要有好心态"><a href="#十、学习要有好心态" class="headerlink" title="十、学习要有好心态"></a>十、学习要有好心态</h2><p>（1）学习要静心</p>
<p>急于求成是学习过程中普遍存在的一种心态。这可以理解，毕竟作为一个程序员，要学的东西实在太多了，而社会又是那样的浮躁，让人觉得一切都是那样的不安全、不确定，似乎只有学得快一点，才能跟上社会的脚步。</p>
<p>可是“欲速则不达”，想快快的学，往往会形成东一榔头、西一棒槌的学习方式，每一个点都没有吃透。心沉不下去，知识也会沉不下去。要想成为真正的高手，只能静下心来，一步一个脚印的攀登。</p>
<p>（2）学习是一个持续一生的过程</p>
<p>人生的过程，就是一个自我完善过程。</p>
<p>孔子曾经说：“吾十有五而志于学，三十而立，四十而不惑，五十而知天命，六十而耳顺，七十而从心所欲，不逾矩。”可见孔子也不是天生的圣人，也在不停的学习、进步，从“志于学”到最后“从心所欲，不逾矩”，孔子一共花了55年的时间。</p>
<p>作为一个程序员，更是需要不断更新自己的知识。我们所知道的东西，就像一个白色的圆圈，圈外则是黑暗的未知的世界。当圆圈越大，所接触到的黑暗部分就越多。我们只有不停的学习，打破更多的黑暗，找到更多光明。</p>
<p>（3）保持饥饿，保持愚蠢</p>
<p>看了《乔布斯传》之后，我最喜欢的一句话是“求知若饥，虚心若愚”（Stay Hungry,Stay Foolish），其实我更喜欢它更原生态的翻译“保持饥饿，保持愚蠢”。我们只有认识到自己还很饥饿和愚蠢，才会像没吃饱一样，由衷的需要学习、爱上学习。</p>
<p> 当然，知易行难，知行合一才是学习的最高境界。我也始终是一个学习者，一直在路上。</p>
<h1 id="关于App程序员泡沫"><a href="#关于App程序员泡沫" class="headerlink" title="关于App程序员泡沫"></a><a href="http://blog.csdn.net/itachi85/article/details/50364043" target="_blank" rel="noopener">关于App程序员泡沫</a></h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 做开发快七年了，对于程序员，外行人总有着数不完的讽刺和误解，但是我都懒得去解释，代码搬运工人也好，民工也罢，随他们去说吧。但是网上最近流传的程序员泡沫,尤其是APP程序员泡沫的文章导致很多我们的年轻的同行产生了疑惑,所以我这个隐藏了很久的能言善辩的老程序员出山来聊一聊这个APP程序员泡沫的话题。<br> 笔者是2010年从事安卓开发，此前做J2ee,对于安卓我有很深的感情，此前也是有意学了iOS，但是还是决定在安卓这条路上一直走到黑，在2010年一个好的安卓开发苗子工资可以过万，工作经验也就1年那样子，基本上你会点安卓都可以接近1W。想想最近某些文章中提到现在安卓开发新手动不动就要过万的工资相比，我觉得现在的新手做法并不为过：第一，以现在的北京物价房价对比2010年来说，开发的工资其实并没有涨反倒是跌了。第二，现在的开发比2010年的新手安卓开发要厉害一些，那个时候网上资料很少，书也很少，大多数安卓开发自学起来很痛苦。现在网上资料多，也有很多高水品的技术书，也有很完善的培训机制。<br> 当然现在很多APP开发存在漫天要价的现象，但是作为企业的HR,技术经理甚至老板你可以选择不要他啊。这篇文章只讨论一般的APP开发，脑残的APP开发不在此文范畴。</p>
<h2 id="1-大环境"><a href="#1-大环境" class="headerlink" title="1.大环境"></a>1.大环境</h2><p> 首先我们说说大环境，现在是互联网时代，你别跟我说什么资本寒冬，在2008年经济危机时，也没见哪个程序员饿死了。资本寒冬只是暂时的，从2010年到现在死的互联网公司多了去了，又会有无数的互联网公司站起来。人们已经离不开互联网和手机了，做为必需品你觉得会破灭吗？就如同北上广的房子一样，08年说泡沫，现在这么多年过去了，谁还会相信这是泡沫呢？</p>
<h2 id="2-App开发"><a href="#2-App开发" class="headerlink" title="2.App开发"></a>2.App开发</h2><p> 接下来我们说一说安卓开发和iOS开发，windowsphone我们暂且不谈，这家伙10年就说要干掉安卓，也就过过嘴瘾。<br> 我现在引用一篇文章的看法:”泡沫，毕竟是泡沫，终有爆破的那一天。这个时间不会很长，3到5年。随着新技术慢慢变旧（当Android和iOS变成和C语言一样老），随着大批量的人才涌入和一些公司退出（十万开发者面对一千岗位），随着很多老板慢慢发现原理和真相（APP真的只是个终端）。” 一看就外行人写的，还说当Android和iOS变成和C语言一样老，现在写C，C++赚的不比App少，Java老不老呢？2010年做Javaweb的优秀开发月薪2W+，再说Android和iOS不是语言不能和C语言比较，我牙都笑掉了。在此我们只能看到这是外行人眼红App开发工资比他高，他又转不了开发罢了，和windowsphone一样也就过过嘴瘾。</p>
<h2 id="3-安卓和ios灭亡"><a href="#3-安卓和ios灭亡" class="headerlink" title="3.安卓和ios灭亡"></a>3.安卓和ios灭亡</h2><p> 有不少眼红的人希望Android和iOS灭亡，就像塞班一样，看Android和iOS灭亡了你们怎么办？笔者的同学以前做塞班的，塞班灭亡了他转做iOS，现在一样很牛逼，因为人家C++强，转iOS有优势。同样如果安卓灭亡了，安卓开发可以转Java，iOS。其实年轻的App开发不用担心这些，当你的技术达到一定层次，语言已经不是阻碍我们的脚步了，笔者1周就学会obj-c,写iOS代码了。同时也给年轻的App开发建议就是要注重基础，安卓和iOS只是武学招式，真正使他们发挥威力是你的内功，也就是你的基础。</p>
<h2 id="4-互联网职位稀缺性"><a href="#4-互联网职位稀缺性" class="headerlink" title="4.互联网职位稀缺性"></a>4.互联网职位稀缺性</h2><p> 一个优秀的程序员是十分难求，他不是去熬年头就能得到的，他需要付出很多，阅读很多书籍，看过很多技术文章，敲过很多高质量的代码，无数个Bug折磨过的，一步步才培养起来的，反观其他的互联网职业我就不便多说什么了，优秀的是有，但更多的是熬年头拼学历，他们所付出的努力远远没有优秀程序员付出的多，他们所创造的价值也未必有他们想象的大。现在有产品思维能言善辩的App开发越来越多，他们可以去抢产品经理的饭碗，但产品经理很难抢程序员的饭碗，这也说明了优秀App程序员的稀缺性。现在我在招聘网上找一个3年以上经验的安卓开发都很难，就算找到了也很容易被别的公司抢走。现在市场上最多的是1到2年的App开发，还有一些从别的行业转过来的App开发，靠谱的很少。</p>
<h2 id="5-提升自己让别人去喷吧"><a href="#5-提升自己让别人去喷吧" class="headerlink" title="5.提升自己让别人去喷吧"></a>5.提升自己让别人去喷吧</h2><p> 我们中国人的一大劣根性就是见不得人好，这是正常现象，那么怎么提高自己使得自己更强，让别人更眼红呢？</p>
<p> <strong>看清自己并尽早规划职业生涯</strong></p>
<p> 早看清自己的人早确定方向，看到自己的优点避开缺点，如果你热爱开发你就继续干开发成为App架构师。如果你能言善辩，组织能力强又敲的一手好代码，那就去做技术经理。如果你只是为了钱而不喜欢代码，那你得想办法尽快脱离这个行业。<br> 如果闷头去敲代码这显然是大部分程序员都能做到的，但是你有没有想过程序员这个职业可以做一辈子嘛，早做打算并且要对自己的职业生涯负责，找到自己的本性和擅长并发掘自己的潜力，从而决定自己是做个技术经理、架构师还是个什么其他相关的职业，工作多年如果还是和刚入行的干一样的活这显然不会提升自身的价值也迟早会被这个行当所淘汰。</p>
<p> <strong>做有产品思维的程序员</strong></p>
<p> 平常多看看其他的App是怎样的，和自己的对比下，每做一个需求要考虑它是否是必须的，能为用户带来什么，而不是产品经理让做什么就做什么想都不想。</p>
<p>  <strong>业余多看书，多写代码，写技术博客，找到适合自己的学习方法</strong></p>
<p> 想要脱颖而出你不付出努力又怎么能行，平常可以写一些自己想写的代码，把他写到博客上或者建立自己的代码库，写博客可以提高自己的写作能力同时也检验你的技术的掌握程度，你会发现你为了写一篇技术文章会查很多资料看很多书，遇到很多的坑，这是你去看别人的技术文章所得不到的。技术首先要做到先精，再做到广，什么叫做精，至少我现在的也不敢说精通Android，不会的实在是太多了。而我现在看到的就是很多开发什么都想搞，结果什么都搞不明白，今天学了Android，明天看看iOS，后天H5和RN火了又都去学，结果什么都不专什么都不精，知道慕容复嘛，会的再多也打不过专精一门武学的乔峰吧。只有你先精一门的前提下再去深入的研究其他的技术这才是对的。不要跟我说什么全栈工程师才是未来的大势所趋，才是王道，跟我说这个首先要明确什么是全栈工程师？全栈工程师至少要精通一门，会一堆技术结果全是半吊子也好意思说自己是全栈？作为Android开发多看看底层的源码，Java的基础，设计模式和算法以及iOS的基本知识。更重要的是在学习的过程中找到适合自己的学习方法，比如我就是多看书，然后敲一敲自己喜欢的代码，写博客总结归纳。关于书，我建议大家还是多多宜善，不仅仅限于专业的。古时文人为了一本书可以受饿攒钱去买，但现在的大多数人，在吃穿玩上花了很多的钱，唯独在书上却斤斤计较，希望大家都能养成爱读书、读好书的好习惯。</p>
<p> <strong>提高自身形象，培养软实力</strong></p>
<p> App程序员同时也需要跟别人打交道，至少要穿的得体干净，别自己舒服却让别人不舒服。多培养自己沟通的能力，多想想其他人是怎么想的，培养自己的同理心，管理好自己的情绪，学会什么时候该发火，什么时候该淡然一笑，学会对着那些令人无比生厌的小人报以自然的微笑。网上讨论什么牛逼的人应该脾气好，但我不这么认为，该霸气时就应该霸气。如果我们程序员能言善辩，精通业务，人际关系好，人脉广，并且还能敲的一手好代码，这绝对非常恐怖。</p>
<p>  <strong>保持良好的技术敏锐度和前瞻性</strong></p>
<p> 作为一个开发，技术的敏锐度和前瞻性是极其重要的。做技术难免会遇到技术的更新和新技术的出现，如何去选择变得极为重要，因为人的精力有限，这一点选择远远要比努力重要。首先要选择自己擅长的那门技术相关的新技术来进行学习，接下来再考虑其他的新技术。说到其他”新”技术，不得不提到H5和RN，作为一个移动开发者和一个手机用户，并不看好这两门”新”技术。从用户的角度来看，我们更追求高品质和最好的体验，显然H5和RN都无法达到这一点，另外想想PC端也出现了很多web应用，但至今都不温不火的，因为体验太屎了，我宁可下个客户端也不会在web应用上做操作。总结一句，就是H5难成大器。作为一个开发者，H5只适合一些商城或者广告类的界面，它只是一种解决方案，想要拿它做App那太扯了。有人在2011年就说H5是趋势是潮流，过了5年还在说，是不是等我退休了你们还在说H8是趋势呢。至于RN，可能未来会有一些进展，国人太喜欢炒作也太浮躁，Android和iOS都有自己的成熟的开发框架，非要在此之上罩上一层去写js，感觉就像是不脱裤子拉屎一样（我实在找不到很好的形容）。用你们的脑子想想，未来人们追求的是什么，是极致和高品质，为了所谓的商业模式来应付用户群体必定走不远，当然想捞一票就跑的可以忽略极致和高品质这个问题，用户不会关心你用了什么技术，他们只关心好不好用。不好用的直接扔垃圾箱里，好用的就算时常让他们下载新版本也会有人用。总结一句，RN可能就是一个搅屎棍，它的出现可能会让很多人趟浑水并且浪费很多时间。对于RN现在我也是持观望态度，因为我发现真正重要，能让我走的更远的是基础和深度，而不是这些前途不明的潮流框架。总之，对于新技术要有自己的判断，不要听风就是雨。</p>
<p>  <strong>选择好平台，不要计较一时得失</strong></p>
<p> 在好的平台才能得到最大的利益，才会发挥自己最大的能力，相反在差的平台以及不适合自己的岗位上就算再努力也白费，除了你手里那点钱什么都得不到，还会赔上最有价值的青春。有时要学会放弃，面对不好的平台、不适合自己的岗位当断则断，计较一时的金钱得失可能会葬送自己整个人生。就好比金子扔进茅坑它永远不会发光，一个铝片放在舞台上却能够闪光，不管我们是金子还是铝片一定要区分茅坑和舞台。既要活在当下同时眼光也要放远。</p>
<p>  <strong>去做去行动</strong></p>
<p> <strong>大道理很多人都懂，为何脱颖而出的就那么几个人，因为他们不只懂而且也去做了</strong></p>
<h1 id="笔记体系"><a href="#笔记体系" class="headerlink" title="笔记体系"></a>笔记体系</h1><p>自己生命、生活和人生的设计师</p>
<p><a href="https://blog.cleancoder.com/uncle-bob/2015/11/18/TheProgrammersOath.html" target="_blank" rel="noopener">程序员的誓言</a></p>
<p>鲍勃·马丁大叔（Bob Martin）是软件开发理论的巨头之一。他提出的程序员誓言，是这个行业的基本职业道德。</p>
<p><img data-src="https://www.wangbase.com/blogimg/asset/201910/bg2019102502.jpg" alt></p>
<p>誓言由关于软件开发人员的九个道德目标组成。</p>
<p>为了捍卫和维护计算机程序员的职业荣誉，我承诺，尽我所能和判断力：</p>
<p>1、我不会产生有害的代码。<br>2、我制作的代码永远是我最好的<a href="https://hazyman.com/Profession/Product/">作品</a>。我不会故意允许在行为或结构上有缺陷的代码。<br>3、每次发布时，我都会生成一个快速、可靠、可重复的证据，证明代码的每个元素都应该正常工作。<br>4、我将经常发布<a href="https://hazyman.com/Wisdom/MVP/">小版本</a>，这样我就不会妨碍其他人的进展。<br>5、我会抓住每一个机会，无畏地，不懈地改进我的代码。我永远不会损害它们。<br>6、我将尽我所能保持自己和他人的生产力。我不会做任何降低生产力的事情。<br>7、我将继续确保支持其他人的工作，并且他们也可以支持我的工作。<br>8、我将对幅度和精度做出诚实的估计。我不会作出做不到的诺言。<br>9、我将永远不会停止学习和改进我的手艺。</p>
<p><a href="https://hackernoon.com/how-many-software-engineers-are-there-in-the-world-in-2019-us-europe-india-russia-and-china-c016d38oc" target="_blank" rel="noopener">一家数据公司</a>称，2018年全世界的软件工程师有2230万人，中国有190万。</p>
<p><img data-src="https://www.wangbase.com/blogimg/asset/201811/bg2018110201.jpg" alt></p>
<p>Standing on Shoulders of Giants</p>
<p>站在巨人的肩上，才有可能在有限的时间里取得最大的成绩…</p>
<p>发现趋势，追随趋势，顺势而安、乘势而起、造势而雄，不做旁观者，要成弄潮儿<br>如果进入了痛苦的高原期，请记住：付出与收获成正比，成功之路本身就不轻松，与戴皇冠必承其重，<br>此时，你需要坚信自己的判断和选择，坚持、坚持再坚持，基于量变到质变的法则，<br>一般都会“踏破铁鞋无觅处，得来全不费工夫”，届时，”待到山花烂漫时，君在丛中笑”。</p>
<p>学之者不如好之者，好之者不如乐之者，兴趣是最好的老师<br>化整为零，先易后难，循序渐进，各个击破，坚持是成功的密码，自胜者强</p>
<p>若贪多求快，则欲速不达<br>若聚焦极致，则迎刃而解</p>
<p>别急，慢慢来，一切都来得及<br>架构思考、动手实践、检索分析、复盘总结、循环递进</p>
<h2 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h2><p>C语言——了解计算机底层技术原理，数据结构+算法；<br>Python语言——AI的有力工具；<br>Kotlin JAVA——Android应用语言</p>
<p>德国工业设计大师 Dieter Rams 是功​​能主义的坚定信徒，他的设计理念就是他的名言：”少，但更好”（less but better）。</p>
<p>– 《<a href="https://uxdesign.cc/great-products-do-less-things-but-better-5dde0ee3fc76" target="_blank" rel="noopener">伟大的产品做得少，但更好</a>》</p>
<p><a href="https://dave.cheney.net/2019/09/24/be-wary-of-functions-which-take-several-parameters-of-the-same-type" target="_blank" rel="noopener">警惕多个同类型参数的函数（英文）</a></p>
<p>一个函数如果有多个同类型的参数，比如两个参数都是字符串f(string A, string B)，作者认为必须警惕，因为容易误用，必须查文档才能分辨每个参数的含义。所以，函数定义时最好避免同类型的参数。</p>
<h3 id="我为什么喜欢编程"><a href="#我为什么喜欢编程" class="headerlink" title="我为什么喜欢编程"></a><a href="http://www.ruanyifeng.com/blog/2009/10/why_i_love_programming.html" target="_blank" rel="noopener">我为什么喜欢编程</a></h3><p>作者： 阮一峰<br>日期： 2009年10月18日</p>
<p>这个周末，我在家核对More Joel on Software的最后定稿。</p>
<p>此书已经在申请书号了，一拿到书号，就可以印刷和销售了。所以，不出意外的话，年底之前就能上架。</p>
<p>在复核的过程中，我又读到了书中让我最有共鸣的一段话：Joel谈为什么公正对程序员很重要。</p>
<p>我不知道别人的情况，我自己喜欢编程，很大的原因就是觉得程序的世界更公平公正，谁对谁错，只要运行一下代码就知道了。这同现实世界截然不同，在现实的世界中，只要你有权有钱，善于搞人际关系和钻制度的空子，你就能把错的说成对的，把黑的说成白的。老老实实、埋头苦干的人，眼睁睁看着乾坤颠倒、小人得志，而只能束手无策、一筹莫展。</p>
<p>我们生活的这个国家，是一个禁止自由思考、党决定一切的国家。在这里，如果你想不撒谎、不干坏事、并且被公正地对待，那么可能你只能去编程了。</p>
<p>==================</p>
<p>不搞政治</p>
<p>作者：Joel Spolsky</p>
<p>译者：阮一峰</p>
<p>老实说，只要有两个以上的人待在一起，就会有政治。这很自然。我说”不搞政治”的真正的意思是”不搞恶性的政治”。程序员早就练出了对公正有非常良好的判断力。代码要么能运行，要么不能。坐在那里争论代码是否有问题，这是毫无意义的，因为你可以运行代码，答案自然就有了。代码的世界是非常公正的，也是非常严格有序的。许许多多的人选择编程，首要的原因就是，他们宁愿将自己的时间花在一个公平有序的地方，一个严格的能者上庸者下的地方，一个只要你是对的就能赢得任何争论的地方。</p>
<p>如果你要吸引程序员，你就必须去创造出这样一个环境。当一个程序员抱怨”人际关系复杂”时，他们的意思明白无误，就是指任何个人因素超过技术因素的环境。程序员在完成手头任务时，不被允许使用最合适的编程语言，而是被命令只能使用另一种特定的语言，原因仅仅是老板喜欢这种语言；没有什么比这更让人气愤了。晋升的原因不是成果，而是人际关系；没有什么比这更让人抓狂的了。程序员被迫去做技术上落后的东西，仅仅因为上级或者得到上级支持的人坚持这样；没有什么比这更让人发火了。</p>
<p>没有什么比因为技术原因赢得一场由于政治原因本来要输掉的争论更让人心满意足了。当我在微软公司刚开始工作的时候，有一个正在开发中的大型项目走入了歧途，项目的代号是MacroMan，目标是创造一种图形化的宏语言。真正的程序员遇到这种语言会很有挫折感，因为图形的特性让你真地没有办法完成循环和条件判断功能。此外，对于那些非程序员的用户，这种语言也不会有很大作用，因为我觉得那些用户不会习惯算法思维，没有办法很快地理解MacroMan。当我说出对MacroMan的负面评价时，我的老板告诉我：”如果火车要出轨，没有东西能够阻挡。算了吧。”但是，我还是不放弃，一再地不断地争论。那时我刚走出学校，在微软公司中差不多跟谁都没有利害关系，所以，渐渐地，人们开始倾听我的核心观点，MacroMan后来终止开发了。我是谁并不重要，重要的是我是对的。非政治性的组织就应该这样，这种组织才会让程序员感到高兴。</p>
<p>总的来说，关注你的组织的社交动态变化，对创造一个健康的、令人愉悦的工作环境是很关键的，这样可以留住程序员和吸引程序员。</p>
<h3 id="为什么Joel不谈软件了？"><a href="#为什么Joel不谈软件了？" class="headerlink" title="为什么Joel不谈软件了？"></a><a href="http://www.ruanyifeng.com/blog/2010/03/why_joel_stopped_blogging.html" target="_blank" rel="noopener">为什么Joel不谈软件了？</a></h3><p>作者： 阮一峰</p>
<p>日期： 2010年3月16日</p>
<p>3月初的时候，Joel发布了一个惊人消息（中文版见下文）。</p>
<p>他将不再写作网志了！就在3月17日，”Joel谈软件”开张十周年的纪念日，他就会停止自己的写作。</p>
<p>全世界排名第一的程序员网志要关门了？我简直不敢相信，不知道3月17日他会怎么告别，只能心神不宁地等着那一天。</p>
<p>结果昨天晚上，Joel出人意料地贴了一篇新文章，做了一些澄清。</p>
<p>首先，关于软件开发的文章，确实不会再写了，因为除了声明中提到的原因，Joel感到他已经有点在重复自己了。其次，讨论技术细节的文章，以后依然会写，比如Mercurial教程。最后，近期还会有一篇关于Twitter的文章，已经写了一半。</p>
<p>我对此感到很可惜，又一个自己喜欢的作者要从网上消失了。而且，Joel的风格太独特，将来恐怕不会再有这样的人了，滔滔不绝地把自己对软件开发的想法写成1000篇文章，免费给大家看，一写就是10年，而且写得那样生动活泼、富有启迪。这样的事情只可能在互联网诞生的初期发生，只有那种时候，才会让人产生异乎寻常的创造力和热情，因为无论你做什么，都是前无古人的，你都是在创造。等到网络模式成熟了，大家也就司空见惯了，没有太高的热情了，一切都是循规蹈矩。另一方面，我也很高兴，幸亏自己翻译了Joel的一本书，否则未来恐怕不会遇到这样的机会。</p>
<p>下面就是Joel告别Blog的声明，像他的其他文章一样，包含着令人深思的观点，非常值得一看。不知道这是不是最后一次我翻译他的文章了，但愿不是吧。</p>
<p>=======================</p>
<p>告别网志的时候到了</p>
<p>作者：Joel Spolsky</p>
<p>译者：阮一峰</p>
<p>发表日期：2010年3月1日</p>
<p>出处：inc.com</p>
<p>你创立了一家公司，做出了一种优秀的产品，现在你需要把消息传播出去。但是，你没有钱买广告，也没有钱雇佣公关公司，你的预算最多只够雇一个销售员。然而优秀的销售员都是聪明人，不会糊涂到愿意为你这样的小公司工作。</p>
<p>所以，你总是会想到网志。</p>
<p>当前，好像每一个初创公司，都有一个自己的网志。但是，其中99%都有问题。什么问题呢？那就是他们在网志中只谈自己，发一些招聘消息，展示一些新产品，秀一下员工一起野餐的照片。这样的文章，看上去当然很可爱。你的亲爱的妈妈，肯定很喜欢读。但是糟糕的是，除了你的妈妈，其他人都不感兴趣。大多数的企业网志，几乎没有任何读者，没有访问量，对销售也毫无影响。长此以往，网志的更新也越来越少，间隔的周期越来越长（如果撰写网志的责任由多个员工承担，情况就更是如此），最终网志就变得荒芜了。</p>
<p>我开始写”Joel谈软件”的时候，几乎没什么人写网志。那是10年前的事，那时我甚至还没有成立自己的公司。我的网志很快就在程序员中变得流行了，上面有各种各样的内容—-如何写出漂亮的代码，如何在短得不合理的时间中拿出产品，如何得到更多的薪水等等。访问人数一直在上升，到了后来，一个月的独立访问者超过100万人。它也使得人们对我的公司”Fog Creek”和我们的产品，产生了兴趣。</p>
<p>那么，企业网志的成功秘诀是什么？怎样才能把网志转化为影响力、销售额和利润？其实，我自己都不太清楚应该怎么做。直到去年，我参加了一个软件研讨会，在会上，一个著名的游戏开发者Kathy Sierra做了一个发言，我听了以后茅塞顿开。她讲了一个很简单的观点，完全解释了为什么我的网志能为我带来商业成功，而其他那么多公司的网志都做不到。</p>
<p>根据她的观察，要让企业网志真正有影响力，就必须谈一些比你的公司、你的产品更大的东西。这听起来不难，但是实际上不是，你需要严格的自律，不谈你自己和你的公司。表面上，网志似乎是一种个人化的媒体，很多时候确实如此。但是，Kathy Sierra说，一旦你使用网志来推广企业，你就不能用它谈论自己感兴趣的事情。你必须谈一些你的读者愿意看到、或者希望看到的东西，这样他们才会变成你的客户。你必须让你的读者感到满意。</p>
<p>举例来说，如果你销售的是照相机的闪光灯，你就不要去谈产品的技术细节，也不要去谈旺季的促销计划（优惠10%！）。你要介绍拍出优秀照片的10个窍门。</p>
<p>如果你开餐馆，网志就不要介绍你的菜单，而要介绍一些好吃的食品。你这样才能吸引，对你的餐馆不感兴趣的饕客。</p>
<p>如果你生产高档巧克力，就不要在网志上写你去多米尼加共和国收购可可豆的旅程，因为这只对你个人有意义。你应该写详细的教程，介绍如何自己做出草莓巧克力。以后的十年中，任何一个美食家或面包师，想在Google中找到制作草莓巧克力的方法，他就会发现你的文章。帮助你的读者做出美味食品，很可能会吸引来一些这种食品的购买者，这就是一个成功的企业网志的意义。介绍前往多米尼加的旅程，只能吸引那些想去多米尼加的人。除非你是搞旅游的，否则你不应该写这个内容。</p>
<p>回顾起来，”Joel谈软件”实际上是一本内容高度集中、专门写给程序员看的小型杂志，以介绍一些软件开发的实用主义观点为主。我也利用它，为自己的公司做免费广告，但是那些广告实际上更接近社论，而不像商业目的的广告。我写的最受欢迎的文章，都与我自己和我的公司无关，比如我写过如果软件公司想要重构代码，那么千万不要推倒重来。</p>
<p>一旦大量的程序员成为了我的读者，他们中的许多人就会变成我的公司的顾客。因为读者群实在是太集中了，导致我们公司开发的产品，只有供程序员使用的才会成功，其他的都不成功。那些都是很优秀的产品，但是就是不成功，因为它们不是供程序员使用的，而我们又没有能力将它们推广到非程序员的目标客户中。</p>
<p>当然，网志占用了我大量时间。它是一种劳动密集型的手工推销方式。合计起来，我用来做自己的网站、写作相关书籍、录制视频、参加网志会议等等的时间，大约占到过去十年我创业总的投入时间的三分之一。那也就是整整三到四年的工作量。</p>
<p>这样做是否值得？你也应该这样写网志吗？</p>
<p>这样说吧，我很受用这个方式，但是当我观察其他人越多，就越发现很多成功的初创公司，不把大量早期创业时间用来架设一个受欢迎的网志，结果也能得到客户，并且快速地发展起来。</p>
<p>而且，更麻烦的是，除了我自己之外，我真的找不到其他任何通过写网志而获得成功的企业家。</p>
<p>过去十年的大热门技术公司，往往都没有一个像样的网志。Twitter、Facebook、Google的网志，都充满了喋喋不休、乏味透顶的新闻稿，最多只是略加改写，好让文章看上去不是那么一本正经。Apple公司实际上根本没有网志，哪怕它开发出了好几样优秀的革命性产品。同时，微软公司倒是有相当一大批很不错的网志，但是毫无作用，这家公司还是给人一种笨重迟暮的印象。</p>
<p>所以，我觉得是时候了，应该从网络日志中退休了，能够在狭小美好的程序员世界成为一个互联网名人，已经足够了。3月17日就是”Joel谈软件”开张十周年的纪念日，我将最后发一篇正式的文章。同时，正常情况下，我也将停止录制视频节目和公开演讲。Twitter？”那玩意太可怕了，我不会去玩的。抱歉，我没法只用140个字母，就告诉你原因。”</p>
<p>真正原因是，虽然我一如既往喜欢写Blog，但是我的时间越来越少了，因为Fog Creek正在不断发展壮大。我们现在有32个雇员，以及至少6条正式的产品线。我们的顾客也已经多到令我无法自由写作的地步，我很怕自己漫不经心写出的一句话，会侮辱到某位顾客。我的日常工作占用了大量时间，以至于无法集中精力，写作一点有思想性的东西，哪怕每个月只写一篇到两篇。</p>
<p>大量证据也表明，推广Fog Creek的产品有很多有效的其他方法。过去，我们倚重网志作为营销渠道，忽略了其他方法。我现在意识到，网志使得我和Fog Creek，成为了一个很小的池塘中的大鱼。结果就是，对于那些经常阅读网志的5%~10%的程序员来说，我们是无可争议的头号产品。同时，对于除此之外的每个人，我们完全是默默无名的。</p>
<p>我希望，放弃网志就好像让一个双眼发展不均衡的孩子，戴一付眼镜。是时候让那只好的眼睛休息一会，而让那只比较弱的眼睛有一个成长的机会了。我的公司需要证明一点，就是我们不依赖于单一渠道推广自己的产品，这是任何一家其他公司都已经明白的道理。在目标市场的一个细分领域中，我们已经彻底做到饱和了，现在我们不得不去大得多的其他领域，寻找更多的潜在顾客。</p>
<p>对于我的读者，感谢你们过去10年中对我的关注。没有你们，我不可能做成这个网志。感谢你们高质量的Email、留言、twitter发言、评论文章，所有这一切使得我的过去10年成为一次美好的旅程。我很享受我们在网上形成的这种关系，期待未来在我的公司的某个发展阶段，我能够与你们有面对面的交流。</p>
<h3 id="等几年，再用新框架"><a href="#等几年，再用新框架" class="headerlink" title="等几年，再用新框架"></a><a href="https://medium.com/@karti/learn-new-frameworks-after-a-few-years-not-immediately-f8b44dc0ed72" target="_blank" rel="noopener">等几年，再用新框架</a></h3><p>在技​​术领域，每个月都有一个新框架。例如，iOS 就有一个新的 UI 框架 SwiftUI。</p>
<p>我的建议是，等待几年再去学习它。不要担心会错过机会，这不是飞机航班，你仍然随时可以登机。任何时候，你都不应该因为害怕落后于潮流，而做出决定技术决定。如果你学习一个 UI 框架，它就应该对你的业务带来帮助，而不是为了学而学。</p>
<p><img data-src="https://www.wangbase.com/blogimg/asset/202001/bg2020010907.jpg" alt></p>
<p>新技术总是被其制造商大肆宣传，他们不会说：”我们的新东西是平庸的”，他们有动机大肆炒作，以光彩照人的方式谈论自己的产品，这对他们有好处。一些在职业生涯早期的开发人员，也会加入炒作，他们是第一次见到这样的东西，因此非常兴奋。总之，新框架总是有自己的支持者，你问他们这个框架好不好，他们总是会说这很棒。</p>
<p>但是，新框架总是有这样或那样的问题，很少像承诺的那样好。它在某些方面可能会很好，而在其他方面则很糟。文档通常不完整，如何有效使用框架也没有形成规范。一旦你使用了它，团队的其他人也必须学习它，才能让整个团队适应你的代码，这给团队带来了额外的负担。因此，等待几年消除所有这些问题是有意义的。</p>
<p>如果你急于采用一个框架，可能会花费很多时间来研究它，之后很可能会发现，它根本不起作用。或者它确实有效，但不适用于你。再或者它以某种方式工作，但在性能或者向后兼容性上有严重问题。新框架就是一个未知数。</p>
<p>如果你采用了新框架，结果它无法正常工作，而你又必须切换回去，就要付出两次过渡成本。</p>
<p>新框架的出现并不会立即使旧框架过时。例如，Swift 1.0 是2014年发布，但真正可用是在2016年。这也不意味着你2016年就要使用它，因为2016年的版本是最早可投入生产的版本，真正成熟可能要等到2018年的版本。因此，新的语言、工具或框架不会淘汰旧的语言、工具或框架。过渡期会有很多年，在此期间，你可以随时采用新技术。没必要在出现的那年就赶上潮流。</p>
<p><img data-src="https://www.wangbase.com/blogimg/asset/202001/bg2020010908.jpg" alt></p>
<h3 id="为什么大多数程序员都是男的？"><a href="#为什么大多数程序员都是男的？" class="headerlink" title="为什么大多数程序员都是男的？"></a><a href="http://www.luojiji.com/thread-3857-1-1.html" target="_blank" rel="noopener">为什么大多数程序员都是男的？</a></h3><p><img data-src="https://img3.doubanio.com/view/subject/l/public/s27668186.jpg" alt></p>
<p>有个现象你肯定也留意过，那就是，程序员、科学家这些职业一般都是男人的天下，很少有女性，这是为什么呢？有本书叫《<a href="https://book.douban.com/subject/26177973/" target="_blank" rel="noopener">是高跟鞋还是高尔夫修改了我的大脑</a>》，作者就提了个观点，说之所以女程序员、女科学家比较少，跟性别差异啊大脑结构啊能力啊统统没关系，完全是<code>外界环境和心理因素</code>造成的。<br><code>比如，咱们一般都觉得，搞计算机、编程序的人，都有些</code>极客风格，喜欢独来独往，黑白颠倒，沉闷孤僻<code>。你想，女生们谁想被看作是这种人呀？华盛顿大学就曾做过一个实验，测试大学生对计算机科学的兴趣。他们专门布置了两个教室，一个是典型的极客风格，什么《星际迷航》海报、快餐、电子产品、技术类图书等等，满屋都是；而另一个教室就是很普通的房间。结果发现，在极客风格的教室里，男生比女生对计算机科学更感兴趣。但在另一个普通房间，男生和女生对计算机的感兴趣程度几乎一模一样。这就说明，你选择从事哪份职业，受外界环境影响很大。</code>极客风格的房间就会给女生一种心理暗示：计算机科学是属于男孩子的，根本就不适合我。`</p>
<p>另外，自我评价也很重要。有科学家曾调查了几万名学生的学习成绩，以及他们对数学能力的自我评价。结果发现，在实际成绩差不多的情况下，男生对自己数学能力的打分却比女生高出一大截。这是因为，社会上普遍认为男生更擅长数学，所以他们就会美化自己的数学能力，将来就更有可能从事科学、数学相关的工作。其实，<code>跟女生相比，他们并不是真正擅长数学，而是觉得自己擅长而已</code>。</p>
<p>所以你看，女性很少选择计算机、科学职业，不是因为她们能力不行，而是外界环境和自我<a href>认知</a>造成的。这就像是以前大家都有一种偏见，觉得女性只能当家庭主妇。可后来人家走向职场，不照样也很成功吗？</p>
<p>本文源自：《是高跟鞋还是高尔夫修改了我的大脑》</p>
<p>我希望程序可以更短，不是以行数或字符衡量，而是以解析树衡量。<br>– <a href="https://news.ycombinator.com/item?id=21232352" target="_blank" rel="noopener">保罗·格拉汉姆（Paul Graham）</a>。他已经54岁了，发布了一门自创的计算机语言 Bel。有人问他目的何在，他做了上面的回答。</p>
<h3 id="程序员真的需要高智商吗？"><a href="#程序员真的需要高智商吗？" class="headerlink" title="程序员真的需要高智商吗？"></a><a href="https://www.toutiao.com/i6450594237967761934/" target="_blank" rel="noopener">程序员真的需要高智商吗？</a></h3><p><img data-src="http://p1.pstatp.com/large/310b00090db1c7a62130" alt><br>你一定很聪明吧！？你数学一定很好吧！？你的逻辑思维一定很强吧！？我觉得你们程序员都很牛逼！</p>
<p>绝大多数程序员都被问过这种被直接带有肯定的问题。自己即使嘴上回答 “不是啦”，可是心里还是很骄傲。</p>
<p>我以前也这样，现在变成熟后就不这么认为了。</p>
<p>程序员真的需要高智商吗？</p>
<p>我认为不需要。人类发明编程，就是想用编程来弥补人类的大脑缺陷。</p>
<p>在编程技术刚被发明时，程序是用来帮大学教授做科学计算的。随着硬件的发展，程序的应用越来越广泛，除了科学计算外，还可以在办公、医疗、航天等多个领域发挥其价值。</p>
<p>人类要开发大量具体的应用程序，编程语言从机器语言往高级语言发展就成了必然趋势。编程语言越接近高级语言，就越符合人类的思维方式。</p>
<p>从简易程度的角度来看，编程语言发展到高级语言后，编程这件事情就变得更容易了。</p>
<p>随着近些年开源软件的发展，大量优秀的开源软件把创造应用程序这件事情变得更简单，甚至可以说是 “傻瓜式”。如果你在今天想创建一个 Web App，一分钟就可以搞定。</p>
<p>编程过程变简单了，用编程方式来创造应用也变简单了，程序员的工作是不是也就变简单了呢？答案是肯定的。</p>
<p>我刚参加工作时，参与开发一个通讯录（BREW 操作系统上的应用），公司投入了 30 多个工程师。</p>
<p>如今，在 Android 操作系统上开发通讯录（甚至功能更完善），只需要投入 2-3 个高级工程师即可。这种变化并不是说以前的工程师比现在的工程师能力差，而是现在的开发过程变得更简单了。</p>
<p>在日新月异的技术发展过程中，我在招聘工程师的态度上也发生了变化。</p>
<p>我以前比较注重项目经验（很多公司在招聘时会应聘有过类似项目经验的候选人），现在我更看重面试者的谦虚和处理细节的能力。</p>
<p>2016 年我面试了 40 多个程序员，其中有两个同学让我印象深刻：</p>
<p>典型1：他很聪明，但不具备创造能力</p>
<p>在被淘汰的人中，有一个同学在学校期间就自学 Android。他给我展示了五个 Android 应用，并很自信地对我说：“这都是我一个人以外包身份给某公司开发的。”</p>
<p>刚开始我和他做了一些简单的交流：</p>
<p>Q: 你开发能力这么强，对薪水的预期是多少？<br>A: 20K。<br>Q: 你的基础怎么样？<br>A: 我是自学 Android，基础可能不是很好，但是我的动手能力很强。我可以一个人完成一个项目。<br>Q: 你平时写代码时遇到问题都是怎么解决的？<br>A: 网上找答案。<br>Q: 在运用一个 Activity 中，你了解里面存在多少种设计模式？<br>A: 我只听过设计模式，但没去看，以后打算看。<br>Q: 你最近一个项目中，用到的一个最熟悉的开源项目是什么？<br>A: Rxjava（作者注：Android 一个开源库）。<br>Q: 你能给我阐述一下 Rxjava 的思路吗？<br>A: （他把用法给我讲了一遍。）<br>Q: 这个用法的背后知道为什么吗？<br>A: 不知道。</p>
<p>后面我问了很多他在工作中实际用到的一些技术，<code>基本上是知道怎么用，但不知道为什么。</code></p>
<p>从动手能力方面来看，他就是人们传统认为的那种 “聪明” 的人。从他脸上流露出的自信我相信这些应用都是他做的。但是，基于以下几点我淘汰了他：</p>
<p>1.基础很差。他虽然动手能力很强，但是对技术细节不理解。<br>2.写代码靠模仿。他对代码的认知还停留在 copy 和模仿阶段，如果不参考事例，就不会写代码。<br>3.创造力差。他适合一个萝卜一个坑的小公司或外包公司，但不适合创业公司，员工的创造力是创业公司渴望获得的。<br>4.有点骄傲。他可能认为自己是属于 “聪明” 那类的，而且不能发现自身的缺点、以及不太能接受别人对他的评价。在管理上会带来风险。</p>
<p>互联网行业中，很多工程师和这位同学一样。这类同学统一犯了一个错误：被”简单”的技术蒙蔽了双眼，使得找不到进步方向和空间。</p>
<p>典型2：他很踏实，而且很有想法</p>
<p>这位同学是一位 C++ 工程师。</p>
<p>我并没有从基础技能入手，而是直接了当地把想招他进来做什么事情告诉他。他刚开始显得很紧张，可能是觉得我面试的套路很奇怪吧。</p>
<p>我为了调节气氛，就在白板上画出我的想法。在不断地沟通后，他似乎明白我的意思，思考了一会儿就在黑板上画出了解决方案。</p>
<p>他提出的解决方案非常初步。虽然从大面上看似能走通，但是关键点和细节点都无法体现。我紧接着围绕方案提出了一些问题，他都能不紧不慢地一一解答。</p>
<p>为了了解他技术的深度，我开始围绕方案问技术的实现细节。比如，模块间的通信机制、事件队列的处理方法、数据共享的方式以及网络交互的实现细节等等。</p>
<p>这些技术细节非常考验局部架构能力，但他都能说出自己的见解。</p>
<p>我们最终讨论出了一套方案，并整理出了技术的难点。整个面试过程就像是一个方案讨论会，非常地自然。</p>
<p>在最后，我问他对这件事情有信心做吗？他的回答大致如下：</p>
<p>这件事情会很难，而且很多东西都没接触过。但是事情是可以的，也有价值。在具体实现上会遇到很多技术难点，需要花时间，但一定能做。</p>
<p>他虽然没有正面回答问题，但是我很满意。主要因为两点：<code>第一，他能正确认识到事情的难度；第二，他不惧怕挑战。</code></p>
<p>至于信心这东西，和决策者的坚定目标有强烈的关系，团队的管理者有足够强的目标，同学们就会有足够的信心。他既然不惧怕挑战，在后续工作中我要不断为他输入信心。</p>
<p>面试结束后，我录取了这位同学。基于以下理由：</p>
<p>1.理解力强。他能非常快速地理解我的问题并作出回答。<br>2.想问题全面。他能由大面到小点，循序渐进改进解决方案。<br>3.勇于承认不足。虽然他面对没接触过的技术会主动承认不会，但还能提出个人观点。<br>4.善于发现细节。他非常善于捕捉设计方案的细节，提出的某些细节都直接关系到方案的成败。</p>
<p>在平时编程工作中，一个工程师是否厉害，并不能简简单单从代码能力一个点上来衡量，而是要结合场景。</p>
<p>这些场景包括：对所做事情的理解、对未来的把控、对异常的避免以及细节的处理。</p>
<p>聪明和优秀程序员之间并无太密切的联系</p>
<p>前面提到过人类发明编程是为了弥补人类的大脑缺陷。人脑的使用度是有限的，学习久了要休息，工作久了要休息，想多了要休息。休息大脑无关于你的智商是高还是低。</p>
<p>为了减轻程序员大脑的负担，编程从机器语言发展到高级语言做了大量的改善，而且很多改善都是为了弥补人的智力缺陷。不信你看：</p>
<p>1.将系统 “分解”，易于人脑理解。<br>2.将子程序写得短小，减轻大脑负担。<br>3.基于面向对象编程而不是过程编程，易于人脑理解。<br>4.微服务化，减轻维护压力，减轻大脑负担。<br>5.制定各种编程规范，将思路从繁琐的编程中解放出来，避免犯错。<br>6.进行审查、评审和测试的流程，避免犯错。</p>
<p>也许有人会说更高的智商在编程上会有更好的作用。衡量一个工程师的水平高度不应该站在人的角度，而应该站在处理事情的角度。</p>
<p>高智商的工程师可以写出更复杂无 bug 的系统，这确实是真的。但是写出的程序如果没有人能懂，没人能继续维护，这个复杂无 bug 的系统的价值就要大打折扣了。</p>
<p>千万别忘了，评价一个系统的好坏除了能正常运行之外，还要考虑<code>可扩展性和易维护性</code>。你考虑得越多，就需要你越注重细节处理。</p>
<p>如果你想学习编程，或者你正在学习编程，下面的建议可能对你有用：</p>
<p>优秀的程序员和高智商无太密切的联系。你越谦虚，进步就越快。<br>如何执着地用聪明的方式去处理事情，比你有多聪明更重要。<br>要想懂怎么写出优秀的代码，就得具备非常强的吸收细节的能力。</p>
<p>最后一点更重要。</p>
<p>不要轻易否定自己，你一定也能学会编程。</p>
<h2 id="What"><a href="#What" class="headerlink" title="What"></a>What</h2><p>雇主最看重的是解决问题的技能，而不是编程语言的熟练程度、调试能力和系统设计。<br>新程序员犯下的最大错误就是专注于学习语法，而不是学习如何解决问题。<br>– 《<a href="https://medium.com/free-code-camp/how-to-think-like-a-programmer-lessons-in-problem-solving-d1d8bf1de7d2" target="_blank" rel="noopener">解决问题的经验教训</a>》</p>
<p><a href="https://www.coderscat.com/best-cs-books" target="_blank" rel="noopener">计算机科学经典书籍的书单（英文）</a></p>
<p>作者列出心目中最佳 CS 书籍，分成编程、算法、语言、系统和网络五个部分。</p>
<h3 id="Flex-amp-Bison"><a href="#Flex-amp-Bison" class="headerlink" title="Flex &amp; Bison"></a><a href="http://zhangdongxuan.com/2018/09/09/Flex-Bison/" target="_blank" rel="noopener">Flex &amp; Bison</a></h3><p>2018-09-09</p>
<p>flex &amp; bison 不仅可以进行语言的词法和文法分析，还可以接续几乎所有的结构化文本。</p>
<p>简介</p>
<p>Flex</p>
<p>Flex是一个词法分析工具，词法分析可以称为lexical analysis，或称scanning；</p>
<p>词法分析把输入分割成一个个有意义的词块，称为记号（token）；</p>
<p>Bison</p>
<p>Bison是一个语法分析工具，语法分析可以称为syntax analysis，或称parsing；</p>
<p>语法分析主要是确定词法分析记号（token）是如何彼此关联的；</p>
<p>基本所有的编译器项目中，都会使用lex或者flex做词法分析，并利用Yacc或者Bison对词法分析的结果进行语法分析。</p>
<p>flex和bison最早是用来生成编译器的，他们具备处理结构化的输入的能力，后来发现他们可以用在很多地方，例如解析css文件、json文件、XML文件等。</p>
<p>语法</p>
<p>上下文无关文法</p>
<p>当我们编写一个语法分析器，就需要我们用一定的方法来描述记号转化为语法分析树的规则。<br>这种描述的方法在计算机中最常用的就是上下文无关文法Context-Free Grammar。<br>上下文无关文法就是说这个文法中所有的产生式左边只有一个非终结符。</p>
<p>例如下面这个就是上下文无关文法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S -&gt; aSb | ab      这个文法产生了语言 &#123;a^n * b^n : n ≥ 1&#125;</span><br></pre></td></tr></table></figure>
<p>这个文法有两个产生式，每个产生式左边只有一个非终结符S，这就是上下文无关文法，因为你只要找到符合产生式右边的串，就可以把它归约为对应的非终结符。</p>
<p>要理解什么是上下文无关文法，可以先感受一下上下文有关文法，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S -&gt; ab</span><br><span class="line">aSb -&gt; aaSbb</span><br></pre></td></tr></table></figure>
<p>这就是上下文相关文法，因为它的第一个产生式左边有不止一个符号，所以你在匹配这个产生式中的S的时候必需确保这个S有正确的“上下文”，也就是左边的a和右边的b，所以叫上下文相关文法。</p>
<p>因为上下文无关文法有足够强的表达力来表示大多数程序设计语言的语法，上下文无关文法又足够简单，使得我们可以构造有效的分析算法来检验一个给定字串是否是由某个上下文无关文法产生的。</p>
<p>BNF文法</p>
<p>为了编写一个语法分析器，需要一定的方法来描述语法分析器所使用的把一系列记号转化为语法分析树的规则。在计算机分析程序里最常用的语言就是上下文无关文法（Context-Free Grammar, CFG）。书写上下文无关文法的标准格式就是Backus-Naur范式（BackusNaur Form，BNF）。</p>
<p>BNF文法用起来是非常简单易懂的，例如我们可以用下面的表达式来表示 1 <em> 2 + 3 </em> 4 + 5:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;exp&gt; ::= &lt;factor&gt; | &lt;exp&gt; + &lt;factor&gt;</span><br><span class="line">&lt;factor&gt; ::= NUMBER | &lt;factor&gt; * NUMBER</span><br></pre></td></tr></table></figure>
<p>每一行就是一条规则，用来说明如何创建语法分析树的分支。<br>有效的BNF总是带有递归性的，规则会直接或者间接地指向自身。</p>
<p>Flex语法结构</p>
<p>以最简单的word count的程序word_count.l来看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">	int chars = 0;</span><br><span class="line">	int words = 0;</span><br><span class="line">	int lines = 0; </span><br><span class="line">%&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%%</span><br><span class="line"></span><br><span class="line">[a-zA-Z]+ 	&#123; words++; chars += strlen(yytext); &#125; </span><br><span class="line">\n 			&#123; chars++; lines++; &#125;</span><br><span class="line">. 			&#123; chars++; &#125;</span><br><span class="line"></span><br><span class="line">%%</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">	yylex();</span><br><span class="line">	printf(&quot;%8d%8d%8d\n&quot;, lines, words, chars); </span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MacOS下编译代码命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flex word_count.l</span><br><span class="line">cc lex.yy.c -ll</span><br></pre></td></tr></table></figure>
<p>变量声明</p>
<p>声明部分可以进行声明和选项设置。<br>可以在%{和%}包围的部分里面定义c代码，里面的内容会被完整地复制到lex.yy.c 的开头，通常会用来放置include、define的信息。</p>
<p>规则定义</p>
<p>规则声明部分被两个%%包围，规则为</p>
<p>正则表达式 {匹配到之后执行的C代码}</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a-zA-Z]+ &#123; words++; chars += strlen(yytext); &#125;</span><br></pre></td></tr></table></figure>
<p>在任意一个flex的动作中，变量yytext总是被设为指向本次匹配的输入文本。<br>前面的部分就是模式，处于一行的开始位置，后面的部分就是动作，也就是，输入中匹配到了这个模式的时候，对应的进行什么动作。<br>yytext，在输入匹配到该模式的时候，匹配的部分就存储到yytext里面。</p>
<p>C代码部分</p>
<p>这部分是C代码，它们会被复制到lex.yy.c的最末尾。</p>
<p>程序主要由一系列带有指令的正则表达式组成，这些指令确定了正则表达式匹配后相应的动作（action）。</p>
<p>Bison语法结构</p>
<p>bison的语法规则也分为三部分，以flex 和 bison协同的计算器程序为例</p>
<p>flex部分：创建calculator.l并声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">    //calculator_def中定义了记号</span><br><span class="line">	#include &quot;calculator_def.h&quot;</span><br><span class="line">%&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">%%</span><br><span class="line"></span><br><span class="line">&quot;+&quot; 	&#123; return ADD; &#125;</span><br><span class="line">&quot;-&quot; 	&#123; return SUB; &#125;</span><br><span class="line">&quot;*&quot; 	&#123; return MUL; &#125;</span><br><span class="line">&quot;/&quot; 	&#123; return DIV; &#125;</span><br><span class="line">&quot;|&quot; 	&#123; return ABS; &#125;</span><br><span class="line">[0-9]+ 	&#123; yylval = atoi(yytext); return NUMBER; &#125; </span><br><span class="line">\n 		&#123; return EOL; &#125;</span><br><span class="line">[ \t]	&#123; /**whitespace**/ &#125;</span><br><span class="line">.		&#123; printf(&quot;Mystery character %c\n&quot;, *yytext); &#125;</span><br><span class="line"></span><br><span class="line">%%</span><br></pre></td></tr></table></figure>
<p>bison代码：创建calculator.y并编写代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">%&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/* declare tokens */ </span><br><span class="line">%token NUMBER</span><br><span class="line">%token ADD SUB MUL DIV ABS </span><br><span class="line">%token EOL</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">%%</span><br><span class="line">calclist:</span><br><span class="line">		| calclist exp EOL &#123; printf(&quot;= %d\n&quot;, $2); &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">exp: factor</span><br><span class="line">	| exp ADD factor &#123; $$ = $1 + $3; &#125; </span><br><span class="line">	| exp SUB factor &#123; $$ = $1 - $3; &#125; ;</span><br><span class="line"></span><br><span class="line">factor: term</span><br><span class="line">	| factor MUL term &#123; $$ = $1 * $3; &#125; </span><br><span class="line">	| factor DIV term &#123; $$ = $1 / $3; &#125; ;</span><br><span class="line"></span><br><span class="line">term: NUMBER</span><br><span class="line">	| ABS term &#123; $$ = $2 &gt;= 0? $2 : - $2; &#125; ;</span><br><span class="line"></span><br><span class="line">%%</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">	yyparse();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">yyerror(char *s)</span><br><span class="line">&#123;</span><br><span class="line">	fprintf(stderr, &quot;error: %s\n&quot;, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明部分和C代码部分</p>
<p>被%{和%}包围的部分，里面的内容会被完整地复制到lex.yy.c 的开头，通常会用来放置include、define的信息。</p>
<p>除此之外一般还要进行token设置。<br>token用于标记语法解析中用到的基本语素，教程里称之为“记号”。<br>用枚举来定义，而且为了避免冲突一般枚举的值从258开始。<br>语法是：<br>%token 记号，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%token NUMBER</span><br><span class="line">%token ADD SUB MUL DIV ABS </span><br><span class="line">%token EOL</span><br></pre></td></tr></table></figure>
<p>这里一般是当flex成功匹配到一个模式的时候，会return一个token，然后在bison的规则中查找应该进行的动作。</p>
<p>规则部分</p>
<p>规则部分遵循DNF范式的定义，每一个bison语法分析器在分析其输入时都会构造一棵语法分析树。<br>在有些应用里，它把整棵树作为一个数据结构创建在内存中以便于后续使用。<br>在其他应用里，语法分析树只是隐式地包含在语法分析器进行的一系列操作中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">%%</span><br><span class="line">calclist:</span><br><span class="line">		| calclist exp EOL &#123; printf(&quot;= %d\n&quot;, $2); &#125; ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">exp: factor</span><br><span class="line">	| exp ADD factor &#123; $$ = $1 + $3; &#125; </span><br><span class="line">	| exp SUB factor &#123; $$ = $1 - $3; &#125; ;</span><br><span class="line"></span><br><span class="line">factor: term</span><br><span class="line">	| factor MUL term &#123; $$ = $1 * $3; &#125; </span><br><span class="line">	| factor DIV term &#123; $$ = $1 / $3; &#125; ;</span><br><span class="line"></span><br><span class="line">term: NUMBER</span><br><span class="line">	| ABS term &#123; $$ = $2 &gt;= 0? $2 : - $2; &#125; ;</span><br><span class="line"></span><br><span class="line">%%</span><br></pre></td></tr></table></figure>
<p>第三部分是用户自定义代码</p>
<p>以上可以使用如下命令生成编译结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bison -d calculator.y</span><br><span class="line">flex calculator.l</span><br><span class="line">cc -o calculator calculator.tab.c lex.yy.c -ll</span><br></pre></td></tr></table></figure>
<p>总结</p>
<p>利用flex &amp; bison 除了可以进行语言的词法和文法分析，还可以接续几乎所有的结构化文本。</p>
<h3 id="关于编程，你应该知道的几件事"><a href="#关于编程，你应该知道的几件事" class="headerlink" title="关于编程，你应该知道的几件事"></a><a href="https://www.toutiao.com/i6450228956019819022/" target="_blank" rel="noopener">关于编程，你应该知道的几件事</a></h3><p><img data-src="http://p3.pstatp.com/large/3188000763d52f8ea448" alt></p>
<p>网上有个著名的段子：</p>
<p>老婆给当程序员的老公打电话：“下班顺路买一斤包子带回来，如果看到卖西瓜的，买一个。”<br>当晚，程序员老公手捧一个包子进了家门。老婆怒道：“你怎么就买了一个包子？！”<br>老公答曰：“因为看到了卖西瓜的。”</p>
<p>搞笑之余，其实也可以看出程序员的思维方式跟普通的思维方式存在差异。</p>
<p>而这种差异，正是编程的奇妙之处。</p>
<p>什么是 “编程”？</p>
<blockquote>
<p>所谓编程，从本质上来说，就是学习使用一种特定的语言，来描述现实世界的一个问题，再将这个问题通过计算机的运算，给出分析和解答。</p>
</blockquote>
<p>从十七世纪开始，数学家和哲学家就都在探索如何将关于世界的知识归纳起来，并且用一套严谨的符号体系进行表征。</p>
<p>在这个过程中，数学家们奠定了现代编程语言的运算逻辑，而哲学家们则为现代编程语言的面向对象思想奠定了坚实的基础。</p>
<p>大名鼎鼎的艾伦·图灵（可参考电影《模仿游戏》）在此基础上描述了一种通用的计算机模型，图灵机由此诞生。</p>
<p><img data-src="http://p1.pstatp.com/large/317c000454ce3300ed15" alt><br>而后，冯·诺依曼等人用电子管实现了这种模型，这便是今天计算机的雏形。</p>
<p>虽然当时的技术无法达到真正 “人工智能” 的程度，但是时至今日，所有的编程语言依然沿着图灵机原理和冯·诺依曼体系发展。</p>
<p>现代编程语言应该能够完整地描述某一个现实领域的问题，并通过运算规则，操作计算设备获得分析过程和结果。</p>
<p>什么是 “编程思维”？</p>
<p>与人类的正常思维不同，程序的逻辑思维是严谨完善的。截止到目前，机器的宽容度在很大程度上还远不如一个低年龄的儿童。</p>
<p>也就是说，不管多么厉害的代码，一个逗号都不能出错。毕竟编程语言最终要作用于机械，因此编程思维很大程度上是一种线性思维，需要符合机械的流程。</p>
<p>所以，想学好编程，就要养成这种理性的逻辑思维方式，并且建立自己的知识体系。比如可以经常画流程图和时序图，或者编写伪代码来练习。</p>
<p>其实，随着技术的演进，编程已经没有想象中那么难了。越来越多的普通人，只需要经过简单的训练，就可以完成业务逻辑的编码工作。</p>
<p>什么是 “程序员”？</p>
<p>大多数程序小白在遇到电子设备的问题时都会想请教程序员，好像凡是会写代码的，都会修电脑，修手机，修一切的电子产品…… 没错，程序员大多对电子设备有相当的了解和控制力。</p>
<p>程序员，简单来说就是可以控制机器按照自己的意图做事的人。程序员必须具备模块化的思维能力，要能正确评估自己的模块对整个项目中的影响及潜在的威胁。</p>
<p>如今，随着可穿戴设备和智能家居设备的逐步普及，越来越多的传统设备配备了操作系统，成为了可编程设备。也就是说，程序员们可以编写程序改变世界的机会，也越来越多。</p>
<p>什么是 “优秀的程序员”？</p>
<p>另一方面，虽然现在能写代码的人不少，但是能成为优秀程序员的人却并不多。这导致了很多学编程的人找不到工作，同时很多高薪的工作却无人应征。</p>
<p>所以，单纯地解决业务问题，并不能成为一个优秀的程序员。</p>
<p>一个优秀的程序员还需要充分了解你写的代码。</p>
<p>你不仅需要知道写出的代码能够解决什么问题，你还需要知道系统是如何执行代码的，甚至执行代码能给系统带来什么改变。</p>
<p>一个优秀的程序员不仅仅是会编写程序，而且要具备刨根究底的精神，一步步追踪到硬件的执行。</p>
<p><a href="https://hazyman.com/Technology/2020/Android/">Android</a>开发正在改变日常生活</p>
<p>如果一个程序员懂得 Android 开发，就可以使用程序控制电视定时播放，可以控制智能手表表针的显示样式，可以控制空调的出风温度，可以将手机和门禁连接，可以在汽车的中控台上部署一个程序和手机共享音乐……当前这个 IOT 时代和 AI 时代的程序员，有更多机会可以通过机器改变现实世界。</p>
<p>作为程序员，如今可供控制的机器已经越来越多样化。只要掌握若干种关键技能，就可以很好地在这个机器拼接的世界中游刃有余。</p>
<p>如果您也想用编写的程序改变世界，那么就从现在开始学习编程吧！</p>
<p>我们建议您从 Android 开发入手，毕竟大多数可编程设备采用的都是 Android 系统。</p>
<h3 id="雇主最欢迎的技术技能"><a href="#雇主最欢迎的技术技能" class="headerlink" title="雇主最欢迎的技术技能"></a><a href="https://www.hiringlab.org/2019/11/19/todays-top-tech-skills/" target="_blank" rel="noopener">雇主最欢迎的技术技能</a></h3><p><img data-src="https://www.wangbase.com/blogimg/asset/201911/bg2019112501.jpg" alt></p>
<p>美国一家招聘网站统计了，过去五年招聘岗位的技能要求。提到最多的前十位技能如下：SQL、Java、Python、Linux、JavaScript、AWS、C++、C、C# 和 .net。</p>
<p>不过需求增长速度最快的技能，排名完全不一样：docker、azure、机器学习、aws 和 Python。</p>
<p><img data-src="https://www.wangbase.com/blogimg/asset/201911/bg2019112502.jpg" alt></p>
<h3 id="关于战略问题的通信之六（译文）"><a href="#关于战略问题的通信之六（译文）" class="headerlink" title="关于战略问题的通信之六（译文）"></a><a href="http://www.ruanyifeng.com/blog/2009/03/strategy_letter_vi.html" target="_blank" rel="noopener">关于战略问题的通信之六（译文）</a></h3><p>作者： 阮一峰<br>日期： 2009年3月30日</p>
<p>《Joel谈软件》一书的翻译，我好久没提了。</p>
<p>合同规定今年1月交稿。假定我没有违约的话，此书现在应该上市了。可是，实际上……就算到下个月，我恐怕都翻译不完。……我也不想多解释了，反正这本书现在是我最大的烦恼，只能争取今年夏天上市了。</p>
<p>下面的文章是该书的第21篇。</p>
<p>=========================</p>
<p>关于战略问题的通信之六</p>
<p>作者：Joel Spolsky</p>
<p>译者：阮一峰</p>
<p>原文网址：<a href="http://www.joelonsoftware.com/items/2007/09/18.html" target="_blank" rel="noopener">http://www.joelonsoftware.com/items/2007/09/18.html</a></p>
<p>发表日期 2007年9月18日，星期二</p>
<p>IBM公司最近发布了一套开源Office软件，叫做IBM Lotus Symphony，看上去大概是根据StarOffice[1]修改的。但是，我怀疑起这个名字的真正目的，可能是想清除人们对最早那套Lotus Symphony[2]的记忆。那套软件在发布之前，被吹得天花乱坠，简直就像耶稣要复活一样，但是在发布之后一败涂地。它就是软件业中的Gigli[3]。</p>
<p>上个世纪80年代后期，Lotus公司努力地想找到下一步的方向，升级他们的旗舰产品—-电子表格和作图软件Lotus 1-2-3。他们很自然地就想到了两条路。第一条路是往软件中加入更多的功能，比如文字处理功能。这就是Symphony这个产品的由来。第二条看上去很显然的路，是做一个3D电子表格软件。这就是后来Lotus 1-2-3的3.0版本。</p>
<p>这两条路一开始就遇到了一个大麻烦：在古老的DOS环境中，内存占用不得超过640K。那个时候，IBM已经开始少量出售配备80286芯片的个人电脑，这种新的芯片能够提供更多的内存。但是，Lotus公司觉得，为这种售价高达10000美元的电脑开发专用软件，市场不会很大。所以，他们一个字节、一个字节地压缩，花了18个月，才将Lotus 1-2-3的新版本塞进了640K的内存中。但是，最终在白白浪费了许多时间之后，他们不得不放弃了3D功能，因为没有足够的内存可以塞进去。Symphony的遭遇也差不多，许多功能都被砍得干干净净。</p>
<p>这两条路都走错了。当Lotus 1-2-3的3.0版本上市的时候，每个人家中都已经有了一台80386芯片的电脑，配备了2MB或者4MB的内存。至于Symphony，它的电子表格功能很弱，文字处理功能也很弱，所有其他功能都很弱。</p>
<p>“够了，老同志，”你们会说。”谁如今还关心那些老掉牙的、只能在字符模式下运行的软件？”</p>
<p>请暂且忍耐我一分钟，因为历史正在以三种不同的方式重演。那么，最聪明的应对策略，就是压宝在同样的结局上面。</p>
<p>低速CPU和小容量内存的环境</p>
<p>从最早的时候一直到大概1999年，程序员都极其关注软件的效率问题。在这段时期中，内存空间总是不够大，CPU主频也不够高。</p>
<p>到了20世纪90年代后期，一些像微软和苹果这样的公司，开始注意到摩尔定律[4]（其实它们只比别的公司早了一点点）。它们认识到，不必太在意软件的效率问题和内存占用……只要把很酷的功能做出来，然后等着硬件升级就可以了。微软公司首次发布Excel的Windows版本的时候，80386电脑还非常贵，实际上没什么人买得起，但是微软公司很有耐心。只过了几年，80386SX[5]出来了，兼容机的价格下降到1500美元，你只要买一台，就能运行Excel。</p>
<p>由于内存的价格直线下降，CPU的速度每年都在翻番，所以作为一个程序员，你就面临选择。你可以花6个月用汇编语言，重写程序的内循环（inner loop）。你也可以休假6个月，找一支摇滚乐队当鼓手。不管是哪一种选择，6个月后你的程序都会运行得更快。实际情况是没有程序员真的喜欢用汇编语言编程。</p>
<p>所以，我们都不怎么关心软件的效率或优化问题。</p>
<p>不过有一个例外，那就是在浏览器的Ajax应用程序中使用的JavaScript语言。因为这是当前几乎所有的软件开发工作的方向，所以这是一个重大的问题。</p>
<p>眼下的许多Ajax应用程序，有一百万行甚至更多的客户端代码。现在的瓶颈已经从内存和CPU，转移到了带宽和编译时间。你真的必须想尽办法进行优化，才能使复杂的Ajax程序有良好的表现。</p>
<p>但是，历史正在重演。带宽正在变得越来越便宜，即使这样，还是有人在考虑如何对Javascript进行预编译（precompile）。</p>
<p>有一些程序员将大量的精力投入优化工作，要将程序变得更紧凑和更快速。某一天，他们醒来后将发现，这种努力或多或少是白忙一场。如果你喜欢用经济学家的口吻夸夸其谈，那么你最低限度可以说，这种努力”不会带来长期的竞争优势”。</p>
<p>那些不关心效率、不关心程序是否臃肿、一个劲往软件中塞住高级功能的程序员，在长期中，将拥有更好的产品。</p>
<p>跨平台的编程语言</p>
<p>C语言的原始设计目标，就是为了让编写跨平台的应用程序变得更容易。它很好地实现了这个目标，但是并不是真的100%跨平台。所以，后来又出现了Java，它的通用性甚至要超过C语言。历史大概就是这样啦。</p>
<p>眼下，在跨平台这出连续剧中，正出现又一个高潮，那就是—-没错，你猜对了—-客户端Javascript的兼容性问题，尤其是浏览器DOM（文档对象模型）的兼容性问题。编写一个网络应用程序，让它在所有不同种类的浏览器上都能运行，这简直是一场可怕的噩梦。你根本找不到其他方法，只能精疲力竭地在Firefox、IE 6、IE 7、Safari和Opera上一一测试，猜猜发生了什么事？我没有时间在Opera上测试，所以只好不管Opera了。这意味着，新兴的互联网浏览器根本不会获得立足的机会。</p>
<p>未来会怎样？当然，你可以在心里企盼或祈求，微软公司和Firefox能够制作出更具备兼容性的产品。 祝你好运。不过，你还有另外一个选择，就是使用p-code虚拟机[6]或者Java虚拟机模型，你在底层系统之上建立一个小小的沙箱（sandbox），再将软件的运行建立在沙箱之上。这样做的不利之处，就是沙箱有很多缺陷，它们非常慢而且错误百出，这就是为什么Java applet[7]都死光光的原因。建立一个沙箱，你就等于走上了一条不归路，你能得到的运行速度只有底层系统的1/10，你也无法利用任何一个只有某个底层系统支持、而其他底层系统都不支持的特性。（直到今天，我都在翘首期待，有人能向我展示可以在智能手机上使用的Java applet。它能利用手机的所有功能，比如拍照、读取地址本、发送短消息、与全球卫星定位系统GPS互动等等。）</p>
<p>沙箱在过去行不通，在将来也不会行得通。</p>
<p>那么，未来会怎样？获胜的一方所采取的策略，正是贝尔实验室在1978年做出的决定，那里的科学家决定开发一种跨平台的、高效的编程语言，这就是后来的C语言。这种语言可以将程序编译成不同平台、不同系统可以理解的”本地”码（各种不同的Javascript和DOM就是本地码）。至于怎么编译，那是编译器作者需要解决的问题，与你无关。代码编译后的运行效果，与”本地的”Javascript直接运行完全一样，能够以一种统一的方式获取DOM模型的全部潜力，能够自动地和跨平台地，与IE和Firefox的核心代码融合在一起。对的，它还完美地支持CSS，能够以一种令人惊骇、但是事实证明是正确的方法，让你玩转CSS，所以你永远都不必为CSS的不兼容问题发愁。再也不会这样了，永远不会了。哦，等这一天到来的时候，该是多么美好啊。</p>
<p>完善的互动性和用户界面标准</p>
<p>IBM 360大型机（mainframe）使用一种叫做CICS[8]的用户界面，你今天在飞机场还能看到这个系统，你只要在办理登机手续的柜台上弯下身子就能看到。这种界面是80字符宽、24字符高的绿色屏幕，只有字符模式，没有图形界面，这是肯定的。主机发送一个表单给”客户端”（一台IBM 3270智能显示终端）。这个”客户端”是智能的，它知道如何将表单呈现给你，允许你将数据输入表单，在这个过程中，根本不与主机通信。这就是IBM大型机如此强大、远远超过Unix系统的原因之一，因为CPU根本不需要处理你的行编辑，这种任务由智能终端承担了。（如果你做不到为每个人都配置一台智能终端，那么你就去买一台System/1小型机，充当主机和哑终端[9]之间的中介，为你承担表单编辑的任务。）</p>
<p>不管怎样，只要你填完了表单，按下”发送”键，你输入的所有数据就被送回服务器端处理。然后，服务器端又给你发来一个新的表单。整个过程周而复始。</p>
<p>一切都很棒。但是，如果你想在这种环境下，使用文字处理软件，你该怎么办？（你真的无法如愿。在大型机上从来都没有过一个像样的文字处理软件。）</p>
<p>这就是历史上的第一阶段。它与互联网时代的HTML阶段正好对应。HTML语言就是带有字体变化的CICS。</p>
<p>等到历史进入第二阶段，所有人都在写字桌上配备了PC。于是，突然之间，也不管程序员本人愿不愿意，他就是具有了在任意时间、任意场合，随意操弄屏幕上任意角落的任意文字的能力。实际上，你可以获取用户打字时的每一次击键，因此你就能做出一个很好很快的应用程序，不必等到用户按下”发送”键，CPU就能提前介入，做出相应的处理。比如说，你可以开发一个文字处理软件，一旦当前行快要写满了，软件就会自动换行，将结尾的最后一个词移到下一行的行首。一切都在瞬间完成。哦，我的老天，你能做到这一点？</p>
<p>第二阶段也有自己的问题，那就是缺乏一个明确的用户界面标准……程序员具备了空前强大的决定权，几乎可以随意按照自己的偏好来制作软件，因此每个人都用不同的方式写软件，这就给用户带来了困扰，如果你会用X软件，这并不代表你就会使用Y软件。WordPerfect[10]和Lotus 1-2-3有截然不同的菜单设计、截然不同的键盘接口和截然不同的指令结构。在程序之间复制数据，根本没有可能。</p>
<p>这也正是我们今天在Ajax开发中面对的局面。当然，不可否认，Ajax应用程序的易用性比第一代DOS应用程序，有了很大的提高。因为从那时开始，我们已经学到了不少经验。但是Ajax应用程序没有规范的标准，如果想要协同工作，非常麻烦。你完全没有办法，将对象从一个Ajax应用程序中，剪切和粘贴到另一个中。举例来说，我就不太确定，你怎样才能将Gmail中的图片传到Flickr中。拜托，老兄，剪切和粘贴在25年前就发明出来了。</p>
<p>在历史上的第三个阶段中，出现了配备Macintosh操作系统和Windows操作系统的PC。一个统一的、标准的用户界面诞生了，包括多窗口和剪贴板这样的标准功能，这使得在多个程序间进行协同工作成为可能。这种崭新的GUI（图形用户界面），带给我们易用性和实用性的飞跃，导致了个人电脑爆炸式增长。</p>
<p>因此，如果历史会重演，我们就可以期待总有一天，Ajax程序的用户界面会出现某种程度的统一，它的诞生方式就如同Windows的诞生方式一样。总有人会写出一个具备压倒性优势的SDK（软件开发工具包），其他人就可以用它来开发功能强大的Ajax应用程序。不同的程序员使用同样的用户界面组件，使得开发出来的程序可以协同工作。那种赢得最多程序员认可的SDK，就具备了垄断性的竞争优势，堪称可于微软用Windows API获得的竞争优势媲美。</p>
<p>如果你是一个互联网开发者，你不想用别人都在用的主流SDK，那么越来越明显地，你将发现没有用户使用你的程序。原因其实你知道的很清楚，那就是你的程序不支持剪切和粘贴，无法进行地址本同步，也做不到其他所有在2010年流行的新奇的互动功能。</p>
<p>比如，请想像一下，假定你是Google公司的负责人，你为自家有Gmail这样的产品，感到沾沾自喜。但是没过多久，某家你从来没有听到过的公司，—-很可能是一家桀骜不驯的初创公司，背后有Y Combinator[11]的资助—-开发出了一种NewSDK，销售状况好得难以置信。这种NewSDK使用一种性能优异的跨平台编程语言，可以直接编译生成Javascript，而且更出色的是，它还配备了一个大型Ajax库，能够执行所有种类的智能性的互动功能。不仅仅是剪切和粘贴，还有一些很酷的聚合（mashup）功能，就像同步和单点身份管理（single-point identity management）。有了单点身份管理，用户就不必将自己正在干什么告诉Facebook和Twitter了，只需要在网上任意一个支持这个功能的地方，输入就可以了。你对这一套NewSDK嗤之以鼻，因为它的大小居然高达惊人的232MB！……232MB啊！……编译生成的Javascript，单单载入一个页面就需要76秒。所以你认定，自家的应用程序Gmail不会流失任何用户。</p>
<p>但是就是从那时起，就当你在Google总部里、坐在Google式座椅上、细细品味Google味咖啡、感到洋洋得意、沾沾自喜、高枕无忧、踌躇满志的同时，新版本的浏览器发布了，支持缓存编译后的Javascript。于是，突然之间，NewSDK的载入速度变得真的很快。Paul Graham又及时地向这家初创公司补充了6000包方便面，让他们饿的时候有东西吃。这样一来，这家公司又可以继续运营三年，将产品不断完善。</p>
<p>你手下的程序员，不管是张三还是李四，都有相同的看法，那就是Gmail太庞大了，无法移植到那个呆呆的NewSDK上面去。如果那样的话，我们就必须改变每一行的代码。这接近于完全重写整个程序，太可怕了。整个系统模型会一团混乱，充满了嵌套。NewSDK使用的跨平台编程语言用到的括号，多得连Google也无法承受。几乎每一个函数的最后一行，都是一个包含连续3296个右括号的字符串。你因此不得不去买一个特殊的编辑器，才能数清到底有多少个右括号。</p>
<p>后面的事情是，NewSDK的工程师又发布了一个相当不错的文本处理软件，以及一个相当不错的电子邮件应用程序，还有一个杀手级的Facebook/Twitter式的事件发表器，能够将网上与你有关的所有事情都进行同步。人们开始使用他们的产品。</p>
<p>就在你不知不觉之间，所有人都开始编写基于NewSDK的应用程序。这些程序的表现真的很好，一转眼，产业界点名只想用基于NEWSDK的应用程序。所有老式的纯Ajax应用程序看上去都变得很寒酸，它们做不到剪切和粘贴，不能够聚合和同步，互相之间无法很好地协同工作。Gmail就这样成了遗迹，好比Email程序中的WordPerfect。未来的某一天，你对孩子们说，曾几何时当你得到2GB的空间储存Email时，你是多么激动。孩子们全都嘲笑你，他们的指甲油都不止2GB。</p>
<p>你是不是觉得这个故事太荒诞不经了？那你就将”Google Gmail”替换成”Lotus 1-2-3”。NewSDK将是微软公司Windows传奇的重现。整个过程完全是Lotus公司如何丢失电子表格市场的重演。在互联网上，这种事情将再发生一次，因为现在所有影响市场的因素和背后的动力，同当年完全一样。我们唯一不知道的就是，它到底发生在何时、何地、何人身上，但是它一定会发生。</p>
<p>注释：</p>
<p>[1] StarOffice是Sun公司发布的一套Office软件，它的源代码在2000年7月开源，成为了后来的OpenOffice的基础。</p>
<p>[2] Lotus Symphony是Lotus公司在1984年发布的一套Office软件，在DOS环境下运行。1995年，IBM公司以35亿美元的价格，并购了Lotus公司。</p>
<p>[3] Gigli是一部2003年上映的美国电影，主演中包括Ben Affleck、Jennifer Lopez、Al Pacino等大明星。由于Ben Affleck和Jennifer Lopez在拍摄过程中爆出绯闻，这部电影在上映之前被大肆宣传，但是上映之后，口碑极差，被认为是有史以来最滥的电影之一。</p>
<p>[4] 摩尔定律（Moore’s Law）是指大约每隔18个月，芯片的晶体管容量比先前增加一倍，同时性能也提升一倍，而价格下降一半。这个定律描述了硬件的发展趋势，由Intel公司的共同创始人Gordon E. Moore在1965年提出。</p>
<p>[5] 80386SX是80386芯片的一个低价版，后者在1986年上市，前者在1988年上市。</p>
<p>[6] P-code是软件编译过程中产生的一种中间代码，不同于最终的机器码，可以使得编程语言不依赖于特定的平台或硬件。</p>
<p>[7] Java applet是用Java语言编写的、镶嵌在网页的小应用程序。它需要计算机安装了Java虚拟机以后才能运行。</p>
<p>[8] CICS是Client Information Control System（用户信息控制系统）的缩写。</p>
<p>[9] 哑终端（dumb terminal）就是连接主机而不做任何计算处理的终端机。</p>
<p>[10] WordPerfect是Coral公司拥有的文字处理软件，在20世纪80年代末和90年代初流行一时，是事实上的文字处理软件标准。后来，被微软公司的Word取代。</p>
<p>[11] Y Combinator是一家创业投资公司，专门为创业者提供种子资金。该公司由Paul Gramham等人在2005年创立。</p>
<h3 id="罗胖60秒：什么是“设计”？"><a href="#罗胖60秒：什么是“设计”？" class="headerlink" title="罗胖60秒：什么是“设计”？"></a><a href="http://www.luojiji.com/thread-15528-1-1.html" target="_blank" rel="noopener">罗胖60秒：什么是“设计”？</a></h3><ol>
<li><p>这个周五上新，给你推荐咱们「得到」里面的最新课程《跟贾伟学设计》。你可能会说，我又不是设计师，我干嘛要学设计？请注意，这里的设计，可不是讲怎么好看的那种美术设计，它其实是一种和陌生人对话的技术。</p>
</li>
<li><p>比如，<code>最新的手机，你拿到之后，是不需要看说明书的，马上就能知道哪个是开关键，哪个是音量键</code>。再比如，<code>进入宾馆的卫生间，这卫生纸折成了一个小三角，你马上就能get到：这个卫生间清扫完毕，还没人用过。</code></p>
</li>
<li><p>这些现象的背后，都是设计师的智慧。所以贾伟老师说，<code>设计本质上是一套“读心术”和沟通术，能大大提高你和人沟通的效率。</code></p>
</li>
<li><p>再说一下主讲人贾伟老师，他既是国内获奖最多的设计师之一，也是中国最大的设计公司的老板。在这门课里，他会把自己丰富的实战经验分享给你。《跟贾伟学设计》，请享用。</p>
</li>
</ol>
<h3 id="软件架构被高估，清晰和简单的设计被低估"><a href="#软件架构被高估，清晰和简单的设计被低估" class="headerlink" title="软件架构被高估，清晰和简单的设计被低估"></a><a href="https://blog.pragmaticengineer.com/software-architecture-is-overrated/" target="_blank" rel="noopener">软件架构被高估，清晰和简单的设计被低估</a></h3><p>（1）设计一个计算机系统的目标应该是简单性 。</p>
<p>系统越简单，理解起来就越简单，找到问题就越简单，实现它就越简单。描述的语言越清晰，设计就越容易理解。</p>
<p>干净的设计类似于干净的代码：它易于阅读且易于理解。</p>
<p>（2）如何编写干净的代码？</p>
<p>编写干净代码有很多好方法。但是，你很少会听到有人建议，在代码中应用”四人帮”的设计模式。</p>
<p>干净代码的特征是：单一责任，明确命名和易于理解的约定。这些原则同样适用于清晰的架构。</p>
<p>（3）设计模式的作用是什么？</p>
<p>设计模式可以为你提供如何改进代码或架构的想法。了解常见的设计模式是一件好事，它们有助于缩短与他人的讨论，让别人以与你相同的方式谈论一件事。</p>
<p>但是，设计模式不是目标，它们不能替代系统设计的简单性。在设计系统时，你可能会发现自己意外地应用了一个众所周知的设计模式，这是一件好事。但你不应该为了采用一种或多种设计模式，而将其用作锤子，到处寻找钉子来使用它。</p>
<p>我承认，虽然我花了很多时间阅读和理解”四人帮”的《设计模式》，但它们对我成为一名更好的程序员的影响，要小于我从其他工程师那里得到的反馈。</p>
<p>作为一名工程师，你的目标应该是更多地解决问题，并通过它们进行学习，而不是选择闪亮的设计模式。</p>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a><a href="https://www.zdnet.com/article/python-is-eating-the-world-how-one-developers-side-project-became-the-hottest-programming-language-on-the-planet/" target="_blank" rel="noopener">Python</a></h3><p>Guido van Rossum 老照片</p>
<p>1990年，34岁的荷兰程序员 Guido van Rossum，发布了一个个人的业余项目– Python 语言。</p>
<p>1994年，他参加波兰的 Python 研讨会。</p>
<p><img data-src="https://www.wangbase.com/blogimg/asset/201908/bg2019081207.jpg" alt></p>
<p>2001年，Python 基金会成立。</p>
<p><img data-src="https://www.wangbase.com/blogimg/asset/201908/bg2019081206.jpg" alt></p>
<p>2014年，他进入 Dropbox 公司工作。</p>
<p><img data-src="https://www.wangbase.com/blogimg/asset/201908/bg2019081205.jpg" alt></p>
<h3 id="中国传统颜色手册"><a href="#中国传统颜色手册" class="headerlink" title="中国传统颜色手册"></a><a href="https://works.yangerxiao.com/chinese-colors/" target="_blank" rel="noopener">中国传统颜色手册</a></h3><p><img data-src="https://www.wangbase.com/blogimg/asset/201909/bg2019092007.jpg" alt></p>
<p>一个方便使用的在线色表，列出中国古典的常见颜色。</p>
<h3 id="程序员管人"><a href="#程序员管人" class="headerlink" title="程序员管人"></a><a href="http://www.ruanyifeng.com/blog/2020/01/weekly-issue-90.html" target="_blank" rel="noopener">程序员管人</a></h3><p>程序员当久了以后，如果项目顺利，一般都有机会组建或者负责团队，开始管人。</p>
<p>管人其实比开发更难。技术是死的，人是活的，随时会变。把大家团结起来，一起奋斗，很不容易。</p>
<p><img data-src="https://www.wangbase.com/blogimg/asset/202001/bg2020010903.jpg" alt></p>
<p>我认识的许多程序员，都不愿意管人。一个创业的朋友开一个工作室，他说这几年有好几次机会做大，但是都放弃了，因为不知道怎么管人。 他说，我可以管好自己，但我不知道怎么管好别人。</p>
<p>首先，招聘或者解雇，都是非常麻烦的事情。然后，<code>绩效的评估，奖金的分配，很容易产生矛盾。只要有人心怀不满，就会有内耗，影响企业或团队的发展。万一出现&quot;删库跑路&quot;这种极端情况，更是要命的打击。</code></p>
<p><img data-src="https://www.wangbase.com/blogimg/asset/202001/bg2020010904.jpg" alt></p>
<blockquote>
<p>马云和任正非强在哪里？不是技术，而是管理和市场判断，他们都非常善于管人，尤其是管理大型组织。任正非就说过，我最大的本事就是一桶浆糊，把几万人粘成一股绳。</p>
</blockquote>
<p>所以，程序员应该对自己有一个清醒的认识，管人和技术是两种不同的能力。如果你不善于管人，就不要去任职管理岗位；如果你在创业，就应该请专门的经理人，负责企业管理。</p>
<p>反过来说，对于那些不是程序员、不精通技术的人，只要你善于管理，那么你可以去找程序员，跟你一起技术创业。</p>
<h3 id="程序员收入最高的美国技术公司"><a href="#程序员收入最高的美国技术公司" class="headerlink" title="程序员收入最高的美国技术公司"></a><a href="https://www.levels.fyi/2019/" target="_blank" rel="noopener">程序员收入最高的美国技术公司</a></h3><p>美国一家数据公司发布，2019年工程师年薪最高的技术公司排名，分成初级工程师、中级工程师、高级工程师、资深工程师、首席工程师五档。年薪包括工资、奖金和股票。</p>
<p><img data-src="https://www.wangbase.com/blogimg/asset/202001/bg2020010601.jpg" alt><br><img data-src="https://www.wangbase.com/blogimg/asset/202001/bg2020010602.jpg" alt><br><img data-src="https://www.wangbase.com/blogimg/asset/202001/bg2020010603.jpg" alt><br><img data-src="https://www.wangbase.com/blogimg/asset/202001/bg2020010604.jpg" alt><br><img data-src="https://www.wangbase.com/blogimg/asset/202001/bg2020010605.jpg" alt></p>
<h2 id="How"><a href="#How" class="headerlink" title="How"></a>How</h2><p><img data-src="https://user-gold-cdn.xitu.io/2018/7/4/16463fc2919e1c90?imageView2/0/w/1280/h/960/format/png/ignore-error/1" alt><br>JetBrains我目前使用的 IDE 是 <a href="https://juejin.im/post/5b3c694f6fb9a04fb309d959" target="_blank" rel="noopener">JetBrains 全家桶</a>，目前我编写 Python 比较多，所以主要使用 PyCharm，另外写前端的时候也会使用 WebStorm，写 Java 就用 IntelliJ IDEA，C、C++ 用 CLion，PHP 的话就用 PhpStorm，Ruby 的话就用 RubyMine，其他的语言用的就少了，就没有装了。</p>
<p>如果我只能给其他程序员一个建议，那就是编写小的代码块，你要多写小方法、小功能、小程序。<br>我自己写C＃时，当函数接近15或20行代码时，我会感到不舒服。我的限制是，一个函数最多最多就是24行代码，因为传统终端就是24行一屏。<br>– <a href="https://blog.ploeh.dk/2019/11/04/the-80-24-rule/" target="_blank" rel="noopener">《80/24规则》</a></p>
<p>我认为，电动汽车比传统汽车更简单是一个谬论。因为电动汽车将复杂性从硬件转移到了软件，因此看上去硬件更简单。<br>– <a href="https://news.ycombinator.com/item?id=21503353" target="_blank" rel="noopener">HN 读者</a></p>
<p><a href="https://boingboing.net/2019/10/03/the-air-force-will-invite-hack.html" target="_blank" rel="noopener">美国空军邀请7个黑客破解 F-16 战斗机的数据系统</a>，结果发现了不少漏洞。空军感到满意，明年计划邀请黑客攻击轨道上的真实卫星。</p>
<h3 id="Git-原理解释（英文）"><a href="#Git-原理解释（英文）" class="headerlink" title="Git 原理解释（英文）"></a><a href="https://codewords.recurse.com/issues/two/git-from-the-inside-out" target="_blank" rel="noopener">Git 原理解释（英文）</a></h3><p>本文用通俗的示例和图片，解释 Git 进行版本管理的原理。</p>
<h3 id="如何将任意命令装为图形界面？（英文）"><a href="#如何将任意命令装为图形界面？（英文）" class="headerlink" title="如何将任意命令装为图形界面？（英文）"></a><a href="https://chriskiehl.com/article/gooey-as-a-universal-frontend" target="_blank" rel="noopener">如何将任意命令装为图形界面？（英文）</a></h3><p><img data-src="https://www.wangbase.com/blogimg/asset/201910/bg2019101009.jpg" alt></p>
<p>本文介绍使用 Gooey 这个工具为任何命令行的命令，生成一个图形界面，用户只需写一个配置文件即可。上图是一个 MP3 转换命令的图形界面。</p>
<h3 id="基于零宽字符的文本隐藏加密工具"><a href="#基于零宽字符的文本隐藏加密工具" class="headerlink" title="基于零宽字符的文本隐藏加密工具"></a><a href="https://github.com/ruanyf/weekly/issues/796" target="_blank" rel="noopener">基于零宽字符的文本隐藏加密工具</a></h3><p>该工具的原理是利用零宽度字符，将加密文本转码后嵌入到普通文本当中，从而表面看起来是一段普通文本，但是复制粘贴不会丢失密文。</p>
<h3 id="free-for-dev"><a href="#free-for-dev" class="headerlink" title="free-for.dev"></a><a href="https://free-for.dev/" target="_blank" rel="noopener">free-for.dev</a></h3><p>该仓库收集各种可以免费使用的（或有免费层的）互联网服务。</p>
<h3 id="一个比直播睡觉更奇怪的网站：直播程序员写代码"><a href="#一个比直播睡觉更奇怪的网站：直播程序员写代码" class="headerlink" title="一个比直播睡觉更奇怪的网站：直播程序员写代码"></a><a href="http://www.luojiji.com/thread-329-1-1.html" target="_blank" rel="noopener">一个比直播睡觉更奇怪的网站：直播程序员写代码</a></h3><p>今天小编发现了一个奇怪的网站，一点进去它的主页就有一个直播窗口，内容是程序员坐在自己的电脑前写代码，比如这样：<br><img data-src="http://www.luojiji.com/data/attachment/forum/201511/21/214604ookffwq68gtzq89e.jpg" alt></p>
<p>当时在首页迎接我的，是一个比这张截图右下角的人类活泼得多的生物。他一直播放着那种很嗨的、让人想要摇摆起来的背景音乐，顺便有点自说自话性质的念叨着自己正在写的代码。结果就是，我居然沉浸在这种类似于看人直播睡觉的诡异气氛中，心甘情愿地看着一个陌生人3分钟说了2个terrible，4个sucks，以及5个shit。（就是这个人↓）<br><img data-src="http://www.luojiji.com/data/attachment/forum/201511/21/214604kuh1d8vpzp1u13j4.jpg" alt></p>
<p>把首页往下拉，会发现两句对网站的文字介绍：这是一个教育性质的直播平台，用这种直播程序员们用代码解决问题的真实场景的方法，来让大家相互学习、相互影响，更好地提升自己的技能。看到这段介绍的时候我的表情是这样的:<br><img data-src="http://www.luojiji.com/data/attachment/forum/201511/21/214605pjco6v9j79yjixf0.jpg" alt></p>
<p>好奇地翻了一下网站的其他内容之后，我发现它确实是一个教育性质的直播平台，而且是既有趣又酷的那种。在网站的直播频道，页面会显示出直播的截图封面和标题，直播者的ID和国籍，以及直播内容所属的开发语言和难易程度。<br><img data-src="http://www.luojiji.com/data/attachment/forum/201511/21/214608ukmrh00gm8k8q082.jpg" alt></p>
<p>小编看着学写代码还可以如此好玩，不得不佩服在线教育领域玩家们的脑洞。其实在小编眼里，学习写程序一直以来就是一件枯燥的事，说起IT男，你懂的。可有人说他们才是这个时代最具匠心的手艺人，因为科技带来的改变是程序员们一行一行代码写就的成果，仔细想想，确实如此。前段时间比较火的新兴职业——程序员鼓励师，就是为鼓励程序员快乐地写代码而设的，而他们值得拥有。</p>
<h2 id="Experience"><a href="#Experience" class="headerlink" title="Experience"></a>Experience</h2><p>数据科学是软件业中唯一需要博士学位的地方，但也有很多数据科学家没有博士学位。如果您想从事任何其他的软件开发，则完全不需要博士学位。<br>– <a href="https://news.ycombinator.com/item?id=21113635" target="_blank" rel="noopener">HN 读者讨论程序员是否需要博士学位</a></p>
<h3 id="滚动条的演进"><a href="#滚动条的演进" class="headerlink" title="滚动条的演进"></a><a href="https://scrollbars.matoseb.com/" target="_blank" rel="noopener">滚动条的演进</a></h3><p><img data-src="https://www.wangbase.com/blogimg/asset/201911/bg2019110302.jpg" alt></p>
<p>这个网页展示自从有计算机以来，系统滚动条的样式变化。</p>
<h3 id="简明-Python-教程"><a href="#简明-Python-教程" class="headerlink" title="简明 Python 教程"></a><a href="https://bop.mol.uno/" target="_blank" rel="noopener">简明 Python 教程</a></h3><p>Python 初学者教程《A Byte of Python》的中文翻译。</p>
<h3 id="Modern-C（第二版）"><a href="#Modern-C（第二版）" class="headerlink" title="Modern C（第二版）"></a><a href="http://modernc.gforge.inria.fr/" target="_blank" rel="noopener">Modern C（第二版）</a></h3><p><img data-src="https://www.wangbase.com/blogimg/asset/201909/bg2019091902.jpg" alt></p>
<p>最新出版的 C 语言的英文教材，作者提供免费下载。</p>
<h3 id="labstack"><a href="#labstack" class="headerlink" title="labstack"></a><a href="https://code.labstack.com/program" target="_blank" rel="noopener">labstack</a></h3><p>在线的代码运行试验环境（playground），支持15种语言，包括 C、C++、Python、Go、Ruby、Swift等。</p>
<h3 id="我如何在40天里面写一个-C-语言编译器（英文）"><a href="#我如何在40天里面写一个-C-语言编译器（英文）" class="headerlink" title="我如何在40天里面写一个 C 语言编译器（英文）"></a><a href="https://www.sigbus.info/how-i-wrote-a-self-hosting-c-compiler-in-40-days" target="_blank" rel="noopener">我如何在40天里面写一个 C 语言编译器（英文）</a></h3><p>作者的编译器开发日记，第一天写了20行代码，发展到后来的4000行，记录了每一天所解决的问题。</p>
<h3 id="10种最佳的-Python-IDE（英文）"><a href="#10种最佳的-Python-IDE（英文）" class="headerlink" title="10种最佳的 Python IDE（英文）"></a><a href="https://codinginfinite.com/best-python-ide-code-editors-top-10/" target="_blank" rel="noopener">10种最佳的 Python IDE（英文）</a></h3><p>本文介绍了10种 Python 编程 IDE（集成编程环境），每一种的简介和特点。</p>
<h3 id="ShowMeBug"><a href="#ShowMeBug" class="headerlink" title="ShowMeBug"></a><a href="https://www.showmebug.com/" target="_blank" rel="noopener">ShowMeBug</a></h3><p><img data-src="https://www.wangbase.com/blogimg/asset/201909/bg2019091005.png" alt></p>
<p>一个国产的在线实时编程环境，程序员面试助手，可以实时观看应聘者远程编程。</p>
<h3 id="G-Shock-电子表"><a href="#G-Shock-电子表" class="headerlink" title="G-Shock 电子表"></a><a href="https://www.ablogtowatch.com/tokyo-man-designs-casio-g-shock-watches-ryusuke-moriai/" target="_blank" rel="noopener">G-Shock 电子表</a></h3><p>G-Shock 是卡西欧的高端电子表品牌，本文以几十张照片介绍 G-Shock 的设计师（下图右一），以及他是如何设计电子表的。</p>
<p><img data-src="https://www.wangbase.com/blogimg/asset/201908/bg2019082401.jpg" alt><br><img data-src="https://www.wangbase.com/blogimg/asset/201908/bg2019082402.jpg" alt></p>
<h3 id="程序员太太太太难了"><a href="#程序员太太太太难了" class="headerlink" title="程序员太太太太难了"></a><a href="https://baike.baidu.com/vbaike/%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A4%AA%E5%A4%AA%E5%A4%AA%E5%A4%AA%E9%9A%BE%E4%BA%86/40240" target="_blank" rel="noopener">程序员太太太太难了</a></h3><p>10月24日是程序员日，据说来源于2¹⁰ = 1024。虽然只是一个民间创意节日，但我们真心感谢程序员们，一直以来的默默付出。祝愿所有程序员们的世界，永远没有bug！</p>
<p><img data-src="https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/crop%3D0%2C1220%2C730%2C1000/sign=d1b8d2440d087bf469a30da9cfe37b1d/838ba61ea8d3fd1f8d194f353f4e251f95ca5fa9.jpg" alt></p>
<h3 id="Regexper"><a href="#Regexper" class="headerlink" title="Regexper"></a><a href="https://regexper.com/#%2F%5B0-9%5D%5Cs%5B0-9%5D%2F" target="_blank" rel="noopener">Regexper</a></h3><p><img data-src="https://www.wangbase.com/blogimg/asset/201909/bg2019091704.jpg" alt></p>
<p>将 JS 的正则表达式转成图形解释的在线工具。</p>
<h3 id="folder-explorer"><a href="#folder-explorer" class="headerlink" title="folder-explorer"></a><a href="https://github.com/d2-projects/folder-explorer" target="_blank" rel="noopener">folder-explorer</a></h3><p><img data-src="https://www.wangbase.com/blogimg/asset/201909/bg2019092804.jpg" alt></p>
<p>扫描一个目录，给出目录结构、文件大小等统计信息的桌面工具。</p>
<h3 id="java-design-patterns"><a href="#java-design-patterns" class="headerlink" title="java-design-patterns"></a><a href="https://java-design-patterns.com/patterns/" target="_blank" rel="noopener">java-design-patterns</a></h3><p>一个开源仓库，收集 Java 语言的各种编程模式。</p>
<h3 id="codelani"><a href="#codelani" class="headerlink" title="codelani"></a><a href="https://codelani.com//lists/languages.html" target="_blank" rel="noopener">codelani</a></h3><p>该仓库对所有计算机语言进行统计，目前一共收集了3563种。</p>
<h3 id="企业软件已死"><a href="#企业软件已死" class="headerlink" title="企业软件已死"></a><a href="https://capiche.com/p/enterprise-software-is-dead" target="_blank" rel="noopener">企业软件已死</a></h3><p>几十年来，企业软件（即针对大公司的软件）与其它软件存在明显的区别，有着不同的品牌目标、不同的产品优先级和不同的销售周期。</p>
<p>今天，这些差异正在消失。企业软件的区别变得无关紧要，未来将全都是商务软件。</p>
<p><img data-src="https://www.wangbase.com/blogimg/asset/201911/bg2019112104.jpg" alt></p>
<p>原因一：SaaS 的出现，改变了软件的销售模式。</p>
<p>云端软件的出现，使得软件的开发速度和成本降低了几个数量级。软件的购买决策，慢慢不再由上层决定，而开始变成自下而上的决策。起初，小团队和个人会自发使用一些帮助他们解决问题的工具，然后这种行为会在整个公司中蔓延。</p>
<p>比如，一个小组先采用了 Slack，然后整个团队都在用，接着邻近的团队也开始用，直至其他部门的团队也开始用。最终，高管们别无选择，只能在整个公司范围内采用它。如果普通员工一直在使用替代解决方案，并且知道它更有效时，他们就会站起来并要求采用它。</p>
<p>随着软件自下而上地采用，业务部门的行为开始像消费者。一个小团队会一时兴起尝试新事物，如果不起作用，他们会继续前进，尝试其他选择。如果确实可行，他们将继续使用它，甚至将其散布到整个组织中。</p>
<p>原因二：公司使用的软件品种激增。</p>
<p>根据一项统计，过去的15年中，公司使用的软件工具的品种激增。曾经的企业软件包含的专有功能（例如：性能管理，团队沟通，文件共享等），现在都不得不与专注于单一功能解决方案的 SaaS 公司竞争。这意味着，企业软件的固定合同锁定模式已经一去不复返了，企业软件对客户将不再有多年的锁定，而是必须与那些不断涌现的廉价云端替代产品竞争。</p>
<p>原因三：单个软件的使用周期变短。</p>
<p>公司也比以往任何时候，都更加频繁地更换工具。以前，IBM 出售企业软件时，会派遣一个团队在客户公司的办公室内安装价值25万美元的硬件。如果该客户想要更换软件，就需要将所有这些硬件都丢掉，向另一家公司支付6位数的费用，然后进行数月的迁移。现在只需要点几下鼠标，就能完成数据迁移。</p>
<p>总之，目前的现状就是，越来越多的企业将更多的业务转移到线上和云上，因此整个市场正在扩展。企业只要以每个用户每月几美元的价格，就能开始使用一个软件。通往企业软件的道路比以往任何时候都更短、更容易，并且软件公司非常容易融资，因此新产品不断涌现。最后，市场已经大规模分散化，企业以前会购买一个涵盖多种工具的单一产品套件，而现在则是分散购买不同功能、不同业务的在线服务组合。</p>
<p>这一切意味着：</p>
<p>（1）企业软件已死，以后只存在用于工作场所的软件。当然，发展一家财富500强公司作为客户，与发展一家75人的创业公司，仍然有所不同，但是销售的差异正在迅速缩小。</p>
<p>（2）现在，仅靠说服决策者，不再能赢得客户，需要为整个组织上下的所有最终用户提供令人愉悦的体验才可以。客户群正在从高管，转变为这些公司中数以百万计的工作人员。</p>
<p>（3）市场比以往任何时候都更具流动性。软件供应商曾经每年竞争一次年度合同，现在则是每天都在竞争。</p>
<p>（4）最后，品牌以新的方式发挥作用。企业软件的品牌曾经追求代表稳定性和可靠性。今天，如果软件不酷，就无法取胜。</p>
<h3 id="Sourcetrail"><a href="#Sourcetrail" class="headerlink" title="Sourcetrail"></a><a href="https://www.sourcetrail.com/blog/open_source/" target="_blank" rel="noopener">Sourcetrail</a></h3><p><img data-src="https://www.wangbase.com/blogimg/asset/201911/bg2019112116.jpg" alt></p>
<p>可视化源码浏览器，可以对 C、C ++、Java、Python 源代码进行静态分析，并以图形可视化的形式呈现。</p>
<h3 id="HomeBrew、CakeBrew"><a href="#HomeBrew、CakeBrew" class="headerlink" title="HomeBrew、CakeBrew"></a><a href="https://juejin.im/post/5b3c694f6fb9a04fb309d959" target="_blank" rel="noopener">HomeBrew、CakeBrew</a></h3><p>HomeBrew、CakeBrew对于开发者来说，这个软件几乎是 Mac 上必备的一个软件，它的官方简介就是 “The missing package manager for macOS”，算是 Mac 上的一个软件包平台，它里面包含着非常多的 Mac 开发软件包，比如 Python、PHP、Redis、MySQL、RabbitMQ、HBase 等等，几乎你能想到的开发软件都集成在里面了，堪称神器！它的安装也非常简单，参见这里：<a href="https://brew.sh/，另外" target="_blank" rel="noopener">https://brew.sh/，另外</a> HomeBrew 也有对应的图形界面，叫做 CakeBrew，如果不喜欢命令行操作的话可以使用 CakeBrew 来代替。</p>
<h3 id="Alfred"><a href="#Alfred" class="headerlink" title="Alfred"></a><a href="https://juejin.im/post/5b3c694f6fb9a04fb309d959" target="_blank" rel="noopener">Alfred</a></h3><p>首推 Alfred，可以说是 Mac 必备软件，利用它我们可以快速地进行各种操作，大幅提高工作效率，如快速打开某个软件、快速打开某个链接、快速搜索某个文档，快速定位某个文件，快速查看本机 IP，快速定义某个色值，几乎你能想到的都能对接实现。</p>
<p><img data-src="https://user-gold-cdn.xitu.io/2018/7/4/16463fc25d65ddc5?imageView2/0/w/1280/h/960/format/png/ignore-error/1" alt></p>
<p>这些快速功能是怎么实现的呢？实际上是 Alfred 对接了很多 Workflow，我们可以使用 Workflow 方便地进行功能扩展，一些比较优秀的 Workflow 已经有人专门做过整理了，可以参见：<a href="https://github.com/zenorocha/alfred-workflows。" target="_blank" rel="noopener">https://github.com/zenorocha/alfred-workflows。</a></p>
<h3 id="Sublime"><a href="#Sublime" class="headerlink" title="Sublime"></a><a href="https://juejin.im/post/5b3c694f6fb9a04fb309d959" target="_blank" rel="noopener">Sublime</a></h3><p><img data-src="https://user-gold-cdn.xitu.io/2018/7/4/16463fc27e12fd30?imageView2/0/w/1280/h/960/format/png/ignore-error/1" alt></p>
<p>Sublime有时候我们可能下载了或接收了一些单个的文本文件，我们只想看看文本文件内容是什么，或者对其再做一些简单的修改操作，这时候就没必要单独用 JetBrains 的 IDE 打开了，显得有点重了。或者有时候需要修改某个配置文件，这时候也需要一个比较好用的编辑器。我使用的就是 Sublime，对于一些日常的文本编辑是足够了，另外 Sublime 还可以扩展好多插件，配置好了功能上基本不输 JetBrains IDE，非常推荐。推荐指数：★★★★</p>
<h3 id="Terrastruct"><a href="#Terrastruct" class="headerlink" title="Terrastruct"></a><a href="https://terrastruct.com/" target="_blank" rel="noopener">Terrastruct</a></h3><p><img data-src="https://www.wangbase.com/blogimg/asset/202001/bg2020010501.jpg" alt><br>一个在线的架构图、流程图工具。</p>
<h3 id="SnippetLab"><a href="#SnippetLab" class="headerlink" title="SnippetLab"></a><a href="https://juejin.im/post/5b3c694f6fb9a04fb309d959" target="_blank" rel="noopener">SnippetLab</a></h3><p>在写代码的时候，我们经常会有一些常用代码或者精华代码，或者一些常用的配置，想要单独保存下来复用，这时我们可能会把它保存到某个文本文件里面，更高级点可以使用云笔记，如有道云笔记或者印象笔记，用过 GitHub Gists 的小伙伴可能会选择 GitHub Gists，但我觉得这些都不是最佳的。首先文本文件、云笔记里面其实并不是专门为了保存代码使用的，另外 GitHub Gists 保存操作并没有那么便捷，而且打开速度也很慢，影响体验。在这里推荐一款专门用来保存代码的软件叫做 SnippetLab，其设计初衷就是为了保存短代码片的，它支持几乎所有编程语言，另外支持分类、分级、加标签、加描述等，另外它还可以和 Alfred 对接实现快速搜索查找，另外还支持备份、导出、云同步等各种功能，非常适合做代码片的管理。推荐指数：★★★★</p>
<h3 id="CVE-搜索"><a href="#CVE-搜索" class="headerlink" title="CVE 搜索"></a><a href="http://cve.mitre.org/cve/search_cve_list.html" target="_blank" rel="noopener">CVE 搜索</a></h3><p>CVE 是严重的计算机 Bug 的一个编号系统。这是 CVE 的官方搜索系统，可以查找已经编号的 Bug，比如搜索 WordPress，可以返回2392条结果。</p>
<h3 id="我的十年回顾（英文）"><a href="#我的十年回顾（英文）" class="headerlink" title="我的十年回顾（英文）"></a><a href="https://overreacted.io/my-decade-in-review/" target="_blank" rel="noopener">我的十年回顾（英文）</a></h3><p>著名 JavaScript 程序员、Redux 作者 Dan Abramov 回顾自己的过去十年，从一个没有上大学的俄罗斯高中毕业生，到 Facebook 公司 React 团队的重要成员。</p>
<h3 id="GOTO-语句被认为有害（中文）"><a href="#GOTO-语句被认为有害（中文）" class="headerlink" title="GOTO 语句被认为有害（中文）"></a><a href="https://www.emon100.me/goto-translation/" target="_blank" rel="noopener">GOTO 语句被认为有害（中文）</a></h3><p>Dijkstra 的《GOTO 有害论》在网上只有两个不太好的翻译版本。于是我花了15天翻译了此文。希望能对想用中文了解原文，历史，评价的人能有所帮助吧。</p>
<h3 id="我编程20年的指导原则（英文）"><a href="#我编程20年的指导原则（英文）" class="headerlink" title="我编程20年的指导原则（英文）"></a><a href="https://medium.com/@alexewerlof/my-guiding-principles-after-20-years-of-programming-a087dc55596c" target="_blank" rel="noopener">我编程20年的指导原则（英文）</a></h3><p>一个编程20年的资深程序员，总结自己编写软件的原则，其中一条是：安全性 &gt; 可用性 &gt; 可维护性 &gt; 代码简洁 &gt; 性能 。另一条是，除非已经完全理解了所要解决的问题，否则不要动手写代码。</p>
<h3 id="软件认证浪费时间和金钱（英文）"><a href="#软件认证浪费时间和金钱（英文）" class="headerlink" title="软件认证浪费时间和金钱（英文）"></a><a href="http://tomaytotomato.com/certs-waste-of-time/" target="_blank" rel="noopener">软件认证浪费时间和金钱（英文）</a></h3><p>作者提出一系列理由，认为各种软件资格证书并无意义，不值得为了它们花费时间和金钱。</p>
<h3 id="GameBoy-模拟器教程：使用-JavaScript-语言"><a href="#GameBoy-模拟器教程：使用-JavaScript-语言" class="headerlink" title="GameBoy 模拟器教程：使用 JavaScript 语言"></a><a href="http://imrannazar.com/GameBoy-Emulation-in-JavaScript:-The-CPU" target="_blank" rel="noopener">GameBoy 模拟器教程：使用 JavaScript 语言</a></h3><p>这组系列文章讲解，如何用 JavaScript 语言模拟 GameBoy 的硬件，可以用来了解硬件知识。</p>
<h3 id="黑客的贝叶斯方法：以-Python-为例"><a href="#黑客的贝叶斯方法：以-Python-为例" class="headerlink" title="黑客的贝叶斯方法：以 Python 为例"></a><a href="https://github.com/CamDavidsonPilon/Probabilistic-Programming-and-Bayesian-Methods-for-Hackers" target="_blank" rel="noopener">黑客的贝叶斯方法：以 Python 为例</a></h3><p><img data-src="https://www.wangbase.com/blogimg/asset/202003/bg2020030502.jpg" alt></p>
<p>免费的英文电子书，讲解贝叶斯概率在 Python 语言中的应用。</p>
<h3 id="过早优化的谬误"><a href="#过早优化的谬误" class="headerlink" title="过早优化的谬误"></a><a href="https://ubiquity.acm.org/article.cfm?id=1513451" target="_blank" rel="noopener">过早优化的谬误</a></h3><p>Tony Hoare 曾经说过：”过早的优化是万恶之源”。经过 Donald Knuth 大师的推荐，这句话已成为软件工程师的名言。</p>
<p><img data-src="https://www.wangbase.com/blogimg/asset/202003/bg2020030404.jpg" alt></p>
<p>不幸的是，它被误解扭曲了。许多软件工程师将这一准则理解成”你永远不应该优化代码！”，认为没有必要进行优化。</p>
<p>Tony Hoare 和 Donald Knuth 的真正意思是，代码微优化（例如，一条特定语句消耗多少 CPU 周期）之前，开发者应该担心其他问题。而且，原话并不是说：”在开发的早期阶段，关注程序的性能是有害的。” 他只是反对过早的优化。</p>
<p>以下几点理由，可以解释为什么不能忽视软件性能。程序员正确的做法应该是，在软件开发的早期阶段，就关注性能问题。</p>
<p>（1）性能问题不容易在软件开发的最后阶段解决。<code>20％的代码占用了80％执行时间</code>，它们可能散布在整个源代码中，不容易一次性修改解决。<br>（2）许多工程师相信，到软件发布时，CPU 的性能将会提高，以弥补部分代码的性能低下。尽管在1990年代确实如此，但在最近十年 CPU 性能非常有限。<br>（3）软件工程师认为，他们的时间比 CPU 时间更有价值。因此，浪费 CPU 周期以减少开发时间是对的。但是，他们忘记了，用户的时间比他们的时间更有价值。<br>（4）优化可能会导致产品延迟进入市场，并降低利润，这是正确的。但这种想法忽略了性能不佳的产品可能很难销售，尤其是在市场竞争激烈的情况下。<br>（5）有些程序员认为，几乎没有必要确保在软件的设计阶段，就使用最佳算法，先实现功能再说，因为以后总是可以替换更好的算法。所以，无需担心软件在开发阶段的性能，以后可以通过更好的算法对其进行提高。不幸的是，更好的算法在后期不一定可以实现，而且代码往往因为牵扯太多，无法轻易替换其中某个部分。</p>
<h3 id="中国地图坐标简介（英文）"><a href="#中国地图坐标简介（英文）" class="headerlink" title="中国地图坐标简介（英文）"></a><a href="https://abstractkitchen.com/blog/a-short-guide-to-chinese-coordinate-system/" target="_blank" rel="noopener">中国地图坐标简介（英文）</a></h3><p><img data-src="https://www.wangbase.com/blogimg/asset/202002/bg2020021602.jpg" alt></p>
<p>中国的地图坐标不同于国际通用坐标，在标准地图会产生几百米的偏移，必须采用算法换算。</p>
<h3 id="Swift-Playgrounds"><a href="#Swift-Playgrounds" class="headerlink" title="Swift Playgrounds"></a><a href="https://apps.apple.com/us/app/swift-playgrounds/id1496833156?mt=12" target="_blank" rel="noopener">Swift Playgrounds</a></h3><p><img data-src="https://www.wangbase.com/blogimg/asset/202002/bg2020021403.jpg" alt></p>
<p>苹果公司官方的免费 Mac 桌面软件，通过游戏学习 Swift 语言。</p>
<h3 id="Unity-官方教程"><a href="#Unity-官方教程" class="headerlink" title="Unity 官方教程"></a><a href="https://learn.unity.com/" target="_blank" rel="noopener">Unity 官方教程</a></h3><p><img data-src="https://www.wangbase.com/blogimg/asset/202003/bg2020032704.jpg" alt><br>Unity 是一个游戏开发引擎，它的官方教程现在免费开放3个月，从零教你写一个 3D 游戏，教程质量相当高。</p>
<h3 id="codefence"><a href="#codefence" class="headerlink" title="codefence"></a><a href="https://codefence.io/" target="_blank" rel="noopener">codefence</a></h3><p>一个可以嵌入网页的交互式代码编辑器，用户能够直接在网页上输入代码并运行，得到结果。服务端是 Docker 容器，目前支持十几种主流的计算机语言。</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="https://electronjs.org/releases/stable" target="_blank" rel="noopener">Electron 7.0.0</a></li>
<li><a href="https://www.ithome.com/0/452/533.htm" target="_blank" rel="noopener">Electron 7.0.0稳定版正式发布：跨平台桌面应用开发工具</a></li>
<li><a href="https://www.conventionalcommits.org/zh-cn/v1.0.0-beta.4/" target="_blank" rel="noopener">提交信息的规范</a></li>
<li><a href="https://www.bfilipek.com/2019/10/cppecosystem.html" target="_blank" rel="noopener">C++ 生态环境介绍</a></li>
<li><a href="https://archiveprogram.github.com/" target="_blank" rel="noopener">北极代码地窖</a></li>
<li><a href="https://news.codecademy.com/bjarne-stroustrup-interview/" target="_blank" rel="noopener">C++ 创始人 Bjarne Stroustrup 访谈</a></li>
<li><a href="https://www.phoronix.com/scan.php?page=article&amp;item=macos1015-win10-ubuntu&amp;num=1" target="_blank" rel="noopener">MacOS、Windows、Ubuntu 性能比较</a></li>
<li><a href="https://www5.in.tum.de/~huckle/bugse.html" target="_blank" rel="noopener">软件 bug 大事记</a></li>
<li><a href="https://www.jianshu.com/p/b477b2cc6cfa" target="_blank" rel="noopener">软件架构编年史</a></li>
<li><a href="https://github.com/xindoo/eng-practices-cn" target="_blank" rel="noopener">谷歌工程实践文档</a></li>
<li><a href="https://coolshell.cn/" target="_blank" rel="noopener">50年前的登月程序和程序员有多硬核</a></li>
<li><a href="https://hackernoon.com/learn-java-with-these-mobile-apps-k9h35iu" target="_blank" rel="noopener">学习编程的安卓 App</a></li>
<li><a href="https://juejin.im/post/5b61626ae51d45195e0f9be1" target="_blank" rel="noopener">MacOS下Java开发环境搭建之JDK</a></li>
<li><a href="https://www.hangge.com/blog/cache/detail_2366.html" target="_blank" rel="noopener">Python - macOS下Python开发环境的搭建教程</a></li>
<li><a href="http://blog.jdk5.com/zh/jetbrains-activation-code/" target="_blank" rel="noopener">jetbrains全家桶phpstorm webstorm clion IntelliJ IDEA等注册码 定期更新</a></li>
<li><a href="http://c.biancheng.net/c/" target="_blank" rel="noopener">C语言入门教程</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/1016959663602400" target="_blank" rel="noopener">Python教程</a></li>
<li><a href="https://www.runoob.com/kotlin/kotlin-tutorial.html" target="_blank" rel="noopener">Kotlin 教程</a></li>
<li><a href="https://www.kotlincn.net/docs/tutorials/" target="_blank" rel="noopener">Kotlin 教程</a></li>
<li><a href="http://c.biancheng.net/java/" target="_blank" rel="noopener">Java学习教程</a></li>
<li><a href="https://www.runoob.com/java/java-tutorial.html" target="_blank" rel="noopener">Java 教程</a></li>
<li><a href="https://wiki.jikexueyuan.com/project/java/" target="_blank" rel="noopener">Java 语言快速入门</a></li>
<li><a href="https://brew.sh" target="_blank" rel="noopener">Homebrew</a></li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner" target="_blank" rel="noopener">Code Runner</a></li>
<li><a href="https://www.zhihu.com/lives/1124809477068849152" target="_blank" rel="noopener">VS Code 从入门到进阶</a></li>
<li><a href="https://www.jianshu.com/p/acb1f062a925" target="_blank" rel="noopener">MAC 设置环境变量PATH 和 查看PATH</a></li>
<li><a href="https://github.com/" target="_blank" rel="noopener">Github</a></li>
<li><a href="https://coding.net/" target="_blank" rel="noopener">Coding</a></li>
<li><a href="http://stackoverflow.com/" target="_blank" rel="noopener">Stack Overflow</a></li>
<li><a href="http://www.qiniu.com/pricing" target="_blank" rel="noopener">七牛</a></li>
<li><a href="http://www.google.com/ncr" target="_blank" rel="noopener">Google</a></li>
<li><a href="http://zhibimo.com/read/xiaolai/everyone-can-use-english/" target="_blank" rel="noopener">English</a></li>
<li><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">Git教程</a></li>
<li><a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="noopener">Python教程</a></li>
<li><a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">hexo-theme-yilia</a></li>
<li><a href="https://atom.io/" target="_blank" rel="noopener">atom</a>——A hackable text editor for the 21st Century</li>
<li><a href="https://book.douban.com/subject/10794788/" target="_blank" rel="noopener">鸟哥的Linux私房菜（第三版）</a></li>
<li><a href="https://book.douban.com/subject/5333562/" target="_blank" rel="noopener">深入理解计算机系统</a></li>
<li><a href="https://book.douban.com/subject/6424904/" target="_blank" rel="noopener">大话数据结构</a></li>
<li><a href="https://book.douban.com/subject/2334288/" target="_blank" rel="noopener">大话设计模式</a></li>
<li><a href="https://book.douban.com/subject/26829016/" target="_blank" rel="noopener">Python编程：从入门到实践</a></li>
<li><a href="https://book.douban.com/subject/25708312/" target="_blank" rel="noopener">C++ Primer 中文版（第 5 版）</a></li>
<li><a href="https://book.douban.com/subject/2130190/" target="_blank" rel="noopener">Java编程思想 （第4版）</a></li>
<li><a href="https://book.douban.com/subject/1139336/" target="_blank" rel="noopener">C程序设计语言</a></li>
<li><a href="https://github.com/ipcreator/free-programming-books-zh_CN" target="_blank" rel="noopener">免费的编程中文书籍索引</a></li>
<li><a href="https://book.douban.com/subject/5355285/" target="_blank" rel="noopener">编程人生</a></li>
<li><a href="https://book.douban.com/subject/1024570/" target="_blank" rel="noopener">编码的奥秘</a></li>
<li><a href="https://book.douban.com/subject/6021440/" target="_blank" rel="noopener">黑客与画家</a></li>
<li><a href="https://book.douban.com/subject/4163938/" target="_blank" rel="noopener">软件随想录</a></li>
<li><a href="https://www.cfpland.com/guides/speaking/" target="_blank" rel="noopener">技术大会演讲指南</a></li>
<li><a href="https://opensource.com/article/19/5/how-write-good-c-main-function" target="_blank" rel="noopener">C 语言主函数 main() 怎么写？</a></li>
<li><a href="https://blog.jse.li/posts/torrent/" target="_blank" rel="noopener">从头构建一个 BitTorrent 客户端</a></li>
<li><a href="https://github.com/geektutu/7days-golang" target="_blank" rel="noopener">7天用 Go 从零实现系列</a></li>
<li><a href="https://stackoverflow.com/questions/3790454/how-do-i-break-a-string-over-multiple-lines/21699210#21699210" target="_blank" rel="noopener">YAML 表示多行字符串的9种方法</a></li>
<li><a href="https://www.ithome.com/0/478/897.htm" target="_blank" rel="noopener">谷歌突然公布并开源 Pigweed：可提升嵌入式开发效率</a></li>
<li><a href="https://www.toutiao.com/a6781367878928040451/" target="_blank" rel="noopener">16 个好用的 Code Review 工具</a></li>
<li><a href="https://www.northjersey.com/story/news/new-jersey/2020/04/04/coronavirus-nj-40-year-old-system-adds-delay-unemployment-checks/2944985001/" target="_blank" rel="noopener">寻找 COBOL 程序员</a></li>
<li><a href="https://github.com/apioak/apioak/blob/master/README_CN.md" target="_blank" rel="noopener">apioak</a></li>
<li><a href="https://luyuhuang.github.io/2020/03/06/dht-and-p2p.html" target="_blank" rel="noopener">分布式哈希表 (DHT) 和 P2P 技术</a></li>
<li><a href="https://www.hashtagcoder.dev/blog/director-of-engineering" target="_blank" rel="noopener">CTO 干什么？</a></li>
<li><a href="https://academy.zenva.com/product/godot-101-game-engine-foundations/" target="_blank" rel="noopener">Godot 101 -游戏引擎基础</a></li>
<li><a href="https://www.wired.com/2013/10/hiroshi-yamauchi-henk-rogers/" target="_blank" rel="noopener">任天堂总裁山內溥的轶事</a></li>
<li><a href="https://github.com/githubhaohao/NDK_OpenGLES_3_0" target="_blank" rel="noopener">Android OpenGL ES 极简教程</a></li>
</ol>

    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/Profession/2020/Window/" rel="bookmark">Window</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/Journey/2020/Beauty/" rel="bookmark">Beauty</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/Profession/2020/Art/" rel="bookmark">Art</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/Wisdom/2020/SuShi/" rel="bookmark">SuShi</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/Journey/2020/Youth/" rel="bookmark">Youth</a></div>
    </li>
  </ul>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Life/" rel="tag"><i class="fa fa-tag"></i> Life</a>
              <a href="/tags/Journey/" rel="tag"><i class="fa fa-tag"></i> Journey</a>
              <a href="/tags/Profession/" rel="tag"><i class="fa fa-tag"></i> Profession</a>
              <a href="/tags/Art/" rel="tag"><i class="fa fa-tag"></i> Art</a>
              <a href="/tags/Coder/" rel="tag"><i class="fa fa-tag"></i> Coder</a>
              <a href="/tags/Design/" rel="tag"><i class="fa fa-tag"></i> Design</a>
          </div>

        
  <div class="post-widgets">
    <div class="wp_rating">
      <div id="wpac-rating"></div>
    </div>
  </div>


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Wisdom/2020/Boundary/" rel="prev" title="Boundary">
      <i class="fa fa-chevron-left"></i> Boundary
    </a></div>
      <div class="post-nav-item">
    <a href="/Profession/2020/Window/" rel="next" title="Window">
      Window <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#自学是门手艺"><span class="nav-number">1.</span> <span class="nav-text">自学是门手艺</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#01-前言"><span class="nav-number">1.1.</span> <span class="nav-text">01. 前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#02-如何证明你真的读过这本书？"><span class="nav-number">1.2.</span> <span class="nav-text">02. 如何证明你真的读过这本书？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#積ん読"><span class="nav-number">1.2.1.</span> <span class="nav-text">積ん読</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PoW"><span class="nav-number">1.2.2.</span> <span class="nav-text">PoW</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#具体步骤"><span class="nav-number">1.2.3.</span> <span class="nav-text">具体步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何使用-Pull-Request-为这本书校对"><span class="nav-number">1.2.4.</span> <span class="nav-text">如何使用 Pull Request 为这本书校对</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何在-Github-网站上将自己的-Fork-与原仓库同步"><span class="nav-number">1.2.5.</span> <span class="nav-text">如何在 Github 网站上将自己的 Fork 与原仓库同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何使用-github-记录自己的学习过程"><span class="nav-number">1.2.6.</span> <span class="nav-text">如何使用 github 记录自己的学习过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#为什么一定要掌握自学能力？"><span class="nav-number">2.</span> <span class="nav-text">为什么一定要掌握自学能力？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#为什么把编程当作自学的入口？"><span class="nav-number">3.</span> <span class="nav-text">为什么把编程当作自学的入口？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#（一）"><span class="nav-number">3.1.</span> <span class="nav-text">（一）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（二）"><span class="nav-number">3.2.</span> <span class="nav-text">（二）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（三）"><span class="nav-number">3.3.</span> <span class="nav-text">（三）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（四）"><span class="nav-number">3.4.</span> <span class="nav-text">（四）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（五）"><span class="nav-number">3.5.</span> <span class="nav-text">（五）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（六）"><span class="nav-number">3.6.</span> <span class="nav-text">（六）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#只靠阅读习得新技能"><span class="nav-number">4.</span> <span class="nav-text">只靠阅读习得新技能</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#开始阅读前的一些准备"><span class="nav-number">5.</span> <span class="nav-text">开始阅读前的一些准备</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#内容概要"><span class="nav-number">5.1.</span> <span class="nav-text">内容概要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#阅读策略"><span class="nav-number">5.2.</span> <span class="nav-text">阅读策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#心理建设"><span class="nav-number">5.3.</span> <span class="nav-text">心理建设</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于这一部分内容中的代码"><span class="nav-number">5.4.</span> <span class="nav-text">关于这一部分内容中的代码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#入口"><span class="nav-number">6.</span> <span class="nav-text">入口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#乔治・布尔"><span class="nav-number">6.1.</span> <span class="nav-text">乔治・布尔</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#布尔运算"><span class="nav-number">6.2.</span> <span class="nav-text">布尔运算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#布尔值"><span class="nav-number">6.2.1.</span> <span class="nav-text">布尔值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#逻辑操作符"><span class="nav-number">6.2.2.</span> <span class="nav-text">逻辑操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#布尔运算操作符"><span class="nav-number">6.2.3.</span> <span class="nav-text">布尔运算操作符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#流程控制"><span class="nav-number">6.3.</span> <span class="nav-text">流程控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#所谓算法"><span class="nav-number">6.4.</span> <span class="nav-text">所谓算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#所谓函数"><span class="nav-number">6.5.</span> <span class="nav-text">所谓函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#细节补充"><span class="nav-number">6.6.</span> <span class="nav-text">细节补充</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#语句"><span class="nav-number">6.6.1.</span> <span class="nav-text">语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#语句块"><span class="nav-number">6.6.2.</span> <span class="nav-text">语句块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注释"><span class="nav-number">6.6.3.</span> <span class="nav-text">注释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作符"><span class="nav-number">6.6.4.</span> <span class="nav-text">操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#赋值符号与操作符的连用"><span class="nav-number">6.6.5.</span> <span class="nav-text">赋值符号与操作符的连用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">6.7.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#值及其相应的运算"><span class="nav-number">7.</span> <span class="nav-text">值及其相应的运算</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#值"><span class="nav-number">7.1.</span> <span class="nav-text">值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#值的类型"><span class="nav-number">7.2.</span> <span class="nav-text">值的类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作符-1"><span class="nav-number">7.3.</span> <span class="nav-text">操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数值操作符"><span class="nav-number">7.3.1.</span> <span class="nav-text">数值操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#布尔值操作符"><span class="nav-number">7.3.2.</span> <span class="nav-text">布尔值操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#逻辑操作符-1"><span class="nav-number">7.3.3.</span> <span class="nav-text">逻辑操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串操作符"><span class="nav-number">7.3.4.</span> <span class="nav-text">字符串操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#列表的操作符"><span class="nav-number">7.3.5.</span> <span class="nav-text">列表的操作符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更复杂的运算"><span class="nav-number">7.4.</span> <span class="nav-text">更复杂的运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于布尔值的补充"><span class="nav-number">7.5.</span> <span class="nav-text">关于布尔值的补充</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于值的类型的补充"><span class="nav-number">7.6.</span> <span class="nav-text">关于值的类型的补充</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结-1"><span class="nav-number">7.7.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#备注"><span class="nav-number">7.8.</span> <span class="nav-text">备注</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#流程控制-1"><span class="nav-number">8.</span> <span class="nav-text">流程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#if-语句"><span class="nav-number">8.1.</span> <span class="nav-text">if 语句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#for-循环"><span class="nav-number">8.2.</span> <span class="nav-text">for 循环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#range-函数"><span class="nav-number">8.2.1.</span> <span class="nav-text">range() 函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Continue、Break-和-Pass"><span class="nav-number">8.2.2.</span> <span class="nav-text">Continue、Break 和 Pass</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#while-循环"><span class="nav-number">8.3.</span> <span class="nav-text">while 循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一个投骰子赌大小的游戏"><span class="nav-number">8.4.</span> <span class="nav-text">一个投骰子赌大小的游戏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结-2"><span class="nav-number">8.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数"><span class="nav-number">9.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#示例-print"><span class="nav-number">9.1.</span> <span class="nav-text">示例 print()</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本的使用方法"><span class="nav-number">9.1.1.</span> <span class="nav-text">基本的使用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#print-的官方文档说明"><span class="nav-number">9.1.2.</span> <span class="nav-text">print() 的官方文档说明</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关键字参数"><span class="nav-number">9.2.</span> <span class="nav-text">关键字参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#位置参数"><span class="nav-number">9.3.</span> <span class="nav-text">位置参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可选位置参数"><span class="nav-number">9.4.</span> <span class="nav-text">可选位置参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可接收很多值的位置参数"><span class="nav-number">9.5.</span> <span class="nav-text">可接收很多值的位置参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Class-也是函数"><span class="nav-number">9.6.</span> <span class="nav-text">Class 也是函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结-3"><span class="nav-number">9.7.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#字符串"><span class="nav-number">10.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#字符码表的转换"><span class="nav-number">10.1.</span> <span class="nav-text">字符码表的转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串的标示"><span class="nav-number">10.2.</span> <span class="nav-text">字符串的标示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串与数值之间的转换"><span class="nav-number">10.3.</span> <span class="nav-text">字符串与数值之间的转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#转义符"><span class="nav-number">10.4.</span> <span class="nav-text">转义符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串的操作符"><span class="nav-number">10.5.</span> <span class="nav-text">字符串的操作符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串的索引"><span class="nav-number">10.6.</span> <span class="nav-text">字符串的索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#处理字符串的内建函数"><span class="nav-number">10.7.</span> <span class="nav-text">处理字符串的内建函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#处理字符串的-Method"><span class="nav-number">10.8.</span> <span class="nav-text">处理字符串的 Method</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#大小写转换"><span class="nav-number">10.8.1.</span> <span class="nav-text">大小写转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#搜索与替换"><span class="nav-number">10.8.2.</span> <span class="nav-text">搜索与替换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#去除子字符"><span class="nav-number">10.8.3.</span> <span class="nav-text">去除子字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拆分字符串"><span class="nav-number">10.8.4.</span> <span class="nav-text">拆分字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拼接字符串"><span class="nav-number">10.8.5.</span> <span class="nav-text">拼接字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串排版"><span class="nav-number">10.8.6.</span> <span class="nav-text">字符串排版</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#格式化字符串"><span class="nav-number">10.8.7.</span> <span class="nav-text">格式化字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用-str-format"><span class="nav-number">10.8.7.1.</span> <span class="nav-text">使用 str.format()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用-f-string"><span class="nav-number">10.8.7.2.</span> <span class="nav-text">使用 f-string</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串属性"><span class="nav-number">10.8.8.</span> <span class="nav-text">字符串属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结-4"><span class="nav-number">10.9.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么数值没有像字符串值这样详细论述？"><span class="nav-number">10.10.</span> <span class="nav-text">为什么数值没有像字符串值这样详细论述？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据容器"><span class="nav-number">11.</span> <span class="nav-text">数据容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代（Iterate）"><span class="nav-number">11.1.</span> <span class="nav-text">迭代（Iterate）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#列表（List）"><span class="nav-number">11.2.</span> <span class="nav-text">列表（List）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#列表的生成"><span class="nav-number">11.2.1.</span> <span class="nav-text">列表的生成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#列表的操作符-1"><span class="nav-number">11.2.2.</span> <span class="nav-text">列表的操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#根据索引提取列表元素"><span class="nav-number">11.2.3.</span> <span class="nav-text">根据索引提取列表元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#列表可用的内建函数"><span class="nav-number">11.2.4.</span> <span class="nav-text">列表可用的内建函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Methods"><span class="nav-number">11.2.5.</span> <span class="nav-text">Methods</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-number">11.2.6.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#元组（Tuple）"><span class="nav-number">11.3.</span> <span class="nav-text">元组（Tuple）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集合（Set）"><span class="nav-number">11.4.</span> <span class="nav-text">集合（Set）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建"><span class="nav-number">11.4.1.</span> <span class="nav-text">创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作"><span class="nav-number">11.4.2.</span> <span class="nav-text">操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#逻辑运算"><span class="nav-number">11.4.3.</span> <span class="nav-text">逻辑运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#更新"><span class="nav-number">11.4.4.</span> <span class="nav-text">更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#冻结集合"><span class="nav-number">11.4.5.</span> <span class="nav-text">冻结集合</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字典（Dictionary）"><span class="nav-number">11.5.</span> <span class="nav-text">字典（Dictionary）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字典的生成"><span class="nav-number">11.5.1.</span> <span class="nav-text">字典的生成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#更新某个元素"><span class="nav-number">11.5.2.</span> <span class="nav-text">更新某个元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#添加元素"><span class="nav-number">11.5.3.</span> <span class="nav-text">添加元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除某个元素"><span class="nav-number">11.5.4.</span> <span class="nav-text">删除某个元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#逻辑操作符-2"><span class="nav-number">11.5.5.</span> <span class="nav-text">逻辑操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可用来操作的内建函数"><span class="nav-number">11.5.6.</span> <span class="nav-text">可用来操作的内建函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用-Methods"><span class="nav-number">11.5.7.</span> <span class="nav-text">常用 Methods</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代各种容器中的元素"><span class="nav-number">11.6.</span> <span class="nav-text">迭代各种容器中的元素</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代的同时获取索引"><span class="nav-number">11.6.1.</span> <span class="nav-text">迭代的同时获取索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代前排序"><span class="nav-number">11.6.2.</span> <span class="nav-text">迭代前排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同时迭代多个容器"><span class="nav-number">11.6.3.</span> <span class="nav-text">同时迭代多个容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代字典中的元素"><span class="nav-number">11.6.4.</span> <span class="nav-text">迭代字典中的元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结-5"><span class="nav-number">11.7.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#文件"><span class="nav-number">12.</span> <span class="nav-text">文件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建文件"><span class="nav-number">12.1.</span> <span class="nav-text">创建文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除文件"><span class="nav-number">12.2.</span> <span class="nav-text">删除文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#读写文件"><span class="nav-number">12.3.</span> <span class="nav-text">读写文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#with-语句块"><span class="nav-number">12.4.</span> <span class="nav-text">with 语句块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#另一个完整的程序"><span class="nav-number">12.5.</span> <span class="nav-text">另一个完整的程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结-6"><span class="nav-number">12.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#如何从容应对含有过多-“过早引用”-的知识？"><span class="nav-number">13.</span> <span class="nav-text">如何从容应对含有过多 “过早引用” 的知识？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#过早引用就是无所不在"><span class="nav-number">13.1.</span> <span class="nav-text">过早引用就是无所不在</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不懂也要硬着头皮读完"><span class="nav-number">13.2.</span> <span class="nav-text">不懂也要硬着头皮读完</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#磨练-“只字不差”-的能力"><span class="nav-number">13.3.</span> <span class="nav-text">磨练 “只字不差” 的能力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#好的记忆力很重要"><span class="nav-number">13.4.</span> <span class="nav-text">好的记忆力很重要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#尽快开始整理归纳总结"><span class="nav-number">13.5.</span> <span class="nav-text">尽快开始整理归纳总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#先关注使用再研究原理"><span class="nav-number">13.6.</span> <span class="nav-text">先关注使用再研究原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#尊重前人的总结和建议"><span class="nav-number">13.7.</span> <span class="nav-text">尊重前人的总结和建议</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#官方教程：The-Python-Tutorial"><span class="nav-number">14.</span> <span class="nav-text">官方教程：The Python Tutorial</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#官方文档中最重要的链接"><span class="nav-number">14.1.</span> <span class="nav-text">官方文档中最重要的链接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么一定要阅读官方文档"><span class="nav-number">14.2.</span> <span class="nav-text">为什么一定要阅读官方文档</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#将官方文档拉回本地"><span class="nav-number">14.3.</span> <span class="nav-text">将官方文档拉回本地</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#安装-git"><span class="nav-number">14.3.1.</span> <span class="nav-text">安装 git</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#下载源文件"><span class="nav-number">14.3.2.</span> <span class="nav-text">下载源文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安装-rst2ipynb"><span class="nav-number">14.3.3.</span> <span class="nav-text">安装 rst2ipynb</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#批量转换-rst-至-ipynb"><span class="nav-number">14.3.4.</span> <span class="nav-text">批量转换 rst 至 ipynb</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用-Sphinx-生成-html-epub-版本"><span class="nav-number">14.3.5.</span> <span class="nav-text">用 Sphinx 生成 html/epub 版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#下载已经转换好的版本"><span class="nav-number">14.3.6.</span> <span class="nav-text">下载已经转换好的版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#完整的-Python-Doc-制作"><span class="nav-number">14.3.7.</span> <span class="nav-text">完整的 Python Doc 制作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#笨拙与耐心"><span class="nav-number">15.</span> <span class="nav-text">笨拙与耐心</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#刻意练习"><span class="nav-number">16.</span> <span class="nav-text">刻意练习</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#为什么从函数开始？"><span class="nav-number">17.</span> <span class="nav-text">为什么从函数开始？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#关于参数（上）"><span class="nav-number">18.</span> <span class="nav-text">关于参数（上）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#为函数取名"><span class="nav-number">18.1.</span> <span class="nav-text">为函数取名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不接收任何参数的函数"><span class="nav-number">18.2.</span> <span class="nav-text">不接收任何参数的函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#没有-return-语句的函数"><span class="nav-number">18.3.</span> <span class="nav-text">没有 return 语句的函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接收外部传递进来的值"><span class="nav-number">18.4.</span> <span class="nav-text">接收外部传递进来的值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变量的作用域"><span class="nav-number">18.5.</span> <span class="nav-text">变量的作用域</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#关于参数（下）"><span class="nav-number">19.</span> <span class="nav-text">关于参数（下）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#可以接收一系列值的位置参数"><span class="nav-number">19.1.</span> <span class="nav-text">可以接收一系列值的位置参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为函数的某些参数设定默认值"><span class="nav-number">19.2.</span> <span class="nav-text">为函数的某些参数设定默认值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可以接收一系列值的关键字参数"><span class="nav-number">19.3.</span> <span class="nav-text">可以接收一系列值的关键字参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数定义时各种参数的排列顺序"><span class="nav-number">19.4.</span> <span class="nav-text">函数定义时各种参数的排列顺序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#化名与匿名"><span class="nav-number">20.</span> <span class="nav-text">化名与匿名</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#化名"><span class="nav-number">20.1.</span> <span class="nav-text">化名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lambda"><span class="nav-number">20.2.</span> <span class="nav-text">lambda</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lambda-的使用场景"><span class="nav-number">20.3.</span> <span class="nav-text">lambda 的使用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#作为某函数的返回值"><span class="nav-number">20.3.1.</span> <span class="nav-text">作为某函数的返回值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作为某函数的参数"><span class="nav-number">20.3.2.</span> <span class="nav-text">作为某函数的参数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#递归函数"><span class="nav-number">21.</span> <span class="nav-text">递归函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#递归（Recursion）"><span class="nav-number">21.1.</span> <span class="nav-text">递归（Recursion）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#递归函数的执行过程"><span class="nav-number">21.2.</span> <span class="nav-text">递归函数的执行过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#递归的终点"><span class="nav-number">21.3.</span> <span class="nav-text">递归的终点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变量的作用域-1"><span class="nav-number">21.4.</span> <span class="nav-text">变量的作用域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#递归函数三原则"><span class="nav-number">21.5.</span> <span class="nav-text">递归函数三原则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#思考与练习"><span class="nav-number">21.6.</span> <span class="nav-text">思考与练习</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数的文档"><span class="nav-number">22.</span> <span class="nav-text">函数的文档</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Docstring"><span class="nav-number">22.1.</span> <span class="nav-text">Docstring</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#书写-Docstring-的规范"><span class="nav-number">22.2.</span> <span class="nav-text">书写 Docstring 的规范</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sphinx-版本的-Docstring-规范"><span class="nav-number">22.3.</span> <span class="nav-text">Sphinx 版本的 Docstring 规范</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#保存到文件的函数"><span class="nav-number">23.</span> <span class="nav-text">保存到文件的函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#模块"><span class="nav-number">23.1.</span> <span class="nav-text">模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模块文件系统目录检索顺序"><span class="nav-number">23.2.</span> <span class="nav-text">模块文件系统目录检索顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#系统内建的模块"><span class="nav-number">23.3.</span> <span class="nav-text">系统内建的模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#引入指定模块中的特定函数"><span class="nav-number">23.4.</span> <span class="nav-text">引入指定模块中的特定函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#引入并使用化名"><span class="nav-number">23.5.</span> <span class="nav-text">引入并使用化名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模块中不一定只有函数"><span class="nav-number">23.6.</span> <span class="nav-text">模块中不一定只有函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dir-函数"><span class="nav-number">23.7.</span> <span class="nav-text">dir() 函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#测试驱动的开发"><span class="nav-number">24.</span> <span class="nav-text">测试驱动的开发</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#可执行的-Python-文件"><span class="nav-number">25.</span> <span class="nav-text">可执行的 Python 文件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#刻意思考"><span class="nav-number">26.</span> <span class="nav-text">刻意思考</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#战胜难点"><span class="nav-number">27.</span> <span class="nav-text">战胜难点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类-——-面向对象编程"><span class="nav-number">28.</span> <span class="nav-text">类 —— 面向对象编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象编程"><span class="nav-number">28.1.</span> <span class="nav-text">面向对象编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#争议"><span class="nav-number">28.2.</span> <span class="nav-text">争议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本术语"><span class="nav-number">28.3.</span> <span class="nav-text">基本术语</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类-——-Python-的实现"><span class="nav-number">29.</span> <span class="nav-text">类 —— Python 的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Defining-Class"><span class="nav-number">29.1.</span> <span class="nav-text">Defining Class</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Inheritance"><span class="nav-number">29.2.</span> <span class="nav-text">Inheritance</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Overrides"><span class="nav-number">29.3.</span> <span class="nav-text">Overrides</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Inspecting-A-Class"><span class="nav-number">29.4.</span> <span class="nav-text">Inspecting A Class</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Scope"><span class="nav-number">29.5.</span> <span class="nav-text">Scope</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Encapsulation"><span class="nav-number">29.6.</span> <span class="nav-text">Encapsulation</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数工具"><span class="nav-number">30.</span> <span class="nav-text">函数工具</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代器（Iterator）"><span class="nav-number">30.1.</span> <span class="nav-text">迭代器（Iterator）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#生成器（Generator）"><span class="nav-number">30.2.</span> <span class="nav-text">生成器（Generator）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#装饰器（Decorator）"><span class="nav-number">30.3.</span> <span class="nav-text">装饰器（Decorator）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数也是对象"><span class="nav-number">30.3.1.</span> <span class="nav-text">函数也是对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#装饰器操作符"><span class="nav-number">30.3.2.</span> <span class="nav-text">装饰器操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#装饰器的用途"><span class="nav-number">30.3.3.</span> <span class="nav-text">装饰器的用途</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#装饰带有参数的函数"><span class="nav-number">30.3.4.</span> <span class="nav-text">装饰带有参数的函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#学会装饰器究竟有多重要？"><span class="nav-number">30.3.5.</span> <span class="nav-text">学会装饰器究竟有多重要？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#正则表达式"><span class="nav-number">31.</span> <span class="nav-text">正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#视觉体验"><span class="nav-number">31.1.</span> <span class="nav-text">视觉体验</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#准备工作"><span class="nav-number">31.2.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#优先级"><span class="nav-number">31.3.</span> <span class="nav-text">优先级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原子"><span class="nav-number">31.4.</span> <span class="nav-text">原子</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#本义字符"><span class="nav-number">31.4.1.</span> <span class="nav-text">本义字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合原子"><span class="nav-number">31.4.2.</span> <span class="nav-text">集合原子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类别原子"><span class="nav-number">31.4.3.</span> <span class="nav-text">类别原子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#边界原子"><span class="nav-number">31.4.4.</span> <span class="nav-text">边界原子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组合原子"><span class="nav-number">31.4.5.</span> <span class="nav-text">组合原子</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数量操作符"><span class="nav-number">31.5.</span> <span class="nav-text">数量操作符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#或操作符"><span class="nav-number">31.6.</span> <span class="nav-text">或操作符 |</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#匹配并捕获"><span class="nav-number">31.7.</span> <span class="nav-text">匹配并捕获</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#非捕获匹配"><span class="nav-number">31.8.</span> <span class="nav-text">非捕获匹配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#控制标记"><span class="nav-number">31.9.</span> <span class="nav-text">控制标记</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#几个最常用的-Regex"><span class="nav-number">31.10.</span> <span class="nav-text">几个最常用的 Regex</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#趣事一则"><span class="nav-number">31.11.</span> <span class="nav-text">趣事一则</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#BNF-以及-EBNF"><span class="nav-number">32.</span> <span class="nav-text">BNF 以及 EBNF</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#拆解"><span class="nav-number">33.</span> <span class="nav-text">拆解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#横向拆解"><span class="nav-number">33.1.</span> <span class="nav-text">横向拆解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#纵向拆解"><span class="nav-number">33.2.</span> <span class="nav-text">纵向拆解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#触类旁通"><span class="nav-number">33.3.</span> <span class="nav-text">触类旁通</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#刚需幻觉"><span class="nav-number">34.</span> <span class="nav-text">刚需幻觉</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#感觉总是最大的坑"><span class="nav-number">34.1.</span> <span class="nav-text">感觉总是最大的坑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#刚需幻觉-1"><span class="nav-number">34.2.</span> <span class="nav-text">刚需幻觉</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#优势策略"><span class="nav-number">34.3.</span> <span class="nav-text">优势策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#影响下一代"><span class="nav-number">34.4.</span> <span class="nav-text">影响下一代</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#全面-——-自学的境界"><span class="nav-number">35.</span> <span class="nav-text">全面 —— 自学的境界</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#自学者的社交"><span class="nav-number">36.</span> <span class="nav-text">自学者的社交</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#这是自学者的黄金时代"><span class="nav-number">37.</span> <span class="nav-text">这是自学者的黄金时代</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#避免注意力漂移"><span class="nav-number">38.</span> <span class="nav-text">避免注意力漂移</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#如何成为优秀沟通者"><span class="nav-number">39.</span> <span class="nav-text">如何成为优秀沟通者</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#入门"><span class="nav-number">39.1.</span> <span class="nav-text">入门</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内容第一"><span class="nav-number">39.1.1.</span> <span class="nav-text">内容第一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内容质量"><span class="nav-number">39.1.2.</span> <span class="nav-text">内容质量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内容组织"><span class="nav-number">39.1.3.</span> <span class="nav-text">内容组织</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进阶"><span class="nav-number">39.2.</span> <span class="nav-text">进阶</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高级"><span class="nav-number">39.3.</span> <span class="nav-text">高级</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#自学者的终点"><span class="nav-number">40.</span> <span class="nav-text">自学者的终点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#the-craft-of-selfteaching"><span class="nav-number">41.</span> <span class="nav-text">the-craft-of-selfteaching</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#自学是门手艺-1"><span class="nav-number">42.</span> <span class="nav-text">自学是门手艺</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#目录"><span class="nav-number">42.1.</span> <span class="nav-text">目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于"><span class="nav-number">42.2.</span> <span class="nav-text">关于 文件转换为 ```.md``` 文件的备注：123456789101112131415```bash# 需提前安装 nbconvert 插件，Terminal 下执行：$ jupyter nbconvert --to markdown *.ipynb而后将所有 `.md` 文件移到 `markdown/` 目录之下 —— 除 `README.md` 文件之外`README.md` 文件复制一份到 `markdown/` 目录之下，而后编辑为当前文件# 需使用 VSCode 批量 Find and Replace:将所有 (https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/ 替换为 (https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/将所有 (Part.1.A.better.teachyourself_files/ 替换为 (https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/将所有 (Part.1.E.6.containers_files/ 替换为 (https://raw.githubusercontent.com/selfteaching/the-craft-of-selfteaching/master//images/将所有 ```\n\n 替换为 ```\n将所有	\n\n```	替换为 \n</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#下一步干什么？"><span class="nav-number">43.</span> <span class="nav-text">下一步干什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Python-必读书籍"><span class="nav-number">43.1.</span> <span class="nav-text">Python 必读书籍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Python-Cheatsheet"><span class="nav-number">43.2.</span> <span class="nav-text">Python Cheatsheet</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Awesome-Python"><span class="nav-number">43.3.</span> <span class="nav-text">Awesome Python</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CS-专业的人都在学什么？"><span class="nav-number">43.4.</span> <span class="nav-text">CS 专业的人都在学什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#全栈工程师路径图"><span class="nav-number">43.5.</span> <span class="nav-text">全栈工程师路径图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Introduction"><span class="nav-number">43.6.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Frontend-Roadmap"><span class="nav-number">43.7.</span> <span class="nav-text">Frontend Roadmap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Back-end-Roadmap"><span class="nav-number">43.8.</span> <span class="nav-text">Back-end Roadmap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DevOps-Roadmap"><span class="nav-number">43.9.</span> <span class="nav-text">DevOps Roadmap</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Visual-Studio-Code-的安装与配置"><span class="nav-number">44.</span> <span class="nav-text">Visual Studio Code 的安装与配置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#允许命令行启动-VS-Code"><span class="nav-number">44.1.</span> <span class="nav-text">允许命令行启动 VS Code</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#选择-Python-解析器版本"><span class="nav-number">44.2.</span> <span class="nav-text">选择 Python 解析器版本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#安装扩展"><span class="nav-number">44.3.</span> <span class="nav-text">安装扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自动补全"><span class="nav-number">44.4.</span> <span class="nav-text">自动补全</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Git-简介"><span class="nav-number">45.</span> <span class="nav-text">Git 简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#内容目标"><span class="nav-number">45.1.</span> <span class="nav-text">内容目标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么你必须学会使用-Git？"><span class="nav-number">45.2.</span> <span class="nav-text">为什么你必须学会使用 Git？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#从逻辑上理顺-Git-基本命令"><span class="nav-number">45.3.</span> <span class="nav-text">从逻辑上理顺 Git 基本命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Git-的安装"><span class="nav-number">45.4.</span> <span class="nav-text">Git 的安装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Mac"><span class="nav-number">45.4.1.</span> <span class="nav-text">Mac</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Windows"><span class="nav-number">45.4.2.</span> <span class="nav-text">Windows</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux"><span class="nav-number">45.4.3.</span> <span class="nav-text">Linux</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Git-本地配置"><span class="nav-number">45.4.4.</span> <span class="nav-text">Git 本地配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Git-GUI"><span class="nav-number">45.4.5.</span> <span class="nav-text">Git GUI</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#需要了解的-Bash-基本命令"><span class="nav-number">45.4.6.</span> <span class="nav-text">需要了解的 Bash 基本命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一些不错的-Git-教程"><span class="nav-number">45.5.</span> <span class="nav-text">一些不错的 Git 教程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Jupyterlab-的安装与配置"><span class="nav-number">46.</span> <span class="nav-text">Jupyterlab 的安装与配置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#下载并安装-Anaconda"><span class="nav-number">46.1.</span> <span class="nav-text">下载并安装 Anaconda</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第一次启动-Jupyter-lab"><span class="nav-number">46.2.</span> <span class="nav-text">第一次启动 Jupyter lab</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置-Jupyter-lab"><span class="nav-number">46.3.</span> <span class="nav-text">配置 Jupyter lab</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#将-Jupyter-lab-配置成系统服务"><span class="nav-number">46.4.</span> <span class="nav-text">将 Jupyter lab 配置成系统服务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于-Jupyter-lab-themes"><span class="nav-number">46.5.</span> <span class="nav-text">关于 Jupyter lab themes</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#安装插件"><span class="nav-number">46.6.</span> <span class="nav-text">安装插件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常用快捷键"><span class="nav-number">46.7.</span> <span class="nav-text">常用快捷键</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#增加一些必要的快捷键"><span class="nav-number">46.8.</span> <span class="nav-text">增加一些必要的快捷键</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#输出所有变量内容"><span class="nav-number">46.9.</span> <span class="nav-text">输出所有变量内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#魔法函数"><span class="nav-number">46.10.</span> <span class="nav-text">魔法函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#桌面版-Jupyter-App"><span class="nav-number">46.11.</span> <span class="nav-text">桌面版 Jupyter App</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Nteract"><span class="nav-number">46.11.1.</span> <span class="nav-text">Nteract</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pineapple"><span class="nav-number">46.11.2.</span> <span class="nav-text">Pineapple</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#这些符号都代表什么？"><span class="nav-number">47.</span> <span class="nav-text">这些符号都代表什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#自学是门艺术"><span class="nav-number">47.1.</span> <span class="nav-text">自学是门艺术</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PART-1"><span class="nav-number">47.2.</span> <span class="nav-text">PART 1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PART-2"><span class="nav-number">47.3.</span> <span class="nav-text">PART 2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PART-3"><span class="nav-number">47.4.</span> <span class="nav-text">PART 3</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#附章"><span class="nav-number">47.5.</span> <span class="nav-text">附章</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#附录"><span class="nav-number">47.6.</span> <span class="nav-text">附录</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#IPCreator’s-View-of-Coding"><span class="nav-number">48.</span> <span class="nav-text">IPCreator’s View of Coding</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Skill-is-acquired-through-correct-and-repetitive-practice-and-practice-makes-perfect"><span class="nav-number">48.1.</span> <span class="nav-text">Skill is acquired through correct and repetitive practice, and practice makes perfect.</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#太用力的人跑不远"><span class="nav-number">49.</span> <span class="nav-text">太用力的人跑不远</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#写在前面"><span class="nav-number">49.1.</span> <span class="nav-text">写在前面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IT人员怎么用力"><span class="nav-number">49.2.</span> <span class="nav-text">IT人员怎么用力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#太用力的人跑不远-1"><span class="nav-number">49.3.</span> <span class="nav-text">太用力的人跑不远</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#就像跑步，「太用力的人跑不远」。"><span class="nav-number">49.4.</span> <span class="nav-text">就像跑步，「太用力的人跑不远」。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最后"><span class="nav-number">49.5.</span> <span class="nav-text">最后</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#不是人人都懂的学习要点"><span class="nav-number">50.</span> <span class="nav-text">不是人人都懂的学习要点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一．学习也是一种能力"><span class="nav-number">50.1.</span> <span class="nav-text">一．学习也是一种能力</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二．买书是最划算的投资"><span class="nav-number">50.2.</span> <span class="nav-text">二．买书是最划算的投资</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三．多读经典书"><span class="nav-number">50.3.</span> <span class="nav-text">三．多读经典书</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四．不要在上班时间看书"><span class="nav-number">50.4.</span> <span class="nav-text">四．不要在上班时间看书</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、只学习与工作相关的东西"><span class="nav-number">50.5.</span> <span class="nav-text">五、只学习与工作相关的东西</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六．织网式的学习"><span class="nav-number">50.6.</span> <span class="nav-text">六．织网式的学习</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#七．问题是最好的学习机会"><span class="nav-number">50.7.</span> <span class="nav-text">七．问题是最好的学习机会</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#八．经常思考总结"><span class="nav-number">50.8.</span> <span class="nav-text">八．经常思考总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#九、克服“高原现象”"><span class="nav-number">50.9.</span> <span class="nav-text">九、克服“高原现象”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#十、学习要有好心态"><span class="nav-number">50.10.</span> <span class="nav-text">十、学习要有好心态</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#关于App程序员泡沫"><span class="nav-number">51.</span> <span class="nav-text">关于App程序员泡沫</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">51.1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-大环境"><span class="nav-number">51.2.</span> <span class="nav-text">1.大环境</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-App开发"><span class="nav-number">51.3.</span> <span class="nav-text">2.App开发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-安卓和ios灭亡"><span class="nav-number">51.4.</span> <span class="nav-text">3.安卓和ios灭亡</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-互联网职位稀缺性"><span class="nav-number">51.5.</span> <span class="nav-text">4.互联网职位稀缺性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-提升自己让别人去喷吧"><span class="nav-number">51.6.</span> <span class="nav-text">5.提升自己让别人去喷吧</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#笔记体系"><span class="nav-number">52.</span> <span class="nav-text">笔记体系</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Why"><span class="nav-number">52.1.</span> <span class="nav-text">Why</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#我为什么喜欢编程"><span class="nav-number">52.1.1.</span> <span class="nav-text">我为什么喜欢编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么Joel不谈软件了？"><span class="nav-number">52.1.2.</span> <span class="nav-text">为什么Joel不谈软件了？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#等几年，再用新框架"><span class="nav-number">52.1.3.</span> <span class="nav-text">等几年，再用新框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么大多数程序员都是男的？"><span class="nav-number">52.1.4.</span> <span class="nav-text">为什么大多数程序员都是男的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#程序员真的需要高智商吗？"><span class="nav-number">52.1.5.</span> <span class="nav-text">程序员真的需要高智商吗？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#What"><span class="nav-number">52.2.</span> <span class="nav-text">What</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Flex-amp-Bison"><span class="nav-number">52.2.1.</span> <span class="nav-text">Flex &amp; Bison</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于编程，你应该知道的几件事"><span class="nav-number">52.2.2.</span> <span class="nav-text">关于编程，你应该知道的几件事</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#雇主最欢迎的技术技能"><span class="nav-number">52.2.3.</span> <span class="nav-text">雇主最欢迎的技术技能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于战略问题的通信之六（译文）"><span class="nav-number">52.2.4.</span> <span class="nav-text">关于战略问题的通信之六（译文）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#罗胖60秒：什么是“设计”？"><span class="nav-number">52.2.5.</span> <span class="nav-text">罗胖60秒：什么是“设计”？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#软件架构被高估，清晰和简单的设计被低估"><span class="nav-number">52.2.6.</span> <span class="nav-text">软件架构被高估，清晰和简单的设计被低估</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Python"><span class="nav-number">52.2.7.</span> <span class="nav-text">Python</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中国传统颜色手册"><span class="nav-number">52.2.8.</span> <span class="nav-text">中国传统颜色手册</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#程序员管人"><span class="nav-number">52.2.9.</span> <span class="nav-text">程序员管人</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#程序员收入最高的美国技术公司"><span class="nav-number">52.2.10.</span> <span class="nav-text">程序员收入最高的美国技术公司</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#How"><span class="nav-number">52.3.</span> <span class="nav-text">How</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Git-原理解释（英文）"><span class="nav-number">52.3.1.</span> <span class="nav-text">Git 原理解释（英文）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何将任意命令装为图形界面？（英文）"><span class="nav-number">52.3.2.</span> <span class="nav-text">如何将任意命令装为图形界面？（英文）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于零宽字符的文本隐藏加密工具"><span class="nav-number">52.3.3.</span> <span class="nav-text">基于零宽字符的文本隐藏加密工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#free-for-dev"><span class="nav-number">52.3.4.</span> <span class="nav-text">free-for.dev</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一个比直播睡觉更奇怪的网站：直播程序员写代码"><span class="nav-number">52.3.5.</span> <span class="nav-text">一个比直播睡觉更奇怪的网站：直播程序员写代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Experience"><span class="nav-number">52.4.</span> <span class="nav-text">Experience</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#滚动条的演进"><span class="nav-number">52.4.1.</span> <span class="nav-text">滚动条的演进</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简明-Python-教程"><span class="nav-number">52.4.2.</span> <span class="nav-text">简明 Python 教程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Modern-C（第二版）"><span class="nav-number">52.4.3.</span> <span class="nav-text">Modern C（第二版）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#labstack"><span class="nav-number">52.4.4.</span> <span class="nav-text">labstack</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#我如何在40天里面写一个-C-语言编译器（英文）"><span class="nav-number">52.4.5.</span> <span class="nav-text">我如何在40天里面写一个 C 语言编译器（英文）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10种最佳的-Python-IDE（英文）"><span class="nav-number">52.4.6.</span> <span class="nav-text">10种最佳的 Python IDE（英文）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ShowMeBug"><span class="nav-number">52.4.7.</span> <span class="nav-text">ShowMeBug</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#G-Shock-电子表"><span class="nav-number">52.4.8.</span> <span class="nav-text">G-Shock 电子表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#程序员太太太太难了"><span class="nav-number">52.4.9.</span> <span class="nav-text">程序员太太太太难了</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Regexper"><span class="nav-number">52.4.10.</span> <span class="nav-text">Regexper</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#folder-explorer"><span class="nav-number">52.4.11.</span> <span class="nav-text">folder-explorer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java-design-patterns"><span class="nav-number">52.4.12.</span> <span class="nav-text">java-design-patterns</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#codelani"><span class="nav-number">52.4.13.</span> <span class="nav-text">codelani</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#企业软件已死"><span class="nav-number">52.4.14.</span> <span class="nav-text">企业软件已死</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sourcetrail"><span class="nav-number">52.4.15.</span> <span class="nav-text">Sourcetrail</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HomeBrew、CakeBrew"><span class="nav-number">52.4.16.</span> <span class="nav-text">HomeBrew、CakeBrew</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Alfred"><span class="nav-number">52.4.17.</span> <span class="nav-text">Alfred</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sublime"><span class="nav-number">52.4.18.</span> <span class="nav-text">Sublime</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Terrastruct"><span class="nav-number">52.4.19.</span> <span class="nav-text">Terrastruct</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SnippetLab"><span class="nav-number">52.4.20.</span> <span class="nav-text">SnippetLab</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CVE-搜索"><span class="nav-number">52.4.21.</span> <span class="nav-text">CVE 搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#我的十年回顾（英文）"><span class="nav-number">52.4.22.</span> <span class="nav-text">我的十年回顾（英文）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GOTO-语句被认为有害（中文）"><span class="nav-number">52.4.23.</span> <span class="nav-text">GOTO 语句被认为有害（中文）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#我编程20年的指导原则（英文）"><span class="nav-number">52.4.24.</span> <span class="nav-text">我编程20年的指导原则（英文）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#软件认证浪费时间和金钱（英文）"><span class="nav-number">52.4.25.</span> <span class="nav-text">软件认证浪费时间和金钱（英文）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GameBoy-模拟器教程：使用-JavaScript-语言"><span class="nav-number">52.4.26.</span> <span class="nav-text">GameBoy 模拟器教程：使用 JavaScript 语言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#黑客的贝叶斯方法：以-Python-为例"><span class="nav-number">52.4.27.</span> <span class="nav-text">黑客的贝叶斯方法：以 Python 为例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#过早优化的谬误"><span class="nav-number">52.4.28.</span> <span class="nav-text">过早优化的谬误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中国地图坐标简介（英文）"><span class="nav-number">52.4.29.</span> <span class="nav-text">中国地图坐标简介（英文）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Swift-Playgrounds"><span class="nav-number">52.4.30.</span> <span class="nav-text">Swift Playgrounds</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unity-官方教程"><span class="nav-number">52.4.31.</span> <span class="nav-text">Unity 官方教程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#codefence"><span class="nav-number">52.4.32.</span> <span class="nav-text">codefence</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reference"><span class="nav-number">52.5.</span> <span class="nav-text">Reference</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="IPCreator"
      src="/img/content/Kick-Off.jpg">
  <p class="site-author-name" itemprop="name">IPCreator</p>
  <div class="site-description" itemprop="description">Life is a journey.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">1534</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">1450</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → /atom.xml"><i class="rss fa-fw"></i>RSS</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://blog.163.com/zhuxuanlv@126/" title="http://blog.163.com/zhuxuanlv@126/" rel="noopener" target="_blank">163 Blog</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">IPCreator</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">27.3m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">412:53</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>



  



  <script>
  if (CONFIG.page.isPost) {
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id    : 11184,
      el    : 'wpac-rating',
      color : 'fc6423'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  }
  </script>

  <script src="/js/local-search.js"></script>








<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://hazyman.com/Profession/2020/Coder/',]
      });
      });
  </script>


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'C75jI23HEPhTehiFhCvUSbJY-gzGzoHsz',
      appKey     : 'qy3Id9srq8HBxwKg3CVSdNNq',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
